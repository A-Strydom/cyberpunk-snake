<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Cyberpunk Snake">
  <meta name="description" content="A cyberpunk-themed Snake game with neon visuals, smooth animations, and retro aesthetics. Play now!">
  <meta name="keywords" content="snake, game, cyberpunk, neon, retro, html5">
  <title>Cyberpunk Snake - Neon Arcade Game</title>
  <link rel="icon" href="images/snake-logo.png" type="image/png">
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Sixtyfour&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(135deg, #1a0a1f 0%, #0f0515 30%, #0a030a 60%, #000000 100%);
      font-family: 'Share Tech Mono', monospace;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #0ff;
      overflow: hidden;
      text-shadow: 0 0 8px #0ff;
      position: relative;
    }
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.15) 1px, transparent 0),
        radial-gradient(circle at 2px 2px, rgba(0, 0, 0, 0.2) 1px, transparent 0),
        radial-gradient(circle at 3px 3px, rgba(255, 255, 255, 0.1) 1px, transparent 0);
      background-size: 4px 4px, 3px 3px, 5px 5px;
      pointer-events: none;
      z-index: 1;
      opacity: 0.4;
      mix-blend-mode: overlay;
    }
    .code-stream {
      position: fixed;
      left: 20px;
      top: 0;
      width: 60px;
      height: 100%;
      font-size: 9px;
      color: rgba(200, 200, 200, 0.25);
      font-family: 'Share Tech Mono', monospace;
      line-height: 1.3;
      overflow: hidden;
      z-index: 1;
    }
    .code-stream::before {
      content: '0x1A2B\A 0x3C4D\A 0x5E6F\A 0x7890\A 0xABCD\A 0xEF01\A 0x2345\A 0x6789\A 0xFEDC\A 0xBA98\A 0x7654\A 0x3210\A 0x9ABC\A 0xDEF0\A 0x1234\A 0x5678\A 0x9ABC\A 0xDEF0\A 0x2468\A 0xACE0\A 0x1357\A 0x9BDF\A 0x0246\A 0x8ACE\A 0x1357\A 0x9BDF\A 0x2468\A 0xACE0\A 0x1357\A 0x9BDF';
      white-space: pre;
      display: block;
    }
    .text-artifacts {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.15;
    }
    .text-artifacts::before {
      content: 'ERR_0x1A2B\A DATA_CORRUPT\A SYS_FAIL\A INIT_SEQ\A LOAD_FAIL\A MEM_ERR\A PROC_TERM\A EXEC_ERR\A STACK_OVF\A NULL_PTR\A ACCESS_DEN\A INVALID_OP\A TIMEOUT\A DEADLOCK\A RACE_COND\A BUFFER_OVF';
      position: absolute;
      top: 10%;
      left: 15%;
      font-size: 7px;
      color: rgba(150, 150, 150, 0.35);
      font-family: 'Share Tech Mono', monospace;
      white-space: pre;
      line-height: 1.4;
      transform: rotate(-1.5deg);
    }
    .text-artifacts::after {
      content: '[192.168.1.42]\A [10.0.0.15]\A [172.16.0.8]\A PORT:8080\A PORT:443\A PORT:22\A PID:1234\A PID:5678\A PID:9012\A /usr/bin/\A /var/log/\A /tmp/data\A /sys/kernel\A /proc/self\A /dev/null\A /etc/config';
      position: absolute;
      bottom: 20%;
      right: 10%;
      font-size: 8px;
      color: rgba(180, 180, 180, 0.3);
      font-family: 'Share Tech Mono', monospace;
      white-space: pre;
      line-height: 1.5;
      transform: rotate(1deg);
    }
    .geometric-lines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.2;
    }
    .geometric-lines::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(90deg, rgba(0, 245, 255, 0.1) 1px, transparent 1px),
        linear-gradient(rgba(0, 245, 255, 0.1) 1px, transparent 1px),
        linear-gradient(45deg, rgba(255, 0, 64, 0.05) 1px, transparent 1px),
        linear-gradient(-45deg, rgba(255, 0, 64, 0.05) 1px, transparent 1px);
      background-size: 50px 50px, 50px 50px, 100px 100px, 100px 100px;
      background-position: 0 0, 0 0, 0 0, 0 0;
    }
    .game-title {
      position: fixed;
      top: 40px;
      left: 80px;
      z-index: 100;
      pointer-events: none;
    }
    .title-menu {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0;
    }
    .sound-menu {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0;
    }
    #menuToggle {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      width: 44px;
      height: 44px;
      padding: 0;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: text-shadow 0.2s ease, transform 0.2s ease;
      border: none;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      pointer-events: auto;
    }
    #menuToggle:hover {
      text-shadow: 0 0 10px #00f5ff;
      transform: scale(1.1);
    }
    #pauseBtnTop {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      width: 44px;
      height: 44px;
      padding: 0;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: text-shadow 0.2s ease, transform 0.2s ease;
      border: none;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      pointer-events: auto;
    }
    #pauseBtnTop:hover {
      text-shadow: 0 0 10px #00f5ff;
      transform: scale(1.1);
    }
    #pauseBtnTop .material-icons {
      font-family: 'Material Icons';
      font-size: 28px;
      color: inherit;
      line-height: 1;
      display: inline-block;
    }
    .menu-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 8px;
      background: rgba(10, 10, 30, 0.95);
      border: 1px solid #00f5ff;
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
      display: none;
      flex-direction: column;
      min-width: 160px;
      padding: 4px 0;
      pointer-events: auto;
      z-index: 200;
    }
    .menu-dropdown.open-above {
      top: auto;
      bottom: 100%;
      margin-top: 0;
      margin-bottom: 8px;
    }
    .menu-dropdown::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #00f5ff;
      pointer-events: none;
      z-index: 1;
    }
    .menu-dropdown.show {
      display: flex;
    }
    .menu-dropdown button {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 12px;
      padding: 8px 16px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: background 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      border: none;
      outline: none;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
    }
    .menu-dropdown button:hover {
      background: rgba(0, 245, 255, 0.1);
      text-shadow: 0 0 10px #00f5ff;
    }
    .menu-dropdown button .material-icons {
      font-family: 'Material Icons';
      font-size: 12px;
      color: inherit;
      line-height: 1;
      display: inline-block;
      margin-right: 4px;
      vertical-align: middle;
    }
    .game-title-main {
      font-size: 25px;
      font-weight: normal;
      color: #ffeb3b;
      text-shadow: 
        2px 2px 0 #00f5ff,
        0 0 4px rgba(0, 245, 255, 0.4),
        0 0 8px rgba(255, 235, 59, 0.8);
      letter-spacing: 2px;
      font-family: 'Sixtyfour', monospace;
      text-transform: uppercase;
      line-height: 1;
      margin-bottom: 5px;
      filter: drop-shadow(0 0 6px rgba(255, 235, 59, 0.5));
    }
    .game-title-sub {
      font-size: 20px;
      font-weight: bold;
      color: #ff6b35;
      text-shadow: 
        0 0 8px #ff6b35,
        0 0 15px rgba(255, 107, 53, 0.5);
      letter-spacing: 4px;
      font-family: 'Share Tech Mono', monospace;
      text-transform: uppercase;
      line-height: 1;
      margin-left: 2px;
    }
    .top-right-controls {
      position: fixed;
      top: 40px;
      right: 80px;
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 100;
    }
    #restart {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #restart::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #restart .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #restart:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #restart:active {
      background: rgba(255, 107, 53, 0.2);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 20px rgba(255, 0, 64, 0.8);
      text-shadow: 0 0 10px #ff0040;
    }
    #restart.clicking {
      animation: buttonGlitch 0.4s ease;
    }
    #pauseBtn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #pauseBtn::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #pauseBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #pauseBtn:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #pauseBtn:active {
      background: rgba(255, 107, 53, 0.2);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 20px rgba(255, 0, 64, 0.8);
      text-shadow: 0 0 10px #ff0040;
    }
    #soundBtn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease, opacity 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #soundBtn::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #soundBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #soundBtn:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #soundBtn.muted {
      opacity: 0.5;
    }
    #autodriveBtn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #autodriveBtn::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #autodriveBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #autodriveBtn:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #autodriveBtn.active {
      background: rgba(0, 245, 255, 0.1);
      border-color: #00f5ff;
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
    }
    #autodrivePanel {
      position: fixed;
      top: 40px;
      right: 80px;
      background: rgba(10, 10, 30, 0.95);
      border: 2px solid #00f5ff;
      border-radius: 8px;
      padding: 15px 20px;
      min-width: 280px;
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.5), inset 0 0 10px rgba(0, 245, 255, 0.1);
      z-index: 100;
      display: none;
      flex-direction: column;
      gap: 12px;
    }
    #autodrivePanel.show {
      display: flex;
    }
    .autodrive-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    .autodrive-panel-header h3 {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      margin: 0;
      text-shadow: 0 0 8px #00f5ff;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .autodrive-panel-header .autodrive-indicator {
      width: 8px;
      height: 8px;
      background: #ff6b35;
      border-radius: 50%;
      box-shadow: 0 0 8px #ff6b35;
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .autodrive-controls {
      margin: 0;
    }
    .autodrive-controls label {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 12px;
      display: block;
      margin-bottom: 8px;
      text-shadow: 0 0 4px rgba(0, 245, 255, 0.3);
    }
    .autodrive-speed-container {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .autodrive-speed-slider {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      background: rgba(0, 245, 255, 0.3);
      border-radius: 2px;
      outline: none;
      touch-action: pan-x;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      user-select: none;
    }
    .autodrive-speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      background: #00f5ff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 8px #00f5ff;
      transition: box-shadow 0.2s ease;
      touch-action: none;
    }
    .autodrive-speed-slider::-webkit-slider-thumb:hover {
      box-shadow: 0 0 12px #00f5ff;
    }
    .autodrive-speed-slider::-webkit-slider-thumb:active {
      box-shadow: 0 0 15px #00f5ff;
      transform: scale(1.1);
    }
    .autodrive-speed-slider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      background: #00f5ff;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 8px #00f5ff;
      touch-action: none;
    }
    .autodrive-speed-slider::-moz-range-thumb:active {
      box-shadow: 0 0 15px #00f5ff;
      transform: scale(1.1);
    }
    .autodrive-speed-value {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      min-width: 35px;
      text-align: right;
      text-shadow: 0 0 6px #00f5ff;
    }
    #spawnSnack {
      background: transparent;
      border: 1px solid #ffeb3b;
      color: #ffeb3b;
      font-family: 'Share Tech Mono', monospace;
      font-size: 12px;
      padding: 8px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #ffeb3b;
      box-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
      transition: all 0.3s ease;
      border-radius: 4px;
      text-transform: uppercase;
      width: 100%;
      margin-top: 5px;
    }
    #spawnSnack:hover {
      background: rgba(255, 235, 59, 0.1);
      color: #ffff00;
      border-color: #ffff00;
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
      transform: scale(1.02);
      text-shadow: 0 0 15px #ffff00;
    }
    #spawnSnack:active {
      transform: scale(0.98);
    }
    #autodriveStop {
      background: transparent;
      border: 1px solid #ff6b35;
      color: #ff6b35;
      font-family: 'Share Tech Mono', monospace;
      font-size: 12px;
      padding: 8px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #ff6b35;
      box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
      transition: all 0.3s ease;
      border-radius: 4px;
      text-transform: uppercase;
      width: 100%;
      margin-top: 5px;
    }
    #autodriveStop:hover {
      background: rgba(255, 107, 53, 0.1);
      color: #ff0040;
      border-color: #ff0040;
      box-shadow: 0 0 15px rgba(255, 0, 64, 0.8);
      transform: scale(1.02);
      text-shadow: 0 0 10px #ff0040;
    }
    @keyframes buttonGlitch {
      0%, 100% { transform: translateX(0); }
      10% { transform: translateX(-2px) translateY(1px); }
      20% { transform: translateX(2px) translateY(-1px); }
      30% { transform: translateX(-1px) translateY(2px); }
      40% { transform: translateX(1px) translateY(-2px); }
      50% { transform: translateX(-2px); }
      60% { transform: translateX(2px); }
      70% { transform: translateX(-1px); }
      80% { transform: translateX(1px); }
    }
    canvas.glitching {
      animation: boardGlitch 0.5s ease;
    }
    @keyframes boardGlitch {
      0%, 100% { 
        transform: translateX(0) translateY(0);
        filter: hue-rotate(0deg);
      }
      5% { 
        transform: translateX(-3px) translateY(2px);
        filter: hue-rotate(90deg);
      }
      10% { 
        transform: translateX(3px) translateY(-2px);
        filter: hue-rotate(-90deg);
      }
      15% { 
        transform: translateX(-2px) translateY(3px);
        filter: hue-rotate(180deg);
      }
      20% { 
        transform: translateX(2px) translateY(-3px);
        filter: hue-rotate(-180deg);
      }
      25% { 
        transform: translateX(-4px) translateY(1px);
        filter: hue-rotate(45deg);
      }
      30% { 
        transform: translateX(4px) translateY(-1px);
        filter: hue-rotate(-45deg);
      }
      35% { 
        transform: translateX(-1px) translateY(4px);
        filter: hue-rotate(135deg);
      }
      40% { 
        transform: translateX(1px) translateY(-4px);
        filter: hue-rotate(-135deg);
      }
      45% { 
        transform: translateX(-3px);
        filter: hue-rotate(90deg);
      }
      50% { 
        transform: translateX(3px);
        filter: hue-rotate(-90deg);
      }
      55% { 
        transform: translateX(-2px);
        filter: hue-rotate(0deg);
      }
      60% { 
        transform: translateX(2px);
        filter: hue-rotate(0deg);
      }
      65%, 100% { 
        transform: translateX(0) translateY(0);
        filter: hue-rotate(0deg);
      }
    }
    .score-display {
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      pointer-events: none;
      flex: 1;
    }
    .score-display strong {
      font-size: 32px;
      color: #00f5ff;
      text-shadow: 0 0 10px #00f5ff, 0 0 20px rgba(0, 245, 255, 0.5);
      font-family: 'Share Tech Mono', monospace;
    }
    .high-score-system {
      position: fixed;
      bottom: 40px;
      right: 80px;
      z-index: 100;
      font-family: 'Share Tech Mono', monospace;
      font-size: 16px;
      color: rgba(150, 150, 150, 0.6);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .high-score-system::before {
      content: '[SYS] ';
      color: rgba(0, 245, 255, 0.5);
    }
    .high-score-system strong {
      color: rgba(0, 245, 255, 0.7);
      font-weight: normal;
    }
    canvas {
      background: rgba(10, 10, 30, 0.3);
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.5), 0 0 40px rgba(255, 0, 255, 0.3), inset 0 0 12px rgba(0, 245, 255, 0.3);
      border: 2px solid rgba(0, 245, 255, 0.75);
      border-radius: 12px;
      image-rendering: pixelated;
      display: block;
      position: relative;
      z-index: 10;
    }
    #game-container {
      position: relative;
      display: inline-block;
    }
    .top-game-controls {
      position: absolute;
      top: -60px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
      width: 100%;
    }
    .top-game-controls-left {
      display: flex;
      align-items: center;
      gap: 0;
      flex: 0 0 auto;
      min-width: 44px;
    }
    .top-game-controls-right {
      display: flex;
      align-items: center;
      gap: 0;
      flex: 0 0 auto;
      min-width: 44px;
      justify-content: flex-end;
    }
    #gameOver {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(5, 0, 17, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }
    #gameOver.show {
      display: flex;
    }
    .game-over-content {
      text-align: center;
    }
    .flatlined-text {
      font-size: 72px;
      font-weight: bold;
      color: #ff0040;
      text-shadow: 
        0 0 4px rgba(255, 0, 64, 0.8),
        0 0 10px rgba(255, 0, 64, 0.48),
        0 0 18px rgba(255, 0, 64, 0.32),
        0 0 28px rgba(255, 0, 64, 0.24),
        0 0 40px rgba(255, 0, 64, 0.16);
      margin-bottom: 20px;
      letter-spacing: 8px;
      filter: brightness(1.1);
    }
    .flatlined-text.perfect-score {
      color: #00ff00;
      text-shadow: 
        0 0 4px rgba(0, 255, 0, 0.8),
        0 0 10px rgba(0, 255, 0, 0.48),
        0 0 18px rgba(0, 255, 0, 0.32),
        0 0 28px rgba(0, 255, 0, 0.24),
        0 0 40px rgba(0, 255, 0, 0.16);
    }
    .game-over-subtitle {
      font-size: 24px;
      color: #ff0040;
      text-shadow: 0 0 10px #ff0040;
      margin-bottom: 30px;
    }
    .game-over-subtitle.perfect-score {
      color: #00ff00;
      text-shadow: 0 0 10px #00ff00;
    }
    .final-score {
      font-size: 42px;
      color: #00f5ff;
      text-shadow: 0 0 15px #00f5ff;
      margin-bottom: 40px;
    }
    .final-score span {
      display: block;
      font-size: 36px;
      color: #00f5ff;
      margin-top: 10px;
    }
    #restartGame {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      padding: 15px 40px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 15px #00f5ff;
      transition: all 0.3s ease;
      border-radius: 6px;
    }
    #restartGame:hover {
      background: rgba(0, 245, 255, 0.1);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 25px #ffeb3b;
      transform: scale(1.1);
      text-shadow: 0 0 15px #ffeb3b;
    }
    #startGame {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 24px;
      padding: 18px 50px;
      cursor: pointer;
      text-shadow: 0 0 10px #00f5ff;
      box-shadow: 0 0 20px #00f5ff;
      transition: all 0.3s ease;
      border-radius: 6px;
      text-transform: uppercase;
      letter-spacing: 2px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 200;
      display: none;
    }
    #startGame.show {
      display: block;
    }
    #startGame:hover {
      background: rgba(0, 245, 255, 0.15);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 30px #ffeb3b;
      transform: translate(-50%, -50%) scale(1.05);
      text-shadow: 0 0 20px #ffeb3b;
    }
    #startGame:active {
      transform: translate(-50%, -50%) scale(0.98);
    }
    #helpModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }
    #helpModal.show {
      display: flex;
    }
    #controlModeModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }
    #controlModeModal.show {
      display: flex;
    }
    #closeControlMode {
      position: absolute;
      top: 15px;
      right: 15px;
      background: transparent;
      border: 1px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      width: 35px;
      height: 35px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
      transition: all 0.2s ease;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #closeControlMode:hover {
      background: rgba(0, 245, 255, 0.1);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 15px rgba(255, 0, 64, 0.5);
      text-shadow: 0 0 10px #ff0040;
    }
    #confirmModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }
    #confirmModal.show {
      display: flex;
    }
    .confirm-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 20px;
    }
    .confirm-btn {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 16px;
      padding: 12px 30px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
      transition: all 0.3s ease;
      border-radius: 6px;
      text-transform: uppercase;
    }
    .confirm-btn:hover {
      background: rgba(0, 245, 255, 0.1);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 25px rgba(255, 235, 59, 0.8);
      transform: scale(1.05);
      text-shadow: 0 0 15px #ffeb3b;
    }
    .reset-btn {
      border-color: #ff6b35 !important;
      color: #ff6b35 !important;
      text-shadow: 0 0 8px #ff6b35 !important;
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.5) !important;
    }
    .reset-btn:hover {
      background: rgba(255, 107, 53, 0.1) !important;
      color: #ff6b35 !important;
      border-color: #ff6b35 !important;
      box-shadow: 0 0 20px rgba(255, 107, 53, 0.7) !important;
      text-shadow: 0 0 12px #ff6b35 !important;
    }
    .reset-btn .material-icons {
      color: inherit !important;
      text-shadow: inherit !important;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .help-content {
      background: linear-gradient(135deg, rgba(10, 10, 30, 0.95) 0%, rgba(15, 5, 25, 0.95) 100%);
      border: 2px solid #00f5ff;
      border-radius: 8px;
      padding: 40px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(0, 245, 255, 0.5), inset 0 0 20px rgba(0, 245, 255, 0.1);
      position: relative;
      animation: slideIn 0.3s ease;
    }
    @keyframes slideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .help-content h2 {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      margin: 0 0 20px 0;
      text-shadow: 0 0 10px #00f5ff;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .help-content h3 {
      color: #ffeb3b;
      font-family: 'Share Tech Mono', monospace;
      font-size: 18px;
      margin: 25px 0 10px 0;
      text-shadow: 0 0 8px rgba(255, 235, 59, 0.5);
    }
    .help-content p {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      line-height: 1.8;
      margin: 10px 0;
      text-shadow: 0 0 4px rgba(0, 245, 255, 0.3);
    }
    #confirmModal .help-content p {
      text-align: center;
    }
    .help-content ul {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      line-height: 2;
      margin: 10px 0;
      padding-left: 25px;
      text-shadow: 0 0 4px rgba(0, 245, 255, 0.3);
    }
    .help-content li {
      margin: 8px 0;
    }
    .help-content .key {
      display: inline-block;
      background: rgba(0, 245, 255, 0.2);
      border: 1px solid #00f5ff;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: bold;
      color: #ffeb3b;
      text-shadow: 0 0 6px rgba(255, 235, 59, 0.8);
      margin: 0 2px;
    }
    #controlModeSelect {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2300f5ff' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 40px;
    }
    #controlModeSelect:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.7);
    }
    #controlModeSelect:focus {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.7);
    }
    #controlModeSelect option {
      background: rgba(10, 10, 30, 0.95);
      color: #00f5ff;
    }
    #closeHelp {
      position: absolute;
      top: 15px;
      right: 15px;
      background: transparent;
      border: 1px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      width: 35px;
      height: 35px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
      transition: all 0.2s ease;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #closeHelp:hover {
      background: rgba(0, 245, 255, 0.1);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 15px rgba(255, 0, 64, 0.5);
      text-shadow: 0 0 10px #ff0040;
    }
    .direction-controls {
      position: fixed;
      bottom: 40px;
      left: 80px;
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      gap: 5px;
      z-index: 1000;
      user-select: none;
    }
    .direction-controls.dragging {
      cursor: grabbing;
    }
    .direction-controls.dragging .direction-btn {
      pointer-events: none;
    }
    .direction-controls-handle {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 20px;
      background: rgba(10, 10, 30, 0.9);
      border: 1px solid #00f5ff;
      border-radius: 4px 4px 0 0;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      z-index: 1001;
      transition: all 0.2s ease;
    }
    .direction-controls-handle:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
    }
    .direction-controls-handle:active {
      cursor: grabbing;
    }
    .direction-controls-handle::before {
      content: '⋮⋮';
      color: #00f5ff;
      font-size: 12px;
      letter-spacing: 2px;
      text-shadow: 0 0 6px #00f5ff;
    }
    .relative-turn-control {
      position: fixed;
      z-index: 1000;
      user-select: none;
      display: none;
    }
    .relative-turn-control.show {
      display: block;
    }
    .relative-turn-control-handle {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 20px;
      background: rgba(10, 10, 30, 0.9);
      border: 1px solid #00f5ff;
      border-radius: 4px 4px 0 0;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      z-index: 1001;
      transition: all 0.2s ease;
    }
    .relative-turn-control-handle:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
    }
    .relative-turn-control-handle:active {
      cursor: grabbing;
    }
    .relative-turn-control-handle::before {
      content: '⋮⋮';
      color: #00f5ff;
      font-size: 12px;
      letter-spacing: 2px;
      text-shadow: 0 0 6px #00f5ff;
    }
    .relative-turn-control.dragging .relative-turn-btn {
      pointer-events: none;
    }
    .relative-turn-btn {
      width: 60px;
      height: 60px;
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 24px;
      border: 2px solid #00f5ff;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      outline: none;
      border-radius: 8px;
    }
    .relative-turn-btn:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    .relative-turn-btn:active {
      background: rgba(0, 245, 255, 0.2);
      transform: scale(0.95);
    }
    .relative-turn-btn .material-icons {
      font-family: 'Material Icons';
      font-size: 32px;
      color: inherit;
      line-height: 1;
    }
    .split-control {
      position: fixed;
      z-index: 1000;
      user-select: none;
      display: none;
    }
    .split-control.show {
      display: block;
    }
    .split-control-handle {
      position: absolute;
      top: -25px;
      left: 0;
      width: 40px;
      height: 20px;
      background: rgba(10, 10, 30, 0.9);
      border: 1px solid #00f5ff;
      border-radius: 4px 4px 0 0;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      z-index: 1001;
      transition: all 0.2s ease;
    }
    #splitControlLeftHandle {
      left: 60px; /* Center over column 2 (50px + 5px gap + 5px offset to center 40px handle) */
    }
    #splitControlRightHandle {
      left: 5px; /* Center over column 1 (5px offset to center 40px handle over 50px column) */
    }
    .split-control-handle:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
    }
    .split-control-handle:active {
      cursor: grabbing;
    }
    .split-control-handle::before {
      content: '⋮⋮';
      color: #00f5ff;
      font-size: 12px;
      letter-spacing: 2px;
      text-shadow: 0 0 6px #00f5ff;
    }
    .split-control.dragging .split-btn {
      pointer-events: none;
    }
    .split-control-buttons {
      display: grid;
      grid-template-columns: 50px 50px;
      grid-template-rows: 50px 50px 50px;
      gap: 5px;
      position: relative;
    }
    .split-btn {
      width: 50px;
      height: 50px;
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      border: 1px solid #00f5ff;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      outline: none;
      border-radius: 4px;
    }
    .split-btn:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    .split-btn:active {
      background: rgba(0, 245, 255, 0.2);
      transform: scale(0.95);
    }
    .split-btn .material-icons {
      font-family: 'Material Icons';
      font-size: 24px;
      color: inherit;
      line-height: 1;
    }
    .split-btn.empty {
      background: transparent;
      border: none;
      cursor: default;
      box-shadow: none;
    }
    .split-btn.empty:hover {
      background: transparent;
      box-shadow: none;
    }
    .direction-btn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      border: 1px solid #00f5ff;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      outline: none;
    }
    .direction-btn:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    .direction-btn:active {
      background: rgba(0, 245, 255, 0.2);
      transform: scale(0.95);
    }
    .direction-btn.empty {
      background: transparent;
      border: none;
      cursor: default;
      box-shadow: none;
    }
    .direction-btn.empty:hover {
      background: transparent;
      box-shadow: none;
    }
    .direction-btn .material-icons {
      font-family: 'Material Icons';
      font-size: 24px;
      color: inherit;
      line-height: 1;
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body {
        overflow-y: auto;
        padding: 10px;
        min-height: 100vh;
        height: auto;
      }

      .game-title {
        top: 15px;
        left: 15px;
        position: fixed;
        max-width: calc(50% - 20px);
      }

      .game-title-main {
        font-size: 18px;
      }

      .game-title-sub {
        font-size: 14px;
        letter-spacing: 2px;
      }

      .top-game-controls {
        top: -50px;
      }

      #menuToggle {
        font-size: 24px;
        width: 36px;
        height: 36px;
      }

      #pauseBtnTop {
        font-size: 24px;
        width: 36px;
        height: 36px;
      }

      #pauseBtnTop .material-icons {
        font-size: 24px;
      }

      #autodriveBtn {
        font-size: 11px;
        padding: 8px 12px;
        min-height: 40px;
      }

      #autodriveBtn .material-icons {
        font-size: 16px;
      }

      #autodrivePanel {
        top: 10px;
        right: 10px;
        min-width: 200px;
        padding: 10px 12px;
      }

      .autodrive-panel-header h3 {
        font-size: 12px;
      }

      .autodrive-controls label {
        font-size: 11px;
      }

      .autodrive-speed-value {
        font-size: 12px;
      }


      #spawnSnack {
        font-size: 11px;
        padding: 6px 15px;
      }

      #autodriveStop {
        font-size: 11px;
        padding: 6px 15px;
      }

      #soundBtn {
        font-size: 11px;
        padding: 8px 12px;
        min-height: 40px;
      }

      #soundBtn .material-icons {
        font-size: 16px;
      }

      .menu-dropdown {
        bottom: 42px;
        min-width: 140px;
      }

      .menu-dropdown button {
        font-size: 11px;
        padding: 6px 12px;
        white-space: nowrap;
      }

      .top-right-controls {
        top: 15px;
        right: 15px;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
        flex-direction: row;
        align-items: flex-start;
        max-width: calc(50% - 20px);
      }

      #restart {
        font-size: 11px;
        padding: 8px 12px;
        min-height: 40px;
        touch-action: manipulation;
        flex: 0 0 auto;
        min-width: 75px;
        white-space: nowrap;
      }

      #game-container {
        margin-top: 80px;
        margin-bottom: 20px;
      }

      canvas {
        width: 100% !important;
        max-width: 100vw;
        height: auto !important;
        max-height: calc(100vh - 300px);
        aspect-ratio: 1;
      }

      .score-display strong {
        font-size: 24px;
      }

      .high-score-system {
        bottom: 15px;
        right: 15px;
        font-size: 12px;
        position: fixed;
      }

      .code-stream, .text-artifacts {
        display: none;
      }

      .help-content {
        padding: 25px;
        max-width: 95%;
        max-height: 90vh;
      }

      .help-content h2 {
        font-size: 22px;
      }

      .help-content h3 {
        font-size: 16px;
      }

      .help-content p, .help-content li {
        font-size: 12px;
      }

      .game-over-content {
        padding: 20px;
      }

      .flatlined-text {
        font-size: 48px;
        text-shadow: 
          0 0 3px rgba(255, 0, 64, 0.8),
          0 0 7px rgba(255, 0, 64, 0.48),
          0 0 12px rgba(255, 0, 64, 0.32),
          0 0 20px rgba(255, 0, 64, 0.24),
          0 0 28px rgba(255, 0, 64, 0.16);
      }
      .flatlined-text.perfect-score {
        text-shadow: 
          0 0 3px rgba(0, 255, 0, 0.8),
          0 0 7px rgba(0, 255, 0, 0.48),
          0 0 12px rgba(0, 255, 0, 0.32),
          0 0 20px rgba(0, 255, 0, 0.24),
          0 0 28px rgba(0, 255, 0, 0.16);
      }

      .game-over-subtitle {
        font-size: 18px;
      }
      .game-over-subtitle.perfect-score {
        color: #00ff00;
        text-shadow: 0 0 8px #00ff00;
      }

      #restartGame {
        font-size: 16px;
        padding: 12px 30px;
        min-height: 44px;
      }

      .direction-controls {
        bottom: 15px;
        left: 15px;
        grid-template-columns: repeat(3, 45px);
        grid-template-rows: repeat(3, 45px);
        gap: 4px;
      }

      .direction-btn {
        font-size: 18px;
      }

      .direction-btn .material-icons {
        font-size: 20px;
      }
    }

    @media (max-width: 480px) {
      .top-game-controls {
        top: -45px;
      }

      .game-title-main {
        font-size: 16px;
      }

      .game-title-sub {
        font-size: 12px;
      }

      .game-title {
        max-width: calc(45% - 15px);
      }

      .top-right-controls {
        gap: 6px;
        top: 10px;
        right: 10px;
        max-width: calc(55% - 15px);
      }

      #autodrivePanel {
        top: 8px;
        right: 8px;
        min-width: 180px;
        padding: 8px 10px;
      }

      .autodrive-panel-header h3 {
        font-size: 11px;
      }

      .autodrive-controls label {
        font-size: 10px;
      }

      .autodrive-speed-value {
        font-size: 11px;
      }


      #spawnSnack {
        font-size: 10px;
        padding: 5px 12px;
      }

      #autodriveStop {
        font-size: 10px;
        padding: 5px 12px;
      }

      #restart {
        font-size: 10px;
        padding: 6px 10px;
        min-width: 65px;
        min-height: 38px;
      }

      #autodriveBtn {
        font-size: 10px;
        padding: 6px 10px;
        min-height: 38px;
      }

      #autodriveBtn .material-icons {
        font-size: 14px;
      }

      .score-display strong {
        font-size: 20px;
      }

      #menuToggle {
        font-size: 20px;
        width: 32px;
        height: 32px;
      }

      #pauseBtnTop {
        font-size: 20px;
        width: 32px;
        height: 32px;
      }

      #pauseBtnTop .material-icons {
        font-size: 20px;
      }

      #soundBtn {
        font-size: 10px;
        padding: 6px 10px;
        min-height: 38px;
      }

      #soundBtn .material-icons {
        font-size: 14px;
      }

      .high-score-system {
        font-size: 11px;
      }

      .help-content {
        padding: 20px;
      }

      .direction-controls {
        bottom: 10px;
        left: 10px;
        grid-template-columns: repeat(3, 40px);
        grid-template-rows: repeat(3, 40px);
        gap: 3px;
      }

      .direction-btn {
        font-size: 16px;
      }

      .direction-btn .material-icons {
        font-size: 18px;
      }

      #startGame {
        font-size: 18px;
        padding: 14px 35px;
      }
    }

    /* Prevent text selection on buttons for better mobile UX */
    button {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      user-select: none;
      -webkit-user-select: none;
    }

    /* Prevent pull-to-refresh on mobile */
    body {
      overscroll-behavior-y: contain;
    }

    canvas {
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="game-title">
    <div class="game-title-main">Cyberpunk</div>
    <div class="game-title-sub">SNAKE</div>
  </div>
  <div class="code-stream"></div>
  <div class="text-artifacts"></div>
  <div class="geometric-lines"></div>
  <div class="top-right-controls">
    <button id="restart" title="Restart">REBOOT<span class="material-icons">power_settings_new</span></button>
    <button id="autodriveBtn" title="Autodrive Mode"><span class="material-icons">settings</span>AUTODRIVE</button>
    <button id="soundBtn" title="Toggle Sound"><span class="material-icons">volume_up</span></button>
  </div>
  <div id="game-container">
    <div class="top-game-controls">
      <div class="top-game-controls-left">
        <div class="title-menu">
          <button id="menuToggle" title="Menu">☰</button>
          <div class="menu-dropdown" id="menuDropdown">
            <button id="clearHighScoreBtn" title="Clear High Score"><span class="material-icons">do_not_disturb</span> CLEAR HIGH SCORE</button>
            <button id="controlModeBtn" title="Control Mode"><span class="material-icons">gamepad</span> CONTROL MODE</button>
            <button id="helpBtn" title="How to Play"><span class="material-icons">help</span> HELP</button>
          </div>
        </div>
      </div>
      <div class="score-display">
        <strong id="score">0</strong>
      </div>
      <div class="top-game-controls-right">
        <button id="pauseBtnTop" title="Pause/Resume"><span class="material-icons">pause</span></button>
      </div>
    </div>
    <canvas id="game"></canvas>
    <button id="startGame">START GAME</button>
  </div>
  <div id="helpModal">
    <div class="help-content">
      <button id="closeHelp" title="Close">×</button>
      <h2>HOW TO PLAY</h2>
      
      <h3>Objective</h3>
      <p>Control the snake to eat food and grow longer. Avoid hitting the walls or your own tail!</p>
      
      <h3>Controls</h3>
      <ul>
        <li><span class="key">↑</span> <span class="key">↓</span> <span class="key">←</span> <span class="key">→</span> Arrow keys to change direction</li>
        <li><span class="key">Swipe</span> on mobile devices</li>
        <li><span class="key">Direction Buttons</span> on mobile</li>
      </ul>
      
      <h3>Gameplay</h3>
      <ul>
        <li>The snake moves continuously in the current direction</li>
        <li>Eat the glowing food to grow and increase your score</li>
        <li>Each food item increases your score by 10 points</li>
        <li>The snake wraps around walls (goes through to the opposite side)</li>
        <li>The game ends only if you hit your own body</li>
        <li>The snake moves faster as your score increases</li>
      </ul>
      
      <h3>Tips</h3>
      <ul>
        <li>Plan your path to avoid trapping yourself</li>
        <li>Use wall wrapping to escape tight situations</li>
        <li>Keep moving - the snake never stops!</li>
      </ul>
    </div>
  </div>
  <div id="autodrivePanel">
    <div class="autodrive-panel-header">
      <h3>AUTODRIVE MODE</h3>
      <div class="autodrive-indicator"></div>
    </div>
    <div class="autodrive-controls">
      <label>SPEED:</label>
      <div class="autodrive-speed-container">
        <input type="range" id="autodriveSpeed" class="autodrive-speed-slider" min="0.5" max="10" step="0.5" value="1">
        <span id="autodriveSpeedValue" class="autodrive-speed-value">1x</span>
      </div>
      <button id="spawnSnack">SPAWN SNACKS</button>
    </div>
    <button id="autodriveStop">STOP</button>
  </div>
  <div id="confirmModal">
    <div class="help-content">
      <h2>CONFIRM</h2>
      <p>Are you sure you want to clear your high score?</p>
      <div class="confirm-buttons">
        <button id="confirmYes" class="confirm-btn">YES</button>
        <button id="confirmNo" class="confirm-btn">NO - ONE MORE GIG</button>
      </div>
    </div>
  </div>
  <div id="controlModeModal">
    <div class="help-content">
      <button id="closeControlMode" title="Close">×</button>
      <h2>CONTROL MODE</h2>
      <p>Choose how the directional controls work:</p>
      <div style="margin-top: 20px;">
        <select id="controlModeSelect" style="width: 100%; padding: 12px; background: rgba(10, 10, 30, 0.9); border: 2px solid #00f5ff; color: #00f5ff; font-family: 'Share Tech Mono', monospace; font-size: 14px; border-radius: 6px; text-transform: uppercase; cursor: pointer; outline: none; box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);">
          <option value="none">NONE</option>
          <option value="absolute">ABSOLUTE DIRECTIONS</option>
          <option value="relative">RELATIVE TURNS (LEFT/RIGHT)</option>
          <option value="split">SPLIT DIRECTIONS (LEFT/RIGHT SIDES)</option>
        </select>
        <p id="controlModeDescription" style="margin-top: 15px; font-size: 12px; opacity: 0.8; color: #00f5ff; text-shadow: 0 0 4px rgba(0, 245, 255, 0.3); padding-left: 4px; min-height: 40px;">
          No touch controls displayed. Use keyboard or swipe gestures to play.
        </p>
        <button id="resetControlPositions" class="confirm-btn reset-btn" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px; margin-top: 20px;">
          <span class="material-icons" style="font-size: 20px; line-height: 1; display: flex; align-items: center;">refresh</span>
          <span>RESET CONTROL POSITIONS</span>
        </button>
        <p style="margin-top: 8px; font-size: 12px; opacity: 0.8; color: #ff6b35; text-shadow: 0 0 4px rgba(255, 107, 53, 0.3); padding-left: 4px;">
          Reset all control positions to their default locations.
        </p>
      </div>
    </div>
  </div>
  <div class="high-score-system">
    HIGH SCORE: <strong id="highscore">0</strong>
  </div>
  <div class="direction-controls" id="directionControls">
    <div class="direction-controls-handle" id="directionControlsHandle"></div>
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnUp" title="Up"><span class="material-icons">arrow_upward</span></button>
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnLeft" title="Left"><span class="material-icons">arrow_back</span></button>
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnRight" title="Right"><span class="material-icons">arrow_forward</span></button>
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnDown" title="Down"><span class="material-icons">arrow_downward</span></button>
    <div class="direction-btn empty"></div>
  </div>
  <div class="relative-turn-control" id="relativeTurnLeft">
    <div class="relative-turn-control-handle" id="relativeTurnLeftHandle"></div>
    <button class="relative-turn-btn" id="btnTurnLeft" title="Turn Left"><span class="material-icons">rotate_left</span></button>
  </div>
  <div class="relative-turn-control" id="relativeTurnRight">
    <div class="relative-turn-control-handle" id="relativeTurnRightHandle"></div>
    <button class="relative-turn-btn" id="btnTurnRight" title="Turn Right"><span class="material-icons">rotate_right</span></button>
  </div>
  <div class="split-control" id="splitControlLeft">
    <div class="split-control-handle" id="splitControlLeftHandle"></div>
    <div class="split-control-buttons">
      <button class="split-btn" id="splitBtnUpLeft" title="Up" style="grid-column: 2; grid-row: 1;"><span class="material-icons">arrow_upward</span></button>
      <button class="split-btn" id="splitBtnDownLeft" title="Down" style="grid-column: 2; grid-row: 2;"><span class="material-icons">arrow_downward</span></button>
      <button class="split-btn" id="splitBtnLeft" title="Left" style="grid-column: 1; grid-row: 1; margin-top: 30px"><span class="material-icons">arrow_back</span></button>
    </div>
  </div>
  <div class="split-control" id="splitControlRight">
    <div class="split-control-handle" id="splitControlRightHandle"></div>
    <div class="split-control-buttons">
      <button class="split-btn" id="splitBtnUpRight" title="Up" style="grid-column: 1; grid-row: 1;"><span class="material-icons">arrow_upward</span></button>
      <button class="split-btn" id="splitBtnDownRight" title="Down" style="grid-column: 1; grid-row: 2;"><span class="material-icons">arrow_downward</span></button>
      <button class="split-btn" id="splitBtnRight" title="Right" style="grid-column: 2; grid-row: 1; margin-top: 30px;"><span class="material-icons">arrow_forward</span></button>
    </div>
  </div>
  <div id="gameOver">
    <div class="game-over-content">
      <div class="flatlined-text">FLATLINED</div>
      <div class="game-over-subtitle">SYSTEM FAILURE DETECTED</div>
      <div class="final-score">
        Final Score: <span id="finalScore">0</span>
      </div>
      <button id="restartGame">REBOOT SYSTEM</button>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highscoreEl = document.getElementById('highscore');
    const restartBtn = document.getElementById('restart');
    const gameOverEl = document.getElementById('gameOver');
    const finalScoreEl = document.getElementById('finalScore');
    const restartGameBtn = document.getElementById('restartGame');
    const startGameBtn = document.getElementById('startGame');

    // Game constants
    const GRID_SIZE = 20;
    const CELL_SIZE = 20;
    const INITIAL_SPEED = 150; // milliseconds per move (constant speed)

    // Game state
    let snake = [{ x: 0, y: 0 }]; // Start at top left
    let direction = { x: 1, y: 0 };
    let nextDirection = { x: 1, y: 0 };
    let directionQueue = []; // Queue to capture rapid key presses
    let food = [{ x: 4, y: 0, type: null }]; // Array of food items - initial food at cell 4 in top row for immediate catch (type will be set in draw)
    let score = 10; // Snake starts with 1 segment = 10 points
    let highscore = parseInt(localStorage.getItem('snakeHighscore') || '0', 10) || 0;
    let gameRunning = false;
    let gameOver = false;
    let gamePaused = false;
    let gameLoop = null;
    let currentSpeed = INITIAL_SPEED;
    let lastMoveTime = 0;
    let animationFrameId = null;
    let hyperSpeedLoopId = null;
    let autodriveActive = false;
    let autodriveSpeed = 1.0;
    let tongueAnimation = 0; // 0 to 1, cycles for tongue animation
    let scalePattern = null; // Cached scale pattern for performance

    // Responsive canvas sizing
    function getCanvasSize() {
      const maxSize = 500;
      const isMobile = window.innerWidth <= 768;
      if (isMobile) {
        const viewportWidth = window.innerWidth - 40;
        const viewportHeight = window.innerHeight - 300;
        return Math.min(viewportWidth, viewportHeight, maxSize);
      }
      return maxSize;
    }

    let logicalSize = getCanvasSize();
    const scale = window.devicePixelRatio || 1;
    let cellSize = Math.floor(logicalSize / GRID_SIZE);
    let gridSize = GRID_SIZE;

    function resizeCanvas() {
      logicalSize = getCanvasSize();
      if (logicalSize < 200) logicalSize = 200;
      
      cellSize = Math.floor(logicalSize / GRID_SIZE);
      const actualSize = cellSize * GRID_SIZE;
      
      canvas.width = actualSize * scale;
      canvas.height = actualSize * scale;
      canvas.style.width = actualSize + 'px';
      canvas.style.height = actualSize + 'px';
      ctx.setTransform(scale, 0, 0, scale, 0, 0);
      
      if (gameRunning || gameOver) {
        draw();
      }
    }

    resizeCanvas();
    window.addEventListener('resize', () => {
      setTimeout(resizeCanvas, 150);
      // Reposition controls if in relative or split mode and not manually positioned
      if (controlMode === 'relative') {
        setTimeout(() => {
          positionRelativeControlsAtBottom();
        }, 200);
      } else if (controlMode === 'split') {
        setTimeout(() => {
          positionSplitControlsOnSides();
        }, 200);
      }
    });
    window.addEventListener('orientationchange', () => {
      setTimeout(resizeCanvas, 100);
      // Reposition controls if in relative or split mode and not manually positioned
      if (controlMode === 'relative') {
        setTimeout(() => {
          positionRelativeControlsAtBottom();
        }, 200);
      } else if (controlMode === 'split') {
        setTimeout(() => {
          positionSplitControlsOnSides();
        }, 200);
      }
    });

    // Sound Manager
    const SoundManager = {
      audioContext: null,
      masterGain: null,
      enabled: true,
      hasUserInteracted: false,
      noteIndex: 0, // Track current note in sequence for musical patterns
      
      // Musical scale (pentatonic scale in C major) - sounds pleasing in any order
      // C, D, E, G, A, C (octave)
      musicalScale: [261.63, 293.66, 329.63, 392.00, 440.00, 523.25],
      
      init() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          // Create master gain node for better control and to prevent clipping
          this.masterGain = this.audioContext.createGain();
          this.masterGain.gain.value = 0.9; // Slight headroom to prevent clipping
          this.masterGain.connect(this.audioContext.destination);
          
          const soundPref = localStorage.getItem('soundEnabled');
          this.enabled = soundPref === null ? true : soundPref === 'true';
          this.updateButton();
        } catch (e) {
          console.warn('Web Audio API not supported:', e);
          this.enabled = false;
        }
      },
      
      getNextNote() {
        const note = this.musicalScale[this.noteIndex];
        this.noteIndex = (this.noteIndex + 1) % this.musicalScale.length;
        return note;
      },
      
      resetSequence() {
        this.noteIndex = 0;
      },
      
      updateButton() {
        const soundBtn = document.getElementById('soundBtn');
        if (soundBtn) {
          const icon = soundBtn.querySelector('.material-icons');
          if (icon) {
            if (this.enabled) {
              soundBtn.classList.remove('muted');
              icon.textContent = 'volume_up';
            } else {
              soundBtn.classList.add('muted');
              icon.textContent = 'volume_off';
            }
          }
        }
      },
      
      async ensureResumed() {
        if (!this.audioContext) return;
        if (this.audioContext.state === 'suspended') {
          if (!this.hasUserInteracted) return;
          try {
            await this.audioContext.resume();
          } catch (e) {}
        }
      },
      
      toggle() {
        this.enabled = !this.enabled;
        localStorage.setItem('soundEnabled', this.enabled.toString());
        this.updateButton();
        if (this.enabled) {
          this.playDirectionChange();
        }
      },
      
      activeOscillators: [],
      
      playTone(frequency, duration, type = 'sine', volume = 0.3) {
        if (!this.enabled || !this.audioContext || !this.masterGain) return;
        if (this.audioContext.state === 'suspended' && !this.hasUserInteracted) return;
        
        // Ensure audio context is resumed (non-blocking)
        this.ensureResumed().catch(() => {});
        
        // Play immediately - Web Audio API is already non-blocking
        try {
          if (this.audioContext.state === 'suspended') return;
          
          const now = this.audioContext.currentTime;
          const startTime = now + 0.001; // Small delay to prevent clicks
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          
          // Connect through master gain for better control
          oscillator.connect(gainNode);
          gainNode.connect(this.masterGain);
          
          oscillator.type = type;
          oscillator.frequency.setValueAtTime(frequency, startTime);
          
          // Smooth envelope with exponential curves to prevent clicks/pops
          const attackTime = 0.005; // Slightly longer attack for smoother start
          const releaseTime = Math.min(0.02, duration * 0.3); // Release time (20ms or 30% of duration)
          const sustainTime = Math.max(0, duration - attackTime - releaseTime);
          
          // Set initial gain to very small value (exponential ramps can't start from 0)
          gainNode.gain.setValueAtTime(0.0001, startTime);
          
          // Smooth attack using exponential ramp
          gainNode.gain.exponentialRampToValueAtTime(volume, startTime + attackTime);
          
          // Sustain
          if (sustainTime > 0) {
            gainNode.gain.setValueAtTime(volume, startTime + attackTime + sustainTime);
          }
          
          // Smooth release using exponential ramp
          gainNode.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);
          
          oscillator.start(startTime);
          oscillator.stop(startTime + duration + 0.01); // Small buffer for cleanup
          
          // Track active oscillators for potential cleanup
          this.activeOscillators.push(oscillator);
          oscillator.onended = () => {
            const index = this.activeOscillators.indexOf(oscillator);
            if (index > -1) {
              this.activeOscillators.splice(index, 1);
            }
            // Clean up nodes
            try {
              oscillator.disconnect();
              gainNode.disconnect();
            } catch (e) {}
          };
        } catch (e) {
          // Silently fail
        }
      },
      
      playDirectionChange() {
        // Play next note in the musical sequence for direction changes
        this.ensureResumed().catch(() => {});
        const note = this.getNextNote();
        this.playTone(note, 0.12, 'sine', 0.2);
      },
      
      playEat() {
        // Play next note in the musical sequence for eating snacks
        // Use a chord (note + fifth) for a richer, more satisfying sound
        this.ensureResumed().catch(() => {});
        const note = this.getNextNote();
        const fifth = note * 1.5; // Perfect fifth interval
        this.playTone(note, 0.18, 'sine', 0.22);
        setTimeout(() => {
          this.playTone(fifth, 0.15, 'sine', 0.18);
        }, 30);
      },
      
      playInvalidMove() {
        // Low, short error sound for invalid moves
        if (!this.enabled || !this.audioContext) return;
        
        // Mark user interaction if not already marked (for error sounds)
        if (!this.hasUserInteracted) {
          this.hasUserInteracted = true;
        }
        
        this.ensureResumed().catch(() => {});
        // Use a slightly longer duration for better feedback
        this.playTone(100, 0.2, 'sawtooth', 0.05);
      },
      
      playGameOver() {
        // Non-blocking sound
        this.ensureResumed().catch(() => {});
        const frequencies = [300, 250, 200, 150];
        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            this.playTone(freq, 0.2, 'sine', 0.3);
          }, index * 100);
        });
      },
      
      playGlitch() {
        // Non-blocking sound
        this.ensureResumed().catch(() => {});
        const frequencies = [200, 150, 250, 180];
        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            this.playTone(freq, 0.08, 'square', 0.15);
          }, index * 30);
        });
      },
      
      playVictory() {
        // Celebration sound - ascending tones
        this.ensureResumed().catch(() => {});
        const frequencies = [400, 500, 600, 700, 800, 900, 1000];
        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            this.playTone(freq, 0.15, 'sine', 0.3);
          }, index * 80);
        });
        // Add a final triumphant chord
        setTimeout(() => {
          this.playTone(600, 0.3, 'sine', 0.4);
          setTimeout(() => {
            this.playTone(800, 0.3, 'sine', 0.4);
            setTimeout(() => {
              this.playTone(1000, 0.3, 'sine', 0.4);
            }, 50);
          }, 50);
        }, frequencies.length * 80);
      }
    };
    
    SoundManager.init();

    // Resume audio context on first user interaction
    let audioContextResumed = false;
    function resumeAudioOnInteraction() {
      if (!audioContextResumed && SoundManager.audioContext) {
        audioContextResumed = true;
        SoundManager.hasUserInteracted = true;
        SoundManager.ensureResumed().catch(() => {});
      }
    }
    
    document.addEventListener('touchstart', resumeAudioOnInteraction, { once: true, passive: true, capture: true });
    document.addEventListener('click', resumeAudioOnInteraction, { once: true, capture: true });
    document.addEventListener('keydown', resumeAudioOnInteraction, { once: true, capture: true });
    window.addEventListener('touchstart', resumeAudioOnInteraction, { once: true, passive: true, capture: true });
    window.addEventListener('click', resumeAudioOnInteraction, { once: true, capture: true });

    // Food types with different shapes and colors (same size)
    const foodTypes = [
      { shape: 'circle', size: 0.7, color: '#ffeb3b', glowColor: 'rgba(255, 235, 59, 0.8)' }, // Yellow circle
      { shape: 'square', size: 0.7, color: '#ff6b35', glowColor: 'rgba(255, 107, 53, 0.8)' }, // Orange square
      { shape: 'diamond', size: 0.7, color: '#00f5ff', glowColor: 'rgba(0, 245, 255, 0.8)' }, // Cyan diamond
      { shape: 'star', size: 0.7, color: '#ff0040', glowColor: 'rgba(255, 0, 64, 0.8)' }, // Red star
      { shape: 'triangle', size: 0.7, color: '#9664ff', glowColor: 'rgba(150, 100, 255, 0.8)' }, // Purple triangle
      { shape: 'hexagon', size: 0.7, color: '#00ff88', glowColor: 'rgba(0, 255, 136, 0.8)' }, // Green hexagon
      { shape: 'plus', size: 0.7, color: '#ffaa00', glowColor: 'rgba(255, 170, 0, 0.8)' }, // Orange plus
      { shape: 'circle', size: 0.7, color: '#ff00ff', glowColor: 'rgba(255, 0, 255, 0.8)' }, // Magenta circle
      { shape: 'square', size: 0.7, color: '#00ffff', glowColor: 'rgba(0, 255, 255, 0.8)' }, // Aqua square
      { shape: 'diamond', size: 0.7, color: '#ffff00', glowColor: 'rgba(255, 255, 0, 0.8)' } // Yellow diamond
    ];
    
    function generateFood() {
      let newFood;
      do {
        newFood = {
          x: Math.floor(Math.random() * GRID_SIZE),
          y: Math.floor(Math.random() * GRID_SIZE),
          type: foodTypes[Math.floor(Math.random() * foodTypes.length)] // Random food type
        };
      } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
               food.some(f => f.x === newFood.x && f.y === newFood.y));
      return newFood;
    }
    
    // Add food items to the board (for autodrive mode)
    function addFood(count) {
      if (!gameRunning || gameOver) return;
      
      for (let i = 0; i < count; i++) {
        // Don't add food if we're at max score
        if (score >= 4000) break;
        const newFood = generateFood();
        food.push(newFood);
      }
      draw();
    }

    function updateScores() {
      // Update highscore first if current score is higher
      if (score > highscore) {
        highscore = score;
        try {
          localStorage.setItem('snakeHighscore', String(highscore));
        } catch (e) {}
      }
      
      // Then update the display with the current values
      if (scoreEl) scoreEl.textContent = score;
      if (highscoreEl) highscoreEl.textContent = highscore;
    }

    function draw() {
      // Clear canvas completely to remove any ghosting
      ctx.clearRect(0, 0, canvas.width / scale, canvas.height / scale);
      
      // Reset all shadow properties
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      
      // Draw background
      ctx.fillStyle = 'rgba(10, 10, 30, 0.3)';
      ctx.fillRect(0, 0, canvas.width / scale, canvas.height / scale);

      // Draw grid (subtle)
      ctx.strokeStyle = 'rgba(0, 245, 255, 0.1)';
      ctx.lineWidth = 0.5;
      for (let i = 0; i <= GRID_SIZE; i++) {
        const pos = i * cellSize;
        ctx.beginPath();
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, GRID_SIZE * cellSize);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, pos);
        ctx.lineTo(GRID_SIZE * cellSize, pos);
        ctx.stroke();
      }

      // Draw all food items with different shapes, sizes, and colors
      if (!Array.isArray(food)) {
        // Safety check: ensure food is an array
        food = [{ x: 4, y: 0, type: foodTypes[0] }];
      }
      for (const foodItem of food) {
        const foodX = foodItem.x * cellSize;
        const foodY = foodItem.y * cellSize;
        const centerX = foodX + cellSize / 2;
        const centerY = foodY + cellSize / 2;
        
        // Get food type (assign random type if not set, for backwards compatibility)
        let foodType = foodItem.type;
        if (!foodType) {
          foodType = foodTypes[Math.floor(Math.random() * foodTypes.length)];
          foodItem.type = foodType; // Cache it for next draw
        }
        const size = cellSize * foodType.size;
        const halfSize = size / 2;
        
        // Outer glow
        const foodGradient = ctx.createRadialGradient(
          centerX, centerY, 0,
          centerX, centerY, cellSize / 2
        );
        foodGradient.addColorStop(0, foodType.glowColor);
        foodGradient.addColorStop(0.5, foodType.glowColor.replace('0.8', '0.4'));
        foodGradient.addColorStop(1, foodType.glowColor.replace('0.8', '0'));
        ctx.fillStyle = foodGradient;
        ctx.fillRect(foodX, foodY, cellSize, cellSize);
        
        // Draw food shape
        ctx.fillStyle = foodType.color;
        ctx.shadowColor = foodType.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        
        switch (foodType.shape) {
          case 'circle':
            ctx.arc(centerX, centerY, halfSize, 0, Math.PI * 2);
            break;
          case 'square':
            ctx.fillRect(centerX - halfSize, centerY - halfSize, size, size);
            break;
          case 'diamond':
            ctx.moveTo(centerX, centerY - halfSize);
            ctx.lineTo(centerX + halfSize, centerY);
            ctx.lineTo(centerX, centerY + halfSize);
            ctx.lineTo(centerX - halfSize, centerY);
            ctx.closePath();
            break;
          case 'star':
            const starPoints = 5;
            const outerRadius = halfSize;
            const innerRadius = halfSize * 0.5;
            for (let i = 0; i < starPoints * 2; i++) {
              const angle = (Math.PI * i) / starPoints - Math.PI / 2;
              const radius = i % 2 === 0 ? outerRadius : innerRadius;
              const x = centerX + Math.cos(angle) * radius;
              const y = centerY + Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            break;
          case 'triangle':
            ctx.moveTo(centerX, centerY - halfSize);
            ctx.lineTo(centerX + halfSize, centerY + halfSize);
            ctx.lineTo(centerX - halfSize, centerY + halfSize);
            ctx.closePath();
            break;
          case 'hexagon':
            const hexPoints = 6;
            for (let i = 0; i < hexPoints; i++) {
              const angle = (Math.PI * 2 * i) / hexPoints - Math.PI / 2;
              const x = centerX + Math.cos(angle) * halfSize;
              const y = centerY + Math.sin(angle) * halfSize;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            break;
          case 'plus':
            const plusWidth = halfSize * 0.3;
            const plusLength = halfSize * 0.7;
            // Horizontal bar
            ctx.fillRect(centerX - plusLength, centerY - plusWidth, plusLength * 2, plusWidth * 2);
            // Vertical bar
            ctx.fillRect(centerX - plusWidth, centerY - plusLength, plusWidth * 2, plusLength * 2);
            break;
        }
        
        if (foodType.shape !== 'square' && foodType.shape !== 'plus') {
          ctx.fill();
        }
      }
      // Reset shadow after food
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;

      // Draw snake as a solid curved path
      const snakeLength = snake.length;
      if (snakeLength === 0) return;
      
      // Calculate center points for each segment
      const centers = snake.map(segment => ({
        x: segment.x * cellSize + cellSize / 2,
        y: segment.y * cellSize + cellSize / 2
      }));
      
      // Helper function to calculate distance between two points (handling wrap)
      function getDistance(p1, p2) {
        let dx = p2.x - p1.x;
        let dy = p2.y - p1.y;
        
        // Check for wrapping (if distance is more than half the canvas, it wrapped)
        const canvasSize = GRID_SIZE * cellSize;
        if (Math.abs(dx) > canvasSize / 2) {
          dx = dx > 0 ? dx - canvasSize : dx + canvasSize;
        }
        if (Math.abs(dy) > canvasSize / 2) {
          dy = dy > 0 ? dy - canvasSize : dy + canvasSize;
        }
        
        return Math.sqrt(dx * dx + dy * dy);
      }
      
      // Helper function to normalize wrapped positions
      function normalizePoint(p, prevP) {
        const canvasSize = GRID_SIZE * cellSize;
        let x = p.x;
        let y = p.y;
        
        if (prevP) {
          // Check if wrapped
          let dx = x - prevP.x;
          let dy = y - prevP.y;
          
          if (Math.abs(dx) > canvasSize / 2) {
            x = dx > 0 ? x - canvasSize : x + canvasSize;
          }
          if (Math.abs(dy) > canvasSize / 2) {
            y = dy > 0 ? y - canvasSize : y + canvasSize;
          }
        }
        
        return { x, y };
      }
      
      // Normalize all points to handle wrapping
      const normalizedCenters = [];
      for (let i = 0; i < centers.length; i++) {
        const prev = i > 0 ? normalizedCenters[i - 1] : null;
        normalizedCenters.push(normalizePoint(centers[i], prev));
      }
      
      // Draw the snake as a continuous path with curves
      const radius = cellSize * 0.4; // Snake body radius
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      // Build the path
      const snakePath = new Path2D();
      snakePath.moveTo(normalizedCenters[0].x, normalizedCenters[0].y);
      
      for (let i = 1; i < normalizedCenters.length; i++) {
        const prev = normalizedCenters[i - 1];
        const curr = normalizedCenters[i];
        const next = i < normalizedCenters.length - 1 ? normalizedCenters[i + 1] : null;
        
        if (next) {
          // Calculate direction vectors
          const dir1 = { x: curr.x - prev.x, y: curr.y - prev.y };
          const dir2 = { x: next.x - curr.x, y: next.y - curr.y };
          
          // Normalize direction vectors
          const len1 = Math.sqrt(dir1.x * dir1.x + dir1.y * dir1.y);
          const len2 = Math.sqrt(dir2.x * dir2.x + dir2.y * dir2.y);
          
          if (len1 > 0 && len2 > 0) {
            dir1.x /= len1;
            dir1.y /= len1;
            dir2.x /= len2;
            dir2.y /= len2;
            
            // Check if turning (not going straight)
            const dot = dir1.x * dir2.x + dir1.y * dir2.y;
            const isTurning = dot < 0.99; // Not perfectly aligned
            
            if (isTurning) {
              // Draw curve at corner
              const curveRadius = Math.min(radius * 0.6, cellSize * 0.3);
              const cornerX = curr.x - dir1.x * curveRadius;
              const cornerY = curr.y - dir1.y * curveRadius;
              const cornerX2 = curr.x + dir2.x * curveRadius;
              const cornerY2 = curr.y + dir2.y * curveRadius;
              
              snakePath.lineTo(cornerX, cornerY);
              snakePath.quadraticCurveTo(curr.x, curr.y, cornerX2, cornerY2);
            } else {
              // Straight line
              snakePath.lineTo(curr.x, curr.y);
            }
          } else {
            snakePath.lineTo(curr.x, curr.y);
          }
        } else {
          // Last segment - just line to tail
          snakePath.lineTo(curr.x, curr.y);
        }
      }
      
      // Create gradient for the snake
      const gradient = ctx.createLinearGradient(
        normalizedCenters[0].x, normalizedCenters[0].y,
        normalizedCenters[normalizedCenters.length - 1].x, normalizedCenters[normalizedCenters.length - 1].y
      );
      gradient.addColorStop(0, '#00f5ff'); // Head - cyan
      gradient.addColorStop(0.5, '#00aacc'); // Mid - darker cyan
      gradient.addColorStop(1, '#9664ff'); // Tail - purple
      
      // Create scale pattern overlay (cached for performance)
      if (!scalePattern) {
        const patternSize = Math.max(cellSize * 0.5, 16); // Larger pattern for less repetition
        const patternCanvas = document.createElement('canvas');
        patternCanvas.width = patternSize;
        patternCanvas.height = patternSize;
        const patternCtx = patternCanvas.getContext('2d');
        
        // Draw subtle snake scale pattern - diamond/hexagonal shapes
        patternCtx.fillStyle = 'rgba(0, 0, 0, 0.1)'; // Subtle dark overlay
        patternCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)'; // Subtle border
        patternCtx.lineWidth = 1;
        
        const scaleWidth = patternSize * 0.6;
        const scaleHeight = patternSize * 0.5;
        const rowOffset = scaleWidth * 0.5; // Stagger rows for snake skin effect
        
        // Draw scales in rows with offset (like real snake skin)
        for (let row = 0; row < 3; row++) {
          const y = row * scaleHeight * 0.7;
          const rowStartX = (row % 2 === 0) ? 0 : rowOffset; // Alternate row offset
          
          for (let col = 0; col < 3; col++) {
            const x = rowStartX + col * scaleWidth;
            
            // Draw diamond/hexagonal scale shape (more like snake scales)
            patternCtx.beginPath();
            const centerX = x + scaleWidth / 2;
            const centerY = y + scaleHeight / 2;
            
            // Create diamond shape with rounded corners
            const points = 4;
            for (let i = 0; i < points; i++) {
              const angle = (Math.PI * 2 * i) / points - Math.PI / 4; // Rotate 45 degrees
              const px = centerX + Math.cos(angle) * scaleWidth * 0.35;
              const py = centerY + Math.sin(angle) * scaleHeight * 0.35;
              
              if (i === 0) {
                patternCtx.moveTo(px, py);
              } else {
                patternCtx.lineTo(px, py);
              }
            }
            patternCtx.closePath();
            patternCtx.fill();
            patternCtx.stroke();
          }
        }
        
        scalePattern = ctx.createPattern(patternCanvas, 'repeat');
      }
      
      // Draw the snake body with gradient
      ctx.strokeStyle = gradient;
      ctx.lineWidth = radius * 2;
      ctx.shadowColor = 'rgba(0, 245, 255, 0.5)';
      ctx.shadowBlur = 8;
      ctx.stroke(snakePath);
      
      // Apply scale pattern overlay to snake body
      ctx.save();
      ctx.globalCompositeOperation = 'multiply'; // Blend with gradient
      ctx.strokeStyle = scalePattern;
      ctx.lineWidth = radius * 2;
      ctx.shadowBlur = 0; // No shadow on pattern overlay
      ctx.stroke(snakePath); // Reuse the same path
      ctx.restore();
      
      // Draw rounded tail cap to ensure it renders properly on mobile
      // This ensures the tail has a proper rounded end even on devices where lineCap might not render correctly
      if (normalizedCenters.length > 1) {
        const tailX = normalizedCenters[normalizedCenters.length - 1].x;
        const tailY = normalizedCenters[normalizedCenters.length - 1].y;
        const prevTail = normalizedCenters[normalizedCenters.length - 2];
        
        // Calculate tail direction for proper positioning
        const dirX = tailX - prevTail.x;
        const dirY = tailY - prevTail.y;
        const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
        
        if (dirLen > 0) {
          const tailDir = { x: dirX / dirLen, y: dirY / dirLen };
          
          // Position tail cap slightly back along the path to overlap with the stroke
          // This makes it blend seamlessly instead of looking disconnected
          const overlap = radius * 0.3; // Overlap with the path
          const tailCapX = tailX - (tailDir.x * overlap);
          const tailCapY = tailY - (tailDir.y * overlap);
          
          // Create radial gradient for seamless blending
          const tailGradient = ctx.createRadialGradient(
            tailCapX, tailCapY, 0,
            tailCapX, tailCapY, radius
          );
          tailGradient.addColorStop(0, '#9664ff'); // Center - tail purple
          tailGradient.addColorStop(0.7, '#9664ff'); // Most of the circle
          tailGradient.addColorStop(1, '#9664ff'); // Edge matches path color
          
          // Draw tail cap with gradient
          ctx.save();
          ctx.fillStyle = tailGradient;
          ctx.shadowColor = 'rgba(150, 100, 255, 0.3)';
          ctx.shadowBlur = 4;
          ctx.beginPath();
          ctx.arc(tailCapX, tailCapY, radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Apply scale pattern overlay to tail cap for consistency
          ctx.globalCompositeOperation = 'multiply';
          ctx.fillStyle = scalePattern;
          ctx.fill();
          ctx.restore();
        }
      } else if (normalizedCenters.length === 1) {
        // Single segment - just draw a circle at the tail
        const tailX = normalizedCenters[0].x;
        const tailY = normalizedCenters[0].y;
        ctx.save();
        ctx.fillStyle = '#9664ff';
        ctx.shadowColor = 'rgba(150, 100, 255, 0.3)';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(tailX, tailY, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = scalePattern;
        ctx.fill();
        ctx.restore();
      }
      
      // Draw head with top-down view
      const headX = normalizedCenters[0].x;
      const headY = normalizedCenters[0].y;
      const headRadius = radius;
      
      // Calculate head direction for tongue
      let headDir = { x: 1, y: 0 };
      if (normalizedCenters.length > 1) {
        const dirX = normalizedCenters[0].x - normalizedCenters[1].x;
        const dirY = normalizedCenters[0].y - normalizedCenters[1].y;
        const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
        if (dirLen > 0) {
          headDir = { x: dirX / dirLen, y: dirY / dirLen };
        }
      }
      
      // Draw head body (circular, top-down view)
      ctx.fillStyle = '#00f5ff';
      ctx.shadowColor = '#00f5ff';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw eyes (top-down view - snake eyes, elliptical/oval, vertical)
      ctx.fillStyle = '#ffffff'; // Yellow eyes
      ctx.shadowBlur = 0;
      const eyeWidth = headRadius * 0.25; // Horizontal radius (narrower)
      const eyeHeight = headRadius * 0.4; // Vertical radius (taller, vertical snake eyes)
      const eyeOffsetX = headRadius * 0.35;
      const eyeOffsetY = -headRadius * 0.2;
      
      // Left eye (elliptical, vertical)
      ctx.beginPath();
      ctx.ellipse(headX - eyeOffsetX, headY + eyeOffsetY, eyeWidth, eyeHeight, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Right eye (elliptical, vertical)
      ctx.beginPath();
      ctx.ellipse(headX + eyeOffsetX, headY + eyeOffsetY, eyeWidth, eyeHeight, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw pupils (black, vertical slit-like)
      ctx.fillStyle = '#000000';
      const pupilWidth = eyeWidth * 0.5;
      const pupilHeight = eyeHeight * 0.6;
      ctx.beginPath();
      ctx.ellipse(headX - eyeOffsetX, headY + eyeOffsetY, pupilWidth, pupilHeight, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(headX + eyeOffsetX, headY + eyeOffsetY, pupilWidth, pupilHeight, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Animate tongue (appears and disappears completely)
      tongueAnimation += 0.02; // Slower animation
      if (tongueAnimation > Math.PI * 2) {
        tongueAnimation = 0;
      }
      
      // Tongue only shows when sin is positive (about half the time)
      const tongueVisible = Math.sin(tongueAnimation) > 0;
      
      if (tongueVisible) {
        // Draw simple line tongue in direction of movement
        const tongueLength = headRadius * 0.8;
        const tongueBaseX = headX + headDir.x * headRadius * 0.8;
        const tongueBaseY = headY + headDir.y * headRadius * 0.8;
        const tongueTipX = tongueBaseX + headDir.x * tongueLength;
        const tongueTipY = tongueBaseY + headDir.y * tongueLength;
        
        // Create gradient from head color (cyan) to red
        const tongueGradient = ctx.createLinearGradient(
          tongueBaseX, tongueBaseY,
          tongueTipX, tongueTipY
        );
        tongueGradient.addColorStop(0, '#00f5ff'); // Cyan at base (blends with head)
        tongueGradient.addColorStop(0.3, '#ff6b9d'); // Pink transition
        tongueGradient.addColorStop(1, '#ff0040'); // Red at tip
        
        ctx.strokeStyle = tongueGradient;
        ctx.lineWidth = headRadius * 0.1;
        ctx.lineCap = 'round';
        
        // Simple line tongue
        ctx.beginPath();
        ctx.moveTo(tongueBaseX, tongueBaseY);
        ctx.lineTo(tongueTipX, tongueTipY);
        ctx.stroke();
      }
      
      // Tail is now part of the continuous path, no need for separate circle
      
      // Reset shadow properties
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
    }

    function moveSnake() {
      if (!gameRunning || gameOver || gamePaused) return;

      // Process direction queue - but prioritize immediate responsiveness
      // Since nextDirection is updated immediately in changeDirection, we only process
      // the queue if it contains directions that haven't been applied yet
      // This ensures direction changes apply on the very next move, even when eating food
      if (directionQueue.length > 0) {
        // Check if the first queued direction matches current nextDirection
        // If it does, it was already applied, so just remove it
        const firstQueued = directionQueue[0];
        if (firstQueued.x === nextDirection.x && firstQueued.y === nextDirection.y) {
          directionQueue.shift();
        } else {
          // If different, apply the queued direction (for rapid key presses)
          nextDirection = directionQueue.shift();
        }
      }
      
      // Update direction from nextDirection
      direction = { ...nextDirection };

      // Calculate new head position
      const head = { ...snake[0] };
      head.x += direction.x;
      head.y += direction.y;

      // Wrap around walls
      if (head.x < 0) {
        head.x = GRID_SIZE - 1;
      } else if (head.x >= GRID_SIZE) {
        head.x = 0;
      }
      if (head.y < 0) {
        head.y = GRID_SIZE - 1;
      } else if (head.y >= GRID_SIZE) {
        head.y = 0;
      }

      // Check self collision
      if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        endGame();
        return;
      }

      snake.unshift(head);

      // Check food collision with all food items
      let ateFood = false;
      for (let i = food.length - 1; i >= 0; i--) {
        if (head.x === food[i].x && head.y === food[i].y) {
          // Remove this food item
          food.splice(i, 1);
          score += 10;
          updateScores();
          SoundManager.playEat();
          ateFood = true;
          
          // Check for victory (max score: 4000 = 400 cells * 10 points)
          if (score >= 4000) {
            victory();
            return;
          }
          
          // Generate new food if array is empty (but only if not at max score)
          if (food.length === 0 && score < 4000) {
            food.push(generateFood());
          }
          break;
        }
      }
      
      if (!ateFood) {
        snake.pop();
      }

      // Don't draw here - let the render loop handle it
    }

    // Smooth game loop using requestAnimationFrame
    function animationLoop(timestamp) {
      // Always render for smooth animations (even when paused or game over)
      if (gameRunning || gameOver) {
        draw();
      }

      // Update game logic based on speed (only when running and not paused)
      if (gameRunning && !gameOver && !gamePaused) {
        if (lastMoveTime === 0) {
          lastMoveTime = timestamp;
        }
        
        // Apply autodrive speed multiplier
        const effectiveSpeed = autodriveActive ? currentSpeed / autodriveSpeed : currentSpeed;
        
        const elapsed = timestamp - lastMoveTime;
        if (elapsed >= effectiveSpeed) {
          // Autodrive AI: calculate direction before moving
          if (autodriveActive) {
            const aiDirection = findPathToFood();
            if (aiDirection) {
              // Check if direction is actually changing
              const checkDir = directionQueue.length > 0 
                ? directionQueue[directionQueue.length - 1] 
                : nextDirection;
              const isDirectionChanging = aiDirection.x !== checkDir.x || aiDirection.y !== checkDir.y;
              
              // Clear queue and set AI direction
              directionQueue = [];
              nextDirection = aiDirection;
              
              // Play sound when direction changes
              if (isDirectionChanging) {
                SoundManager.playDirectionChange();
              }
            }
          }
          
          moveSnake();
          lastMoveTime = timestamp;
        }
      }

      // Continue the loop only if game is running or just ended
      if (gameRunning || gameOver) {
        animationFrameId = requestAnimationFrame(animationLoop);
      } else {
        animationFrameId = null;
      }
    }

    function startGame() {
      if (gameRunning) return;
      
      snake = [{ x: 0, y: 0 }]; // Start at top left
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      directionQueue = []; // Clear direction queue on restart
      // Don't regenerate food here - it should already be set at initialization
      // Food will only be regenerated when the snake eats it
      score = 10; // Snake starts with 1 segment = 10 points
      gameOver = false;
      gamePaused = false;
      gameRunning = true;
      currentSpeed = INITIAL_SPEED;
      lastMoveTime = 0;
      autodriveActive = false; // Reset autodrive on new game
      
      // Reset musical sequence for a fresh start
      SoundManager.resetSequence();
      
      updateScores();
      hideGameOver();
      hideStartButton();
      updatePauseButton();
      if (autodriveBtn) autodriveBtn.classList.remove('active');
      if (autodrivePanel) autodrivePanel.classList.remove('show');
      draw();
      
      // Stop any existing loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Start smooth animation loop
      animationFrameId = requestAnimationFrame(animationLoop);
    }

    function togglePause() {
      if (!gameRunning || gameOver) return;
      
      gamePaused = !gamePaused;
      updatePauseButton();
      
      if (gamePaused) {
        SoundManager.playGlitch();
        // Keep rendering even when paused for smooth UI
      } else {
        lastMoveTime = performance.now();
      }
    }

    function updatePauseButton() {
      const pauseBtn = document.getElementById('pauseBtnTop');
      if (pauseBtn) {
        const icon = pauseBtn.querySelector('.material-icons');
        if (icon) {
          if (gamePaused) {
            icon.textContent = 'play_arrow';
            pauseBtn.title = 'Resume';
          } else {
            icon.textContent = 'pause';
            pauseBtn.title = 'Pause';
          }
        }
      }
    }

    function endGame() {
      if (!gameRunning) return;
      
      gameRunning = false;
      gameOver = true;
      
      // Stop animation loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Final render
      draw();
      
      // Ensure final score is saved to highscore
      updateScores();
      
      SoundManager.playGameOver();
      showGameOver();
      // Show start button after game over
      showStartButton();
    }
    
    function victory() {
      if (!gameRunning) return;
      
      gameRunning = false;
      gameOver = true;
      
      // Stop animation loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      if (hyperSpeedLoopId) {
        clearTimeout(hyperSpeedLoopId);
        hyperSpeedLoopId = null;
      }
      
      // Ensure score is exactly 4000
      score = 4000;
      updateScores();
      
      // Final render
      draw();
      
      // Play celebration sound
      SoundManager.playVictory();
      
      // Show victory message
      showVictory();
      // Show start button after victory
      showStartButton();
    }

    function showGameOver() {
      finalScoreEl.textContent = score;
      // Reset to normal game over message
      const flatlinedText = gameOverEl.querySelector('.flatlined-text');
      const subtitle = gameOverEl.querySelector('.game-over-subtitle');
      if (flatlinedText) {
        flatlinedText.textContent = 'FLATLINED';
        flatlinedText.classList.remove('perfect-score');
      }
      if (subtitle) {
        subtitle.textContent = 'SYSTEM FAILURE DETECTED';
        subtitle.classList.remove('perfect-score');
      }
      gameOverEl.classList.add('show');
    }
    
    function showVictory() {
      finalScoreEl.textContent = score;
      // Change to victory message
      const flatlinedText = gameOverEl.querySelector('.flatlined-text');
      const subtitle = gameOverEl.querySelector('.game-over-subtitle');
      if (flatlinedText) {
        flatlinedText.textContent = 'PERFECT SCORE';
        flatlinedText.classList.add('perfect-score');
      }
      if (subtitle) {
        subtitle.textContent = 'MAX SCORE OF 4000 ACHIEVED';
        subtitle.classList.add('perfect-score');
      }
      gameOverEl.classList.add('show');
    }

    function hideGameOver() {
      gameOverEl.classList.remove('show');
    }

    function showStartButton() {
      if (startGameBtn) {
        startGameBtn.classList.add('show');
      }
    }

    function hideStartButton() {
      if (startGameBtn) {
        startGameBtn.classList.remove('show');
      }
    }

    // Pre-computed Hamiltonian path that visits every cell exactly once
    // Pattern matches spreadsheet: Row 1 A→T, Row 2 T→B, Row 3 B→T, etc., then up column A
    let hamiltonianPath = null;
    
    function generateHamiltonianPath() {
      const path = [];
      
      // Row 1 (y=0): A1 to T1 (x=0 to x=GRID_SIZE-1, going right)
      // This ends at (GRID_SIZE-1, 0) = T1
      for (let x = 0; x < GRID_SIZE; x++) {
        path.push({ x, y: 0 });
      }
      
      // Rows 2 to GRID_SIZE (y=1 to y=GRID_SIZE-1): Zigzag pattern
      // Row 2 (y=1, even 1-indexed): T2 to B2 (x=GRID_SIZE-1 to x=1, going left)
      // Row 3 (y=2, odd 1-indexed): B3 to T3 (x=1 to x=GRID_SIZE-1, going right)
      // Row 4 (y=3, even 1-indexed): T4 to B4 (x=GRID_SIZE-1 to x=1, going left)
      // etc.
      for (let y = 1; y < GRID_SIZE; y++) {
        if (y % 2 === 1) {
          // Even row (1-indexed, y=1,3,5...): go left from T to B
          // Start at T (x=GRID_SIZE-1) - this is adjacent to where we ended in previous row
          for (let x = GRID_SIZE - 1; x >= 1; x--) {
            path.push({ x, y });
          }
          // Ends at B (x=1, y)
        } else {
          // Odd row (1-indexed, y=2,4,6...): go right from B to T
          // Start at B (x=1) - this is adjacent to where we ended in previous row
          for (let x = 1; x < GRID_SIZE; x++) {
            path.push({ x, y });
          }
          // Ends at T (x=GRID_SIZE-1, y)
        }
      }
      
      // After processing all rows, we end at either:
      // - (1, GRID_SIZE-1) if last row was even (1-indexed) - which means y=GRID_SIZE-1 is odd
      // - (GRID_SIZE-1, GRID_SIZE-1) if last row was odd (1-indexed) - which means y=GRID_SIZE-1 is even
      // Check: GRID_SIZE-1 = 19, which is odd, so last row (y=19) is even (1-indexed)
      // So we end at (1, GRID_SIZE-1) = B20
      
      // Go to A20 (x=0, y=GRID_SIZE-1) - this is adjacent to B20
      path.push({ x: 0, y: GRID_SIZE - 1 });
      
      // Go up column A from A20 to A2 (skip A1 since it's already visited)
      // This goes from (0, GRID_SIZE-1) to (0, 1)
      for (let y = GRID_SIZE - 2; y >= 1; y--) {
        path.push({ x: 0, y });
      }
      
      // Verify path is continuous and visits all cells
      const visited = new Set();
      for (let i = 0; i < path.length; i++) {
        const cell = path[i];
        const key = `${cell.x},${cell.y}`;
        if (visited.has(key)) {
          console.error('Duplicate cell in path:', cell, 'at index', i);
        }
        visited.add(key);
        
        // Check continuity (except for last cell)
        if (i < path.length - 1) {
          const next = path[i + 1];
          const dx = Math.abs(cell.x - next.x);
          const dy = Math.abs(cell.y - next.y);
          if (dx + dy !== 1) {
            console.error('Path not continuous at index', i, cell, '->', next);
          }
        }
      }
      
      if (visited.size !== GRID_SIZE * GRID_SIZE) {
        console.warn('Path incomplete:', visited.size, 'expected', GRID_SIZE * GRID_SIZE);
      }
      if (path.length !== GRID_SIZE * GRID_SIZE) {
        console.warn('Path length mismatch:', path.length, 'expected', GRID_SIZE * GRID_SIZE);
      }
      
      return path;
    }
    
    // Get the index of a cell in the Hamiltonian path
    function getPathIndex(x, y) {
      if (!hamiltonianPath) {
        hamiltonianPath = generateHamiltonianPath();
      }
      for (let i = 0; i < hamiltonianPath.length; i++) {
        if (hamiltonianPath[i].x === x && hamiltonianPath[i].y === y) {
          return i;
        }
      }
      return -1;
    }
    
    // Get the next cell in the path from current position
    function getNextInPath(x, y) {
      if (!hamiltonianPath) {
        hamiltonianPath = generateHamiltonianPath();
      }
      const currentIndex = getPathIndex(x, y);
      if (currentIndex === -1 || currentIndex >= hamiltonianPath.length - 1) {
        return null; // At end of path
      }
      return hamiltonianPath[currentIndex + 1];
    }
    
    // AI Pathfinding for Autodrive - Simple Hamiltonian path following
    // Just follows the predefined path, no additional logic needed
    function findPathToFood() {
      const head = snake[0];
      
      // Create a set of snake body positions (excluding tail which will move)
      const snakeBody = new Set();
      for (let i = 0; i < snake.length - 1; i++) {
        snakeBody.add(`${snake[i].x},${snake[i].y}`);
      }
      
      // Get the next cell in the predefined path
      const nextCell = getNextInPath(head.x, head.y);
      
      if (!nextCell) {
        // At the end of the path - game should be complete
        // Fallback: continue in current direction
        const currentDir = snake.length > 1 
          ? { x: snake[0].x - snake[1].x, y: snake[0].y - snake[1].y }
          : { x: 1, y: 0 };
        return currentDir;
      }
      
      // Calculate direction to the next cell
      const dirX = nextCell.x - head.x;
      const dirY = nextCell.y - head.y;
      
      // Verify this is an adjacent cell (distance = 1)
      if (Math.abs(dirX) + Math.abs(dirY) !== 1) {
        console.error('Next cell in path is not adjacent!', head, nextCell);
        const currentDir = snake.length > 1 
          ? { x: snake[0].x - snake[1].x, y: snake[0].y - snake[1].y }
          : { x: 1, y: 0 };
        return currentDir;
      }
      
      // Normalize direction
      const normalizedX = dirX !== 0 ? (dirX > 0 ? 1 : -1) : 0;
      const normalizedY = dirY !== 0 ? (dirY > 0 ? 1 : -1) : 0;
      
      // Check if this move is safe (won't hit body, excluding tail)
      const key = `${nextCell.x},${nextCell.y}`;
      if (!snakeBody.has(key) && nextCell.x >= 0 && nextCell.x < GRID_SIZE && 
          nextCell.y >= 0 && nextCell.y < GRID_SIZE) {
        return { x: normalizedX, y: normalizedY };
      }
      
      // If blocked, something is wrong - but this shouldn't happen with proper path
      console.warn('Next cell in path is blocked:', nextCell);
      
      // Fallback: try current direction
      const currentDir = snake.length > 1 
        ? { x: snake[0].x - snake[1].x, y: snake[0].y - snake[1].y }
        : { x: 1, y: 0 };
      const newX = head.x + currentDir.x;
      const newY = head.y + currentDir.y;
      if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && 
          !snakeBody.has(`${newX},${newY}`)) {
        return currentDir;
      }
      
      return { x: 1, y: 0 }; // Last resort
    }
    
    // BFS to find shortest path between two points
    function bfsPath(start, target, obstacles) {
      const queue = [{ x: start.x, y: start.y, path: [] }];
      const visited = new Set();
      visited.add(`${start.x},${start.y}`);
      
      const directions = [
        { x: 0, y: -1 }, // up
        { x: 1, y: 0 },  // right
        { x: 0, y: 1 },  // down
        { x: -1, y: 0 }  // left
      ];
      
      while (queue.length > 0) {
        const current = queue.shift();
        
        if (current.x === target.x && current.y === target.y) {
          return current.path;
        }
        
        for (const dir of directions) {
          let newX = (current.x + dir.x + GRID_SIZE) % GRID_SIZE;
          let newY = (current.y + dir.y + GRID_SIZE) % GRID_SIZE;
          
          const key = `${newX},${newY}`;
          
          if (!visited.has(key) && !obstacles.has(key)) {
            visited.add(key);
            queue.push({
              x: newX,
              y: newY,
              path: [...current.path, dir]
            });
          }
        }
      }
      
      return null; // No path found
    }
    
    // Find the safest move that maximizes future options
    function findSafeMove(head, snakeBody, target) {
      const directions = [
        { x: 0, y: -1 }, // up
        { x: 1, y: 0 },  // right
        { x: 0, y: 1 },  // down
        { x: -1, y: 0 }  // left
      ];
      
      // Score each possible move
      const moves = [];
      
      for (const dir of directions) {
        let newX = (head.x + dir.x + GRID_SIZE) % GRID_SIZE;
        let newY = (head.y + dir.y + GRID_SIZE) % GRID_SIZE;
        
        const key = `${newX},${newY}`;
        
        // Skip if would hit body
        if (snakeBody.has(key)) {
          continue;
        }
        
        // Calculate score for this move
        let score = 0;
        
        // Check if this move is safe (can reach tail after moving)
        const newSnakeBody = new Set(snakeBody);
        newSnakeBody.delete(`${snake[snake.length - 1].x},${snake[snake.length - 1].y}`); // Remove tail
        newSnakeBody.add(key); // Add new head position
        
        const tail = snake[snake.length - 1];
        const pathToTail = bfsPath({ x: newX, y: newY }, tail, newSnakeBody);
        
        if (pathToTail && pathToTail.length > 0) {
          score += 1000; // Safe move - can reach tail
        } else {
          // Unsafe move, but might be necessary
          score -= 500;
        }
        
        // Prefer moves that get closer to food (with wrapping)
        const dx = Math.min(Math.abs(newX - target.x), GRID_SIZE - Math.abs(newX - target.x));
        const dy = Math.min(Math.abs(newY - target.y), GRID_SIZE - Math.abs(newY - target.y));
        const wrappedDistToFood = dx + dy;
        score += (GRID_SIZE * 2 - wrappedDistToFood) * 10;
        
        // Count how many free spaces are reachable from this position
        const reachable = countReachableSpaces({ x: newX, y: newY }, newSnakeBody);
        score += reachable;
        
        moves.push({ dir, score, newX, newY });
      }
      
      // Sort by score (highest first)
      moves.sort((a, b) => b.score - a.score);
      
      // Return best move, or current direction if no safe moves
      if (moves.length > 0 && moves[0].score > -500) {
        return moves[0].dir;
      }
      
      // Last resort: try to continue in current direction if safe
      const currentDir = direction;
      let newX = (head.x + currentDir.x + GRID_SIZE) % GRID_SIZE;
      let newY = (head.y + currentDir.y + GRID_SIZE) % GRID_SIZE;
      const key = `${newX},${newY}`;
      if (!snakeBody.has(key)) {
        return currentDir;
      }
      
      // Any move is better than crashing
      return moves.length > 0 ? moves[0].dir : currentDir;
    }
    
    // Count how many spaces are reachable from a position (flood fill)
    function countReachableSpaces(start, obstacles) {
      const queue = [start];
      const visited = new Set();
      visited.add(`${start.x},${start.y}`);
      
      const directions = [
        { x: 0, y: -1 }, // up
        { x: 1, y: 0 },  // right
        { x: 0, y: 1 },  // down
        { x: -1, y: 0 }  // left
      ];
      
      let count = 0;
      
      while (queue.length > 0) {
        const current = queue.shift();
        count++;
        
        for (const dir of directions) {
          let newX = (current.x + dir.x + GRID_SIZE) % GRID_SIZE;
          let newY = (current.y + dir.y + GRID_SIZE) % GRID_SIZE;
          
          const key = `${newX},${newY}`;
          
          if (!visited.has(key) && !obstacles.has(key)) {
            visited.add(key);
            queue.push({ x: newX, y: newY });
          }
        }
      }
      
      return count;
    }

    function changeDirection(newDir) {
      // Don't auto-start on direction change - user must press start button
      if (!gameRunning || gameOver || gamePaused) {
        SoundManager.playInvalidMove();
        return;
      }
      
      // Don't allow manual direction changes when autodrive is active
      if (autodriveActive) {
        SoundManager.playInvalidMove();
        return;
      }
      
      // Determine what direction to check against
      // Use the actual current direction (where snake is moving now)
      const currentDir = direction;
      
      // Prevent reversing into itself (backwards)
      if (newDir.x === -currentDir.x && newDir.y === -currentDir.y) {
        SoundManager.playInvalidMove();
        return;
      }
      
      // Prevent moving in the same direction (snake can't move into itself)
      if (newDir.x === currentDir.x && newDir.y === currentDir.y) {
        SoundManager.playInvalidMove();
        return;
      }
      
      // Determine what direction to check against for queue
      // Use the last queued direction if queue exists, otherwise use nextDirection
      const checkDir = directionQueue.length > 0 
        ? directionQueue[directionQueue.length - 1] 
        : nextDirection;
      
      // Check if direction is actually changing (not the same as queued)
      const isDirectionChanging = newDir.x !== checkDir.x || newDir.y !== checkDir.y;
      
      // Add to queue to capture rapid key presses
      // Remove any duplicate of this direction from queue first
      directionQueue = directionQueue.filter(
        dir => !(dir.x === newDir.x && dir.y === newDir.y)
      );
      directionQueue.push(newDir);
      
      // Always update nextDirection to the most recent direction for immediate responsiveness
      // This ensures direction changes apply on the next move, even when eating food
      nextDirection = newDir;
      
      // Play super short cyber beep when direction actually changes
      if (isDirectionChanging) {
        SoundManager.playDirectionChange();
      }
      
      // Limit queue size to prevent memory issues (keep last 3 directions)
      if (directionQueue.length > 3) {
        directionQueue.shift();
      }
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (SoundManager.audioContext && !SoundManager.hasUserInteracted) {
        SoundManager.hasUserInteracted = true;
        SoundManager.ensureResumed();
      }
      
      switch (e.key) {
        case 'ArrowUp':
          e.preventDefault();
          changeDirection({ x: 0, y: -1 });
          break;
        case 'ArrowDown':
          e.preventDefault();
          changeDirection({ x: 0, y: 1 });
          break;
        case 'ArrowLeft':
          e.preventDefault();
          changeDirection({ x: -1, y: 0 });
          break;
        case 'ArrowRight':
          e.preventDefault();
          changeDirection({ x: 1, y: 0 });
          break;
        case ' ':
          e.preventDefault();
          // If game over screen is showing, restart the game
          if (gameOverEl && gameOverEl.classList.contains('show')) {
            // Play glitch sound like reboot button
            SoundManager.playGlitch();
            
            // Add glitching animation to canvas
            canvas.classList.add('glitching');
            setTimeout(() => {
              canvas.classList.remove('glitching');
            }, 500);
            
            // Stop any existing loops first
            if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
              animationFrameId = null;
            }
            if (gameLoop) {
              clearInterval(gameLoop);
              gameLoop = null;
            }
            
            // Reset all game state before restarting
            gameRunning = false;
            gameOver = false;
            gamePaused = false;
            score = 10; // Snake starts with 1 segment = 10 points
            snake = [{ x: 0, y: 0 }]; // Start at top left
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            directionQueue = [];
            currentSpeed = INITIAL_SPEED;
            lastMoveTime = 0;
            
            // Set initial food position (cell 4, top row) for immediate catch
            food = [{ x: 4, y: 0, type: null }];
            
            // Hide game over screen and show start button (don't auto-start)
            hideGameOver();
            updateScores();
            showStartButton();
            draw();
          } else if (gameRunning && !gameOver) {
            togglePause();
          } else if (!gameRunning && !gameOver) {
            // Start the game if not running and not on game over screen
            startGame();
          }
          break;
      }
    });

    // Touch/Swipe controls
    let touchStartX = null;
    let touchStartY = null;
    const minSwipeDistance = 30;

    function isInteractiveElement(target) {
      return target.tagName === 'BUTTON' || 
             target.closest('button') !== null ||
             target.closest('#gameOver') !== null ||
             target.closest('#helpModal') !== null ||
             target.closest('.menu-dropdown') !== null ||
             target.closest('.direction-controls') !== null;
    }

    document.addEventListener('touchstart', (e) => {
      if (SoundManager.audioContext && !SoundManager.hasUserInteracted) {
        SoundManager.hasUserInteracted = true;
        SoundManager.ensureResumed();
      }
      
      if (isInteractiveElement(e.target)) return;
      // Don't auto-start on touch - user must press start button
      if (!gameRunning || gameOver || gamePaused) return;
      
      e.preventDefault();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      if (isInteractiveElement(e.target)) return;
      if (touchStartX === null || touchStartY === null) return;
      
      e.preventDefault();
      const touch = e.changedTouches[0];
      const deltaX = touch.clientX - touchStartX;
      const deltaY = touch.clientY - touchStartY;
      const absDeltaX = Math.abs(deltaX);
      const absDeltaY = Math.abs(deltaY);
      
      if (absDeltaX > minSwipeDistance || absDeltaY > minSwipeDistance) {
        if (absDeltaX > absDeltaY) {
          if (deltaX > 0) {
            changeDirection({ x: 1, y: 0 });
          } else {
            changeDirection({ x: -1, y: 0 });
          }
        } else {
          if (deltaY > 0) {
            changeDirection({ x: 0, y: 1 });
          } else {
            changeDirection({ x: 0, y: -1 });
          }
        }
      }
      
      touchStartX = null;
      touchStartY = null;
    }, { passive: false });

    // Control mode state (absolute, relative, or split)
    let controlMode = localStorage.getItem('controlMode') || 'none'; // 'none', 'absolute', 'relative', or 'split'
    
    // Function to calculate relative turn direction
    function getRelativeDirection(turn) {
      // turn: 'left' or 'right'
      // Get current direction - use directionQueue if available, otherwise nextDirection, otherwise direction
      let currentDir;
      if (directionQueue.length > 0) {
        currentDir = directionQueue[directionQueue.length - 1];
      } else if (nextDirection.x !== 0 || nextDirection.y !== 0) {
        currentDir = nextDirection;
      } else {
        currentDir = direction;
      }
      
      // If snake has multiple segments, we can also check the actual movement direction
      if (snake.length > 1) {
        const head = snake[0];
        const neck = snake[1];
        const actualDir = { x: head.x - neck.x, y: head.y - neck.y };
        // Normalize in case of wrapping
        if (actualDir.x !== 0 || actualDir.y !== 0) {
          currentDir = {
            x: actualDir.x > 0 ? 1 : (actualDir.x < 0 ? -1 : 0),
            y: actualDir.y > 0 ? 1 : (actualDir.y < 0 ? -1 : 0)
          };
        }
      }
      
      // Calculate relative turn
      // Current direction vectors:
      // Up: {x: 0, y: -1}
      // Right: {x: 1, y: 0}
      // Down: {x: 0, y: 1}
      // Left: {x: -1, y: 0}
      
      if (turn === 'left') {
        // Turn left: rotate 90 degrees counter-clockwise
        // Up -> Left, Left -> Down, Down -> Right, Right -> Up
        return { x: currentDir.y, y: -currentDir.x };
      } else if (turn === 'right') {
        // Turn right: rotate 90 degrees clockwise
        // Up -> Right, Right -> Down, Down -> Left, Left -> Up
        return { x: -currentDir.y, y: currentDir.x };
      }
      return currentDir;
    }
    
    // Function to position split controls below the game board
    function positionSplitControlsOnSides() {
      const splitControlLeft = document.getElementById('splitControlLeft');
      const splitControlRight = document.getElementById('splitControlRight');
      const leftPos = localStorage.getItem('splitControlLeftPosition');
      const rightPos = localStorage.getItem('splitControlRightPosition');
      
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
          const containerRect = gameContainer.getBoundingClientRect();
          const controlHeight = 105; // Height of 2 buttons stacked (50px + 5px gap + 50px)
          const controlWidth = 105; // Width of 2 columns (50px + 5px gap + 50px)
          const padding = 20; // Padding from edges
          const spacingBelow = 25; // Space below the game container
          const gapBetweenControls = 150; // Space between left and right controls
          
          // Position below the game container
          const bottomY = containerRect.bottom + spacingBelow;
          
          // Calculate center position for both controls
          const centerX = containerRect.left + (containerRect.width / 2);
          
          // Position left control if not already saved
          if (!leftPos && splitControlLeft) {
            // Position on left side of center with gap
            splitControlLeft.style.left = (centerX - controlWidth - gapBetweenControls / 2) + 'px';
            splitControlLeft.style.top = bottomY + 'px';
            splitControlLeft.style.transform = 'none';
            splitControlLeft.style.bottom = 'auto';
            splitControlLeft.style.right = 'auto';
          }
          
          // Position right control if not already saved
          if (!rightPos && splitControlRight) {
            // Position on right side of center with gap
            splitControlRight.style.left = (centerX + gapBetweenControls / 2) + 'px';
            splitControlRight.style.top = bottomY + 'px';
            splitControlRight.style.transform = 'none';
            splitControlRight.style.bottom = 'auto';
            splitControlRight.style.right = 'auto';
          }
      } else {
        // Fallback if game container not found
        if (!leftPos && splitControlLeft) {
          splitControlLeft.style.left = '20px';
          splitControlLeft.style.bottom = '20px';
          splitControlLeft.style.top = 'auto';
          splitControlLeft.style.transform = 'none';
          splitControlLeft.style.right = 'auto';
        }
        if (!rightPos && splitControlRight) {
          splitControlRight.style.right = '20px';
          splitControlRight.style.bottom = '20px';
          splitControlRight.style.top = 'auto';
          splitControlRight.style.transform = 'none';
          splitControlRight.style.left = 'auto';
        }
      }
    }
    
    // Function to position relative controls at bottom of game area
    function positionRelativeControlsAtBottom() {
      const relativeTurnLeft = document.getElementById('relativeTurnLeft');
      const relativeTurnRight = document.getElementById('relativeTurnRight');
      const leftPos = localStorage.getItem('relativeTurnLeftPosition');
      const rightPos = localStorage.getItem('relativeTurnRightPosition');
      
      // Only position if not already saved
      if (!leftPos || !rightPos) {
        // Calculate position below game area (not inside it)
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
          const containerRect = gameContainer.getBoundingClientRect();
          const controlHeight = 60; // Height of the control button
          const controlWidth = 60; // Width of the control button
          const padding = 20; // Padding from edges
          const spacingBelow = 25; // Space below the game container
          
          // Position below the game container
          const bottomY = containerRect.bottom + spacingBelow;
          
          if (!leftPos && relativeTurnLeft) {
            // Position at bottom-left, below game area
            relativeTurnLeft.style.left = (containerRect.left + padding) + 'px';
            relativeTurnLeft.style.top = bottomY + 'px';
            relativeTurnLeft.style.transform = 'none';
            relativeTurnLeft.style.bottom = 'auto';
            relativeTurnLeft.style.right = 'auto';
          }
          
          if (!rightPos && relativeTurnRight) {
            // Position at bottom-right, below game area
            relativeTurnRight.style.left = (containerRect.right - controlWidth - padding) + 'px';
            relativeTurnRight.style.top = bottomY + 'px';
            relativeTurnRight.style.transform = 'none';
            relativeTurnRight.style.bottom = 'auto';
            relativeTurnRight.style.right = 'auto';
          }
        } else {
          // Fallback if game container not found
          if (!leftPos && relativeTurnLeft) {
            relativeTurnLeft.style.left = '20px';
            relativeTurnLeft.style.bottom = '20px';
            relativeTurnLeft.style.top = 'auto';
            relativeTurnLeft.style.transform = 'none';
            relativeTurnLeft.style.right = 'auto';
          }
          if (!rightPos && relativeTurnRight) {
            relativeTurnRight.style.right = '20px';
            relativeTurnRight.style.bottom = '20px';
            relativeTurnRight.style.top = 'auto';
            relativeTurnRight.style.transform = 'none';
            relativeTurnRight.style.left = 'auto';
          }
        }
      }
    }
    
    // Update direction button handlers based on control mode
    function updateDirectionButtons() {
      const directionControls = document.getElementById('directionControls');
      const relativeTurnLeft = document.getElementById('relativeTurnLeft');
      const relativeTurnRight = document.getElementById('relativeTurnRight');
      const btnTurnLeft = document.getElementById('btnTurnLeft');
      const btnTurnRight = document.getElementById('btnTurnRight');
      
      const splitControlLeft = document.getElementById('splitControlLeft');
      const splitControlRight = document.getElementById('splitControlRight');
      
      if (controlMode === 'none') {
        // Hide all touch controls
        directionControls.style.display = 'none';
        relativeTurnLeft.classList.remove('show');
        relativeTurnRight.classList.remove('show');
        if (splitControlLeft) splitControlLeft.classList.remove('show');
        if (splitControlRight) splitControlRight.classList.remove('show');
      } else if (controlMode === 'relative') {
        // Hide absolute direction controls and split controls
        directionControls.style.display = 'none';
        if (splitControlLeft) splitControlLeft.classList.remove('show');
        if (splitControlRight) splitControlRight.classList.remove('show');
        
        // Show relative turn controls
        relativeTurnLeft.classList.add('show');
        relativeTurnRight.classList.add('show');
        
        // Remove existing listeners by cloning and replacing buttons
        const newBtnTurnLeft = btnTurnLeft.cloneNode(true);
        const newBtnTurnRight = btnTurnRight.cloneNode(true);
        btnTurnLeft.parentNode.replaceChild(newBtnTurnLeft, btnTurnLeft);
        btnTurnRight.parentNode.replaceChild(newBtnTurnRight, btnTurnRight);
        
        // Update references
        const updatedBtnTurnLeft = document.getElementById('btnTurnLeft');
        const updatedBtnTurnRight = document.getElementById('btnTurnRight');
        
        // Set up relative turn buttons
        updatedBtnTurnLeft.addEventListener('click', () => {
          const newDir = getRelativeDirection('left');
          changeDirection(newDir);
        });
        updatedBtnTurnRight.addEventListener('click', () => {
          const newDir = getRelativeDirection('right');
          changeDirection(newDir);
        });
        
        // Position relative controls at bottom of game area (if not already positioned)
        // Use setTimeout to ensure game container is rendered
        setTimeout(() => {
          positionRelativeControlsAtBottom();
        }, 100);
      } else if (controlMode === 'split') {
        // Hide absolute direction controls and relative turn controls
        directionControls.style.display = 'none';
        relativeTurnLeft.classList.remove('show');
        relativeTurnRight.classList.remove('show');
        
        // Show split controls
        if (splitControlLeft) splitControlLeft.classList.add('show');
        if (splitControlRight) splitControlRight.classList.add('show');
        
        // Get split control buttons
        const splitBtnUpLeft = document.getElementById('splitBtnUpLeft');
        const splitBtnLeft = document.getElementById('splitBtnLeft');
        const splitBtnDownLeft = document.getElementById('splitBtnDownLeft');
        const splitBtnUpRight = document.getElementById('splitBtnUpRight');
        const splitBtnRight = document.getElementById('splitBtnRight');
        const splitBtnDownRight = document.getElementById('splitBtnDownRight');
        
        // Remove existing listeners by cloning and replacing
        const newSplitBtnUpLeft = splitBtnUpLeft.cloneNode(true);
        const newSplitBtnLeft = splitBtnLeft.cloneNode(true);
        const newSplitBtnDownLeft = splitBtnDownLeft.cloneNode(true);
        const newSplitBtnUpRight = splitBtnUpRight.cloneNode(true);
        const newSplitBtnRight = splitBtnRight.cloneNode(true);
        const newSplitBtnDownRight = splitBtnDownRight.cloneNode(true);
        
        splitBtnUpLeft.parentNode.replaceChild(newSplitBtnUpLeft, splitBtnUpLeft);
        splitBtnLeft.parentNode.replaceChild(newSplitBtnLeft, splitBtnLeft);
        splitBtnDownLeft.parentNode.replaceChild(newSplitBtnDownLeft, splitBtnDownLeft);
        splitBtnUpRight.parentNode.replaceChild(newSplitBtnUpRight, splitBtnUpRight);
        splitBtnRight.parentNode.replaceChild(newSplitBtnRight, splitBtnRight);
        splitBtnDownRight.parentNode.replaceChild(newSplitBtnDownRight, splitBtnDownRight);
        
        // Set up split control buttons
        newSplitBtnUpLeft.addEventListener('click', () => changeDirection({ x: 0, y: -1 }));
        newSplitBtnLeft.addEventListener('click', () => changeDirection({ x: -1, y: 0 }));
        newSplitBtnDownLeft.addEventListener('click', () => changeDirection({ x: 0, y: 1 }));
        newSplitBtnUpRight.addEventListener('click', () => changeDirection({ x: 0, y: -1 }));
        newSplitBtnRight.addEventListener('click', () => changeDirection({ x: 1, y: 0 }));
        newSplitBtnDownRight.addEventListener('click', () => changeDirection({ x: 0, y: 1 }));
        
        // Position split controls on sides (if not already positioned)
        setTimeout(() => {
          positionSplitControlsOnSides();
        }, 100);
      } else if (controlMode === 'absolute') {
        // Hide relative turn controls and split controls
        relativeTurnLeft.classList.remove('show');
        relativeTurnRight.classList.remove('show');
        if (splitControlLeft) splitControlLeft.classList.remove('show');
        if (splitControlRight) splitControlRight.classList.remove('show');
        
        // Show absolute direction controls
        directionControls.style.display = 'grid';
        
        // Set up absolute direction buttons
        const btnUp = document.getElementById('btnUp');
        const btnDown = document.getElementById('btnDown');
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');
        
        // Remove existing listeners by cloning and replacing
        const newBtnUp = btnUp.cloneNode(true);
        const newBtnDown = btnDown.cloneNode(true);
        const newBtnLeft = btnLeft.cloneNode(true);
        const newBtnRight = btnRight.cloneNode(true);
        
        btnUp.parentNode.replaceChild(newBtnUp, btnUp);
        btnDown.parentNode.replaceChild(newBtnDown, btnDown);
        btnLeft.parentNode.replaceChild(newBtnLeft, btnLeft);
        btnRight.parentNode.replaceChild(newBtnRight, btnRight);
        
        newBtnUp.addEventListener('click', () => changeDirection({ x: 0, y: -1 }));
        newBtnDown.addEventListener('click', () => changeDirection({ x: 0, y: 1 }));
        newBtnLeft.addEventListener('click', () => changeDirection({ x: -1, y: 0 }));
        newBtnRight.addEventListener('click', () => changeDirection({ x: 1, y: 0 }));
      }
    }
    
    // Initialize direction buttons
    updateDirectionButtons();
    
    // Draggable direction controls
    const directionControls = document.getElementById('directionControls');
    const directionControlsHandle = document.getElementById('directionControlsHandle');
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };
    
    // Load saved position
    const savedPosition = localStorage.getItem('directionControlsPosition');
    if (savedPosition) {
      const pos = JSON.parse(savedPosition);
      directionControls.style.left = pos.left + 'px';
      directionControls.style.top = pos.top + 'px';
      directionControls.style.bottom = 'auto';
      directionControls.style.right = 'auto';
    }
    
    function savePosition() {
      const rect = directionControls.getBoundingClientRect();
      localStorage.setItem('directionControlsPosition', JSON.stringify({
        left: rect.left,
        top: rect.top
      }));
    }
    
    // Handle drag start
    function startDrag(e) {
      // Only drag from handle, not from buttons
      const target = e.target;
      if (target !== directionControlsHandle && 
          !directionControlsHandle.contains(target) &&
          !target.closest('.direction-controls-handle')) {
        return;
      }
      isDragging = true;
      directionControls.classList.add('dragging');
      const rect = directionControls.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      dragOffset.x = clientX - rect.left;
      dragOffset.y = clientY - rect.top;
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Handle drag
    function doDrag(e) {
      if (!isDragging) return;
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
      let newLeft = clientX - dragOffset.x;
      let newTop = clientY - dragOffset.y;
      
      // Constrain to viewport
      const rect = directionControls.getBoundingClientRect();
      const maxLeft = window.innerWidth - rect.width;
      const maxTop = window.innerHeight - rect.height;
      
      newLeft = Math.max(0, Math.min(newLeft, maxLeft));
      newTop = Math.max(0, Math.min(newTop, maxTop));
      
      directionControls.style.left = newLeft + 'px';
      directionControls.style.top = newTop + 'px';
      directionControls.style.bottom = 'auto';
      directionControls.style.right = 'auto';
      
      e.preventDefault();
    }
    
    // Handle drag end
    function endDrag() {
      if (isDragging) {
        isDragging = false;
        directionControls.classList.remove('dragging');
        savePosition();
      }
    }
    
    // Add event listeners for dragging
    directionControlsHandle.addEventListener('mousedown', startDrag);
    directionControlsHandle.addEventListener('touchstart', startDrag, { passive: false });
    document.addEventListener('mousemove', doDrag);
    document.addEventListener('touchmove', doDrag, { passive: false });
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchend', endDrag);
    
    // Prevent button clicks from triggering drag
    directionControls.addEventListener('mousedown', (e) => {
      const target = e.target;
      // Allow buttons to work normally
      if (target.closest('.direction-btn') && !target.closest('.direction-controls-handle')) {
        return; // Let button click handlers work
      }
      // Only allow drag from handle
      if (target !== directionControlsHandle && !target.closest('.direction-controls-handle')) {
        e.stopPropagation();
      }
    });
    
    // Draggable relative turn controls (will be initialized after updateDirectionButtons)
    let relativeTurnLeft = document.getElementById('relativeTurnLeft');
    let relativeTurnRight = document.getElementById('relativeTurnRight');
    let relativeTurnLeftHandle = document.getElementById('relativeTurnLeftHandle');
    let relativeTurnRightHandle = document.getElementById('relativeTurnRightHandle');
    let isDraggingLeft = false;
    let isDraggingRight = false;
    let dragOffsetLeft = { x: 0, y: 0 };
    let dragOffsetRight = { x: 0, y: 0 };
    
    // Load saved positions for relative controls
    const savedLeftPos = localStorage.getItem('relativeTurnLeftPosition');
    const savedRightPos = localStorage.getItem('relativeTurnRightPosition');
    if (savedLeftPos) {
      const pos = JSON.parse(savedLeftPos);
      relativeTurnLeft.style.left = pos.left + 'px';
      relativeTurnLeft.style.top = pos.top + 'px';
      relativeTurnLeft.style.bottom = 'auto';
      relativeTurnLeft.style.right = 'auto';
      relativeTurnLeft.style.transform = 'none';
    }
    if (savedRightPos) {
      const pos = JSON.parse(savedRightPos);
      relativeTurnRight.style.left = pos.left + 'px';
      relativeTurnRight.style.top = pos.top + 'px';
      relativeTurnRight.style.bottom = 'auto';
      relativeTurnRight.style.right = 'auto';
      relativeTurnRight.style.transform = 'none';
    }
    
    function saveRelativePosition(control, isLeft) {
      const rect = control.getBoundingClientRect();
      const key = isLeft ? 'relativeTurnLeftPosition' : 'relativeTurnRightPosition';
      localStorage.setItem(key, JSON.stringify({
        left: rect.left,
        top: rect.top
      }));
    }
    
    // Handle drag start for left control
    function startDragLeft(e) {
      const target = e.target;
      if (target !== relativeTurnLeftHandle && 
          !relativeTurnLeftHandle.contains(target) &&
          !target.closest('.relative-turn-control-handle')) {
        return;
      }
      isDraggingLeft = true;
      relativeTurnLeft.classList.add('dragging');
      const rect = relativeTurnLeft.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      dragOffsetLeft.x = clientX - rect.left;
      dragOffsetLeft.y = clientY - rect.top;
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Handle drag start for right control
    function startDragRight(e) {
      const target = e.target;
      if (target !== relativeTurnRightHandle && 
          !relativeTurnRightHandle.contains(target) &&
          !target.closest('.relative-turn-control-handle')) {
        return;
      }
      isDraggingRight = true;
      relativeTurnRight.classList.add('dragging');
      const rect = relativeTurnRight.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      dragOffsetRight.x = clientX - rect.left;
      dragOffsetRight.y = clientY - rect.top;
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Handle drag for relative controls
    function doDragRelative(e) {
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
      if (isDraggingLeft) {
        let newLeft = clientX - dragOffsetLeft.x;
        let newTop = clientY - dragOffsetLeft.y;
        
        const rect = relativeTurnLeft.getBoundingClientRect();
        const maxLeft = window.innerWidth - rect.width;
        const maxTop = window.innerHeight - rect.height;
        
        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        newTop = Math.max(0, Math.min(newTop, maxTop));
        
        relativeTurnLeft.style.left = newLeft + 'px';
        relativeTurnLeft.style.top = newTop + 'px';
        relativeTurnLeft.style.bottom = 'auto';
        relativeTurnLeft.style.right = 'auto';
        relativeTurnLeft.style.transform = 'none';
      }
      
      if (isDraggingRight) {
        let newLeft = clientX - dragOffsetRight.x;
        let newTop = clientY - dragOffsetRight.y;
        
        const rect = relativeTurnRight.getBoundingClientRect();
        const maxLeft = window.innerWidth - rect.width;
        const maxTop = window.innerHeight - rect.height;
        
        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        newTop = Math.max(0, Math.min(newTop, maxTop));
        
        relativeTurnRight.style.left = newLeft + 'px';
        relativeTurnRight.style.top = newTop + 'px';
        relativeTurnRight.style.bottom = 'auto';
        relativeTurnRight.style.right = 'auto';
        relativeTurnRight.style.transform = 'none';
      }
      
      if (isDraggingLeft || isDraggingRight) {
        e.preventDefault();
      }
    }
    
    // Handle drag end for relative controls
    function endDragRelative() {
      if (isDraggingLeft) {
        isDraggingLeft = false;
        relativeTurnLeft.classList.remove('dragging');
        saveRelativePosition(relativeTurnLeft, true);
      }
      if (isDraggingRight) {
        isDraggingRight = false;
        relativeTurnRight.classList.remove('dragging');
        saveRelativePosition(relativeTurnRight, false);
      }
    }
    
    // Add event listeners for dragging relative controls
    relativeTurnLeftHandle.addEventListener('mousedown', startDragLeft);
    relativeTurnLeftHandle.addEventListener('touchstart', startDragLeft, { passive: false });
    relativeTurnRightHandle.addEventListener('mousedown', startDragRight);
    relativeTurnRightHandle.addEventListener('touchstart', startDragRight, { passive: false });
    
    // Update global drag handlers to include relative controls
    document.addEventListener('mousemove', doDragRelative);
    document.addEventListener('touchmove', doDragRelative, { passive: false });
    document.addEventListener('mouseup', endDragRelative);
    document.addEventListener('touchend', endDragRelative);
    
    // Prevent button clicks from triggering drag on relative controls
    relativeTurnLeft.addEventListener('mousedown', (e) => {
      const target = e.target;
      if (target.closest('.relative-turn-btn') && !target.closest('.relative-turn-control-handle')) {
        return;
      }
      if (target !== relativeTurnLeftHandle && !target.closest('.relative-turn-control-handle')) {
        e.stopPropagation();
      }
    });
    
    relativeTurnRight.addEventListener('mousedown', (e) => {
      const target = e.target;
      if (target.closest('.relative-turn-btn') && !target.closest('.relative-turn-control-handle')) {
        return;
      }
      if (target !== relativeTurnRightHandle && !target.closest('.relative-turn-control-handle')) {
        e.stopPropagation();
      }
    });
    
    // Draggable split controls
    let splitControlLeft = document.getElementById('splitControlLeft');
    let splitControlRight = document.getElementById('splitControlRight');
    let splitControlLeftHandle = document.getElementById('splitControlLeftHandle');
    let splitControlRightHandle = document.getElementById('splitControlRightHandle');
    let isDraggingSplitLeft = false;
    let isDraggingSplitRight = false;
    let dragOffsetSplitLeft = { x: 0, y: 0 };
    let dragOffsetSplitRight = { x: 0, y: 0 };
    
    // Load saved positions for split controls
    const savedSplitLeftPos = localStorage.getItem('splitControlLeftPosition');
    const savedSplitRightPos = localStorage.getItem('splitControlRightPosition');
    if (savedSplitLeftPos && splitControlLeft) {
      const pos = JSON.parse(savedSplitLeftPos);
      splitControlLeft.style.left = pos.left + 'px';
      splitControlLeft.style.top = pos.top + 'px';
      splitControlLeft.style.bottom = 'auto';
      splitControlLeft.style.right = 'auto';
      splitControlLeft.style.transform = 'none';
    }
    if (savedSplitRightPos && splitControlRight) {
      const pos = JSON.parse(savedSplitRightPos);
      splitControlRight.style.left = pos.left + 'px';
      splitControlRight.style.top = pos.top + 'px';
      splitControlRight.style.bottom = 'auto';
      splitControlRight.style.right = 'auto';
      splitControlRight.style.transform = 'none';
    }
    
    function saveSplitPosition(control, isLeft) {
      const rect = control.getBoundingClientRect();
      const key = isLeft ? 'splitControlLeftPosition' : 'splitControlRightPosition';
      localStorage.setItem(key, JSON.stringify({
        left: rect.left,
        top: rect.top
      }));
    }
    
    // Handle drag start for split left control
    function startDragSplitLeft(e) {
      const target = e.target;
      if (target !== splitControlLeftHandle && 
          !splitControlLeftHandle.contains(target) &&
          !target.closest('.split-control-handle')) {
        return;
      }
      isDraggingSplitLeft = true;
      splitControlLeft.classList.add('dragging');
      const rect = splitControlLeft.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      dragOffsetSplitLeft.x = clientX - rect.left;
      dragOffsetSplitLeft.y = clientY - rect.top;
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Handle drag start for split right control
    function startDragSplitRight(e) {
      const target = e.target;
      if (target !== splitControlRightHandle && 
          !splitControlRightHandle.contains(target) &&
          !target.closest('.split-control-handle')) {
        return;
      }
      isDraggingSplitRight = true;
      splitControlRight.classList.add('dragging');
      const rect = splitControlRight.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      dragOffsetSplitRight.x = clientX - rect.left;
      dragOffsetSplitRight.y = clientY - rect.top;
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Handle drag for split controls
    function doDragSplit(e) {
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
      if (isDraggingSplitLeft && splitControlLeft) {
        let newLeft = clientX - dragOffsetSplitLeft.x;
        let newTop = clientY - dragOffsetSplitLeft.y;
        
        const rect = splitControlLeft.getBoundingClientRect();
        const maxLeft = window.innerWidth - rect.width;
        
        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        // Allow positioning anywhere vertically, including below the viewport
        
        splitControlLeft.style.left = newLeft + 'px';
        splitControlLeft.style.top = newTop + 'px';
        splitControlLeft.style.bottom = 'auto';
        splitControlLeft.style.right = 'auto';
        splitControlLeft.style.transform = 'none';
      }
      
      if (isDraggingSplitRight && splitControlRight) {
        let newLeft = clientX - dragOffsetSplitRight.x;
        let newTop = clientY - dragOffsetSplitRight.y;
        
        const rect = splitControlRight.getBoundingClientRect();
        const maxLeft = window.innerWidth - rect.width;
        
        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        // Allow positioning anywhere vertically, including below the viewport
        
        splitControlRight.style.left = newLeft + 'px';
        splitControlRight.style.top = newTop + 'px';
        splitControlRight.style.bottom = 'auto';
        splitControlRight.style.right = 'auto';
        splitControlRight.style.transform = 'none';
      }
      
      if (isDraggingSplitLeft || isDraggingSplitRight) {
        e.preventDefault();
      }
    }
    
    // Handle drag end for split controls
    function endDragSplit() {
      if (isDraggingSplitLeft && splitControlLeft) {
        isDraggingSplitLeft = false;
        splitControlLeft.classList.remove('dragging');
        saveSplitPosition(splitControlLeft, true);
      }
      if (isDraggingSplitRight && splitControlRight) {
        isDraggingSplitRight = false;
        splitControlRight.classList.remove('dragging');
        saveSplitPosition(splitControlRight, false);
      }
    }
    
    // Add event listeners for dragging split controls
    if (splitControlLeftHandle) {
      splitControlLeftHandle.addEventListener('mousedown', startDragSplitLeft);
      splitControlLeftHandle.addEventListener('touchstart', startDragSplitLeft, { passive: false });
    }
    if (splitControlRightHandle) {
      splitControlRightHandle.addEventListener('mousedown', startDragSplitRight);
      splitControlRightHandle.addEventListener('touchstart', startDragSplitRight, { passive: false });
    }
    
    // Update global drag handlers to include split controls
    document.addEventListener('mousemove', doDragSplit);
    document.addEventListener('touchmove', doDragSplit, { passive: false });
    document.addEventListener('mouseup', endDragSplit);
    document.addEventListener('touchend', endDragSplit);
    
    // Prevent button clicks from triggering drag on split controls
    if (splitControlLeft) {
      splitControlLeft.addEventListener('mousedown', (e) => {
        const target = e.target;
        if (target.closest('.split-btn') && !target.closest('.split-control-handle')) {
          return;
        }
        if (target !== splitControlLeftHandle && !target.closest('.split-control-handle')) {
          e.stopPropagation();
        }
      });
    }
    
    if (splitControlRight) {
      splitControlRight.addEventListener('mousedown', (e) => {
        const target = e.target;
        if (target.closest('.split-btn') && !target.closest('.split-control-handle')) {
          return;
        }
        if (target !== splitControlRightHandle && !target.closest('.split-control-handle')) {
          e.stopPropagation();
        }
      });
    }

    // Restart button
    restartBtn.addEventListener('click', () => {
      SoundManager.playGlitch();
      restartBtn.classList.add('clicking');
      setTimeout(() => {
        restartBtn.classList.remove('clicking');
      }, 400);
      
      canvas.classList.add('glitching');
      setTimeout(() => {
        canvas.classList.remove('glitching');
      }, 500);
      
      // Stop any existing loops first
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Reset all game state before restarting
      gameRunning = false;
      gameOver = false;
      gamePaused = false;
      score = 10; // Snake starts with 1 segment = 10 points
      snake = [{ x: 0, y: 0 }]; // Start at top left
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      directionQueue = [];
      currentSpeed = INITIAL_SPEED;
      lastMoveTime = 0;
      
      // Set initial food position (cell 4, top row) for immediate catch
      food = [{ x: 4, y: 0 }];
      
      // Hide game over screen if it's showing
      hideGameOver();
      
      // Don't auto-start - wait for user to press start button
      updateScores();
      showStartButton();
      draw();
    });

    restartGameBtn.addEventListener('click', () => {
      // Play glitch sound like reboot button
      SoundManager.playGlitch();
      
      // Add glitching animation to canvas
      canvas.classList.add('glitching');
      setTimeout(() => {
        canvas.classList.remove('glitching');
      }, 500);
      
      // Stop any existing loops first
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Reset all game state before restarting (same as reboot)
      gameRunning = false;
      gameOver = false;
      gamePaused = false;
      score = 10; // Snake starts with 1 segment = 10 points
      snake = [{ x: 0, y: 0 }]; // Start at top left
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      directionQueue = [];
      currentSpeed = INITIAL_SPEED;
      lastMoveTime = 0;
      
      // Set initial food position (cell 4, top row) for immediate catch
      food = [{ x: 4, y: 0 }];
      
      // Hide game over screen
      hideGameOver();
      
      // Don't auto-start - wait for user to press start button
      updateScores();
      showStartButton();
      draw();
    });

    // Menu toggle
    const menuToggle = document.getElementById('menuToggle');
    const menuDropdown = document.getElementById('menuDropdown');
    
    if (menuToggle && menuDropdown) {
      menuToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        const isShowing = menuDropdown.classList.contains('show');
        
        if (!isShowing) {
          // Show temporarily to measure
          menuDropdown.style.display = 'flex';
          menuDropdown.style.visibility = 'hidden';
          
          const toggleRect = menuToggle.getBoundingClientRect();
          const dropdownRect = menuDropdown.getBoundingClientRect();
          const spaceBelow = window.innerHeight - toggleRect.bottom;
          const spaceAbove = toggleRect.top;
          const dropdownHeight = dropdownRect.height;
          
          // Reset display
          menuDropdown.style.display = '';
          menuDropdown.style.visibility = '';
          
          // If not enough space below but enough space above, open above
          if (spaceBelow < dropdownHeight + 20 && spaceAbove > dropdownHeight + 20) {
            menuDropdown.classList.add('open-above');
          } else {
            menuDropdown.classList.remove('open-above');
          }
        }
        
        menuDropdown.classList.toggle('show');
      });
      
      const closeMenuIfOutside = (e) => {
        const target = e.target;
        if (menuDropdown.classList.contains('show')) {
          if (!menuToggle.contains(target) && !menuDropdown.contains(target)) {
            menuDropdown.classList.remove('show');
          }
        }
      };
      
      document.addEventListener('click', closeMenuIfOutside);
      document.addEventListener('touchend', closeMenuIfOutside);
    }

    // Sound button
    const soundBtn = document.getElementById('soundBtn');
    if (soundBtn) {
      soundBtn.addEventListener('click', () => {
        SoundManager.toggle();
      });
    }

    // Autodrive button and controls
    const autodriveBtn = document.getElementById('autodriveBtn');
    const autodrivePanel = document.getElementById('autodrivePanel');
    const autodriveSpeedSlider = document.getElementById('autodriveSpeed');
    const autodriveSpeedValue = document.getElementById('autodriveSpeedValue');
    const autodriveStop = document.getElementById('autodriveStop');

    if (autodriveBtn && autodrivePanel) {
      autodriveBtn.addEventListener('click', () => {
        if (!gameRunning || gameOver) {
          // Start game first if not running
          startGame();
        }
        
        if (autodriveActive) {
          // Stop autodrive
          autodriveActive = false;
          autodriveBtn.classList.remove('active');
          autodrivePanel.classList.remove('show');
        } else {
          // Start autodrive
          autodriveActive = true;
          autodriveBtn.classList.add('active');
          autodrivePanel.classList.add('show');
          gamePaused = false; // Ensure game is not paused
        }
      });
    }

    if (autodriveSpeedSlider && autodriveSpeedValue) {
      // Use both input and change events for better touch support
      const updateSpeed = (e) => {
        autodriveSpeed = parseFloat(e.target.value);
        autodriveSpeedValue.textContent = autodriveSpeed + 'x';
      };
      autodriveSpeedSlider.addEventListener('input', updateSpeed);
      autodriveSpeedSlider.addEventListener('change', updateSpeed);
      
      // Prevent scrolling when interacting with slider on touch devices
      autodriveSpeedSlider.addEventListener('touchstart', (e) => {
        // Allow the slider to work, but prevent page scrolling
        const touch = e.touches[0];
        const sliderRect = autodriveSpeedSlider.getBoundingClientRect();
        const percentage = (touch.clientX - sliderRect.left) / sliderRect.width;
        const min = parseFloat(autodriveSpeedSlider.min);
        const max = parseFloat(autodriveSpeedSlider.max);
        const value = min + (percentage * (max - min));
        autodriveSpeedSlider.value = Math.max(min, Math.min(max, value));
        updateSpeed({ target: autodriveSpeedSlider });
      }, { passive: false });
      
      autodriveSpeedSlider.addEventListener('touchmove', (e) => {
        e.preventDefault(); // Prevent scrolling
        const touch = e.touches[0];
        const sliderRect = autodriveSpeedSlider.getBoundingClientRect();
        const percentage = (touch.clientX - sliderRect.left) / sliderRect.width;
        const min = parseFloat(autodriveSpeedSlider.min);
        const max = parseFloat(autodriveSpeedSlider.max);
        const value = min + (percentage * (max - min));
        autodriveSpeedSlider.value = Math.max(min, Math.min(max, value));
        updateSpeed({ target: autodriveSpeedSlider });
      }, { passive: false });
    }

    const spawnSnackBtn = document.getElementById('spawnSnack');
    if (spawnSnackBtn) {
      spawnSnackBtn.addEventListener('click', () => {
        if (gameRunning && !gameOver) {
          // Don't spawn if we're at max score
          if (score >= 4000) return;
          
          // Calculate empty squares (total squares - snake - existing food)
          const totalSquares = GRID_SIZE * GRID_SIZE;
          const occupiedSquares = snake.length + food.length;
          const emptySquares = totalSquares - occupiedSquares;
          
          // Calculate 80% of empty squares
          const snacksToSpawn = Math.floor(emptySquares * 0.8);
          
          // Spawn snacks in empty cells
          for (let i = 0; i < snacksToSpawn; i++) {
            // Don't add food if we're at max score
            if (score >= 4000) break;
            
            // Try to generate food, but limit attempts to avoid infinite loops
            let attempts = 0;
            let newFood;
            do {
              newFood = {
                x: Math.floor(Math.random() * GRID_SIZE),
                y: Math.floor(Math.random() * GRID_SIZE)
              };
              attempts++;
              // If we can't find an empty spot after many attempts, break
              if (attempts > 100) break;
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
                     food.some(f => f.x === newFood.x && f.y === newFood.y));
            
            // Only add if we found a valid position
            if (attempts <= 100) {
              food.push(newFood);
            }
          }
          
          draw();
        }
      });
    }

    if (autodriveStop) {
      autodriveStop.addEventListener('click', () => {
        autodriveActive = false;
        autodriveBtn.classList.remove('active');
        autodrivePanel.classList.remove('show');
        // Pause the game when stopping autodrive
        if (gameRunning && !gameOver) {
          gamePaused = true;
          updatePauseButton();
        }
      });
    }

    // Pause button
    const pauseBtnTop = document.getElementById('pauseBtnTop');
    if (pauseBtnTop) {
      pauseBtnTop.addEventListener('click', () => {
        togglePause();
      });
    }

    // Clear high score
    const clearHighScoreBtn = document.getElementById('clearHighScoreBtn');
    const confirmModal = document.getElementById('confirmModal');
    const confirmYes = document.getElementById('confirmYes');
    const confirmNo = document.getElementById('confirmNo');
    
    if (clearHighScoreBtn && confirmModal) {
      clearHighScoreBtn.addEventListener('click', () => {
        confirmModal.classList.add('show');
        if (menuDropdown) menuDropdown.classList.remove('show');
      });
    }

    if (confirmYes) {
      confirmYes.addEventListener('click', () => {
        highscore = 0;
        // Store as number (localStorage will convert to string, but this ensures consistency)
        localStorage.setItem('snakeHighscore', String(0));
        updateScores();
        if (confirmModal) confirmModal.classList.remove('show');
        // Don't auto-start game after clearing high score
      });
    }

    if (confirmNo) {
      confirmNo.addEventListener('click', () => {
        if (confirmModal) confirmModal.classList.remove('show');
      });
    }

    if (confirmModal) {
      confirmModal.addEventListener('click', (e) => {
        if (e.target === confirmModal) {
          confirmModal.classList.remove('show');
        }
      });
    }

    // Help modal
    const helpBtn = document.getElementById('helpBtn');
    const helpModal = document.getElementById('helpModal');
    const closeHelp = document.getElementById('closeHelp');

    if (helpBtn) {
      helpBtn.addEventListener('click', () => {
        helpModal.classList.add('show');
        menuDropdown.classList.remove('show');
      });
    }

    if (closeHelp) {
      closeHelp.addEventListener('click', () => {
        helpModal.classList.remove('show');
      });
    }

    if (helpModal) {
      helpModal.addEventListener('click', (e) => {
        if (e.target === helpModal) {
          helpModal.classList.remove('show');
        }
      });
    }

    // Control mode modal
    const controlModeBtn = document.getElementById('controlModeBtn');
    const controlModeModal = document.getElementById('controlModeModal');
    const closeControlMode = document.getElementById('closeControlMode');
    const controlModeAbsolute = document.getElementById('controlModeAbsolute');
    const controlModeRelative = document.getElementById('controlModeRelative');

    if (controlModeBtn) {
      controlModeBtn.addEventListener('click', () => {
        controlModeModal.classList.add('show');
        if (menuDropdown) menuDropdown.classList.remove('show');
      });
    }

    if (closeControlMode) {
      closeControlMode.addEventListener('click', () => {
        controlModeModal.classList.remove('show');
      });
    }

    // Control mode modal should only close with X button, not by clicking outside

    const controlModeSelect = document.getElementById('controlModeSelect');
    const controlModeDescription = document.getElementById('controlModeDescription');
    
    // Description texts for each mode
    const modeDescriptions = {
      'none': 'No touch controls displayed. Use keyboard or swipe gestures to play.',
      'absolute': 'Up/Down/Left/Right buttons always move in those directions.',
      'relative': 'Buttons turn the snake left or right from its current facing direction.',
      'split': 'Left side: Up, Left, Down. Right side: Up, Right, Down. Split directional controls on both sides.'
    };
    
    // Set initial value and description
    if (controlModeSelect) {
      controlModeSelect.value = controlMode;
      if (controlModeDescription) {
        controlModeDescription.textContent = modeDescriptions[controlMode] || modeDescriptions['none'];
      }
    }

    function setControlMode(mode) {
      controlMode = mode;
      localStorage.setItem('controlMode', mode);
      updateDirectionButtons();
      // Update dropdown and description
      if (controlModeSelect) {
        controlModeSelect.value = mode;
      }
      if (controlModeDescription) {
        controlModeDescription.textContent = modeDescriptions[mode] || modeDescriptions['none'];
      }
      // Don't close the modal - let user see the controls change and close manually with X
    }
    
    // Handle dropdown change
    if (controlModeSelect) {
      controlModeSelect.addEventListener('change', (e) => {
        setControlMode(e.target.value);
      });
    }

    // Reset control positions button
    const resetControlPositions = document.getElementById('resetControlPositions');
    if (resetControlPositions) {
      resetControlPositions.addEventListener('click', () => {
        // Clear saved positions from localStorage
        localStorage.removeItem('directionControlsPosition');
        localStorage.removeItem('relativeTurnLeftPosition');
        localStorage.removeItem('relativeTurnRightPosition');
        localStorage.removeItem('splitControlLeftPosition');
        localStorage.removeItem('splitControlRightPosition');
        
        // Reset absolute direction controls to default position
        const directionControls = document.getElementById('directionControls');
        if (directionControls) {
          directionControls.style.left = '80px';
          directionControls.style.top = 'auto';
          directionControls.style.bottom = '40px';
          directionControls.style.right = 'auto';
          directionControls.style.transform = 'none';
        }
        
        // Reset relative turn controls
        const relativeTurnLeft = document.getElementById('relativeTurnLeft');
        const relativeTurnRight = document.getElementById('relativeTurnRight');
        
        if (relativeTurnLeft && relativeTurnRight) {
          // Clear their positions and reposition at bottom of game area
          relativeTurnLeft.style.left = '';
          relativeTurnLeft.style.top = '';
          relativeTurnLeft.style.bottom = '';
          relativeTurnLeft.style.right = '';
          relativeTurnLeft.style.transform = '';
          
          relativeTurnRight.style.left = '';
          relativeTurnRight.style.top = '';
          relativeTurnRight.style.bottom = '';
          relativeTurnRight.style.right = '';
          relativeTurnRight.style.transform = '';
          
          // Reposition at bottom of game area
          setTimeout(() => {
            positionRelativeControlsAtBottom();
          }, 100);
        }
        
        // Reset split controls
        const splitControlLeft = document.getElementById('splitControlLeft');
        const splitControlRight = document.getElementById('splitControlRight');
        
        if (splitControlLeft && splitControlRight) {
          // Clear their positions
          splitControlLeft.style.left = '';
          splitControlLeft.style.top = '';
          splitControlLeft.style.bottom = '';
          splitControlLeft.style.right = '';
          splitControlLeft.style.transform = '';
          
          splitControlRight.style.left = '';
          splitControlRight.style.top = '';
          splitControlRight.style.bottom = '';
          splitControlRight.style.right = '';
          splitControlRight.style.transform = '';
          
          // Reposition on sides
          setTimeout(() => {
            positionSplitControlsOnSides();
          }, 100);
        }
        
        // Play feedback sound
        SoundManager.playGlitch();
      });
    }

    // Close modals with Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (helpModal && helpModal.classList.contains('show')) {
          helpModal.classList.remove('show');
        }
        if (confirmModal && confirmModal.classList.contains('show')) {
          confirmModal.classList.remove('show');
        }
        // Control mode modal should only close with X button, not Escape
      }
    });

    // Initialize - set initial food position (cell 4, top row) for immediate catch
    food = [{ x: 4, y: 0 }];
    updateScores();
    draw();
    
    // Show start button initially
    showStartButton();
    
    // Position controls on initial load if in relative or split mode
    if (controlMode === 'relative') {
      setTimeout(() => {
        positionRelativeControlsAtBottom();
      }, 200);
    } else if (controlMode === 'split') {
      setTimeout(() => {
        positionSplitControlsOnSides();
      }, 200);
    }
    
    // Start button click handler
    if (startGameBtn) {
      startGameBtn.addEventListener('click', () => {
        startGame();
      });
    }
  </script>
</body>
</html>



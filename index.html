<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Cyberpunk Snake">
  <meta name="description" content="A cyberpunk-themed Snake game with neon visuals, smooth animations, and retro aesthetics. Play now!">
  <meta name="keywords" content="snake, game, cyberpunk, neon, retro, html5">
  <title>Cyberpunk Snake - Neon Arcade Game</title>
  <link rel="icon" href="images/snake-logo.png" type="image/png">
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Sixtyfour&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(135deg, #1a0a1f 0%, #0f0515 30%, #0a030a 60%, #000000 100%);
      font-family: 'Share Tech Mono', monospace;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #0ff;
      overflow: hidden;
      text-shadow: 0 0 8px #0ff;
      position: relative;
    }
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.15) 1px, transparent 0),
        radial-gradient(circle at 2px 2px, rgba(0, 0, 0, 0.2) 1px, transparent 0),
        radial-gradient(circle at 3px 3px, rgba(255, 255, 255, 0.1) 1px, transparent 0);
      background-size: 4px 4px, 3px 3px, 5px 5px;
      pointer-events: none;
      z-index: 1;
      opacity: 0.4;
      mix-blend-mode: overlay;
    }
    .code-stream {
      position: fixed;
      left: 20px;
      top: 0;
      width: 60px;
      height: 100%;
      font-size: 9px;
      color: rgba(200, 200, 200, 0.25);
      font-family: 'Share Tech Mono', monospace;
      line-height: 1.3;
      overflow: hidden;
      z-index: 1;
    }
    .code-stream::before {
      content: '0x1A2B\A 0x3C4D\A 0x5E6F\A 0x7890\A 0xABCD\A 0xEF01\A 0x2345\A 0x6789\A 0xFEDC\A 0xBA98\A 0x7654\A 0x3210\A 0x9ABC\A 0xDEF0\A 0x1234\A 0x5678\A 0x9ABC\A 0xDEF0\A 0x2468\A 0xACE0\A 0x1357\A 0x9BDF\A 0x0246\A 0x8ACE\A 0x1357\A 0x9BDF\A 0x2468\A 0xACE0\A 0x1357\A 0x9BDF';
      white-space: pre;
      display: block;
    }
    .text-artifacts {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.15;
    }
    .text-artifacts::before {
      content: 'ERR_0x1A2B\A DATA_CORRUPT\A SYS_FAIL\A INIT_SEQ\A LOAD_FAIL\A MEM_ERR\A PROC_TERM\A EXEC_ERR\A STACK_OVF\A NULL_PTR\A ACCESS_DEN\A INVALID_OP\A TIMEOUT\A DEADLOCK\A RACE_COND\A BUFFER_OVF';
      position: absolute;
      top: 10%;
      left: 15%;
      font-size: 7px;
      color: rgba(150, 150, 150, 0.35);
      font-family: 'Share Tech Mono', monospace;
      white-space: pre;
      line-height: 1.4;
      transform: rotate(-1.5deg);
    }
    .text-artifacts::after {
      content: '[192.168.1.42]\A [10.0.0.15]\A [172.16.0.8]\A PORT:8080\A PORT:443\A PORT:22\A PID:1234\A PID:5678\A PID:9012\A /usr/bin/\A /var/log/\A /tmp/data\A /sys/kernel\A /proc/self\A /dev/null\A /etc/config';
      position: absolute;
      bottom: 20%;
      right: 10%;
      font-size: 8px;
      color: rgba(180, 180, 180, 0.3);
      font-family: 'Share Tech Mono', monospace;
      white-space: pre;
      line-height: 1.5;
      transform: rotate(1deg);
    }
    .geometric-lines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.2;
    }
    .geometric-lines::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(90deg, rgba(0, 245, 255, 0.1) 1px, transparent 1px),
        linear-gradient(rgba(0, 245, 255, 0.1) 1px, transparent 1px),
        linear-gradient(45deg, rgba(255, 0, 64, 0.05) 1px, transparent 1px),
        linear-gradient(-45deg, rgba(255, 0, 64, 0.05) 1px, transparent 1px);
      background-size: 50px 50px, 50px 50px, 100px 100px, 100px 100px;
      background-position: 0 0, 0 0, 0 0, 0 0;
    }
    .game-title {
      position: fixed;
      top: 40px;
      left: 80px;
      z-index: 100;
      pointer-events: none;
    }
    .title-menu {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0;
    }
    .sound-menu {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0;
    }
    #menuToggle {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      width: 44px;
      height: 44px;
      padding: 0;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: text-shadow 0.2s ease, transform 0.2s ease;
      border: none;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      pointer-events: auto;
    }
    #menuToggle:hover {
      text-shadow: 0 0 10px #00f5ff;
      transform: scale(1.1);
    }
    #pauseBtnTop {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      width: 44px;
      height: 44px;
      padding: 0;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: text-shadow 0.2s ease, transform 0.2s ease;
      border: none;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      pointer-events: auto;
    }
    #pauseBtnTop:hover {
      text-shadow: 0 0 10px #00f5ff;
      transform: scale(1.1);
    }
    #pauseBtnTop .material-icons {
      font-family: 'Material Icons';
      font-size: 28px;
      color: inherit;
      line-height: 1;
      display: inline-block;
    }
    .menu-dropdown {
      position: absolute;
      bottom: 50px;
      left: 0;
      background: rgba(10, 10, 30, 0.95);
      border: 1px solid #00f5ff;
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
      display: none;
      flex-direction: column;
      min-width: 160px;
      padding: 4px 0;
      pointer-events: auto;
      z-index: 200;
    }
    .menu-dropdown::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #00f5ff;
      pointer-events: none;
      z-index: 1;
    }
    .menu-dropdown.show {
      display: flex;
    }
    .menu-dropdown button {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 12px;
      padding: 8px 16px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: background 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      border: none;
      outline: none;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
    }
    .menu-dropdown button:hover {
      background: rgba(0, 245, 255, 0.1);
      text-shadow: 0 0 10px #00f5ff;
    }
    .menu-dropdown button .material-icons {
      font-family: 'Material Icons';
      font-size: 12px;
      color: inherit;
      line-height: 1;
      display: inline-block;
      margin-right: 4px;
      vertical-align: middle;
    }
    .game-title-main {
      font-size: 25px;
      font-weight: normal;
      color: #ffeb3b;
      text-shadow: 
        2px 2px 0 #00f5ff,
        0 0 4px rgba(0, 245, 255, 0.4),
        0 0 8px rgba(255, 235, 59, 0.8);
      letter-spacing: 2px;
      font-family: 'Sixtyfour', monospace;
      text-transform: uppercase;
      line-height: 1;
      margin-bottom: 5px;
      filter: drop-shadow(0 0 6px rgba(255, 235, 59, 0.5));
    }
    .game-title-sub {
      font-size: 20px;
      font-weight: bold;
      color: #ff6b35;
      text-shadow: 
        0 0 8px #ff6b35,
        0 0 15px rgba(255, 107, 53, 0.5);
      letter-spacing: 4px;
      font-family: 'Share Tech Mono', monospace;
      text-transform: uppercase;
      line-height: 1;
      margin-left: 2px;
    }
    .top-right-controls {
      position: fixed;
      top: 40px;
      right: 80px;
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 100;
    }
    #restart {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #restart::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #restart .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #restart:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #restart:active {
      background: rgba(255, 107, 53, 0.2);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 20px rgba(255, 0, 64, 0.8);
      text-shadow: 0 0 10px #ff0040;
    }
    #restart.clicking {
      animation: buttonGlitch 0.4s ease;
    }
    #pauseBtn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #pauseBtn::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #pauseBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #pauseBtn:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #pauseBtn:active {
      background: rgba(255, 107, 53, 0.2);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 20px rgba(255, 0, 64, 0.8);
      text-shadow: 0 0 10px #ff0040;
    }
    #soundBtn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease, opacity 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #soundBtn::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #soundBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #soundBtn:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #soundBtn.muted {
      opacity: 0.5;
    }
    #autodriveBtn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #autodriveBtn::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #autodriveBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #autodriveBtn:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #autodriveBtn.active {
      background: rgba(0, 245, 255, 0.1);
      border-color: #00f5ff;
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
    }
    #autodrivePanel {
      position: fixed;
      top: 40px;
      right: 80px;
      background: rgba(10, 10, 30, 0.95);
      border: 2px solid #00f5ff;
      border-radius: 8px;
      padding: 15px 20px;
      min-width: 280px;
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.5), inset 0 0 10px rgba(0, 245, 255, 0.1);
      z-index: 100;
      display: none;
      flex-direction: column;
      gap: 12px;
    }
    #autodrivePanel.show {
      display: flex;
    }
    .autodrive-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    .autodrive-panel-header h3 {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      margin: 0;
      text-shadow: 0 0 8px #00f5ff;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .autodrive-panel-header .autodrive-indicator {
      width: 8px;
      height: 8px;
      background: #ff6b35;
      border-radius: 50%;
      box-shadow: 0 0 8px #ff6b35;
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .autodrive-controls {
      margin: 0;
    }
    .autodrive-controls label {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 12px;
      display: block;
      margin-bottom: 8px;
      text-shadow: 0 0 4px rgba(0, 245, 255, 0.3);
    }
    .autodrive-speed-container {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .autodrive-speed-slider {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      background: rgba(0, 245, 255, 0.3);
      border-radius: 2px;
      outline: none;
    }
    .autodrive-speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #00f5ff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 8px #00f5ff;
      transition: box-shadow 0.2s ease;
    }
    .autodrive-speed-slider::-webkit-slider-thumb:hover {
      box-shadow: 0 0 12px #00f5ff;
    }
    .autodrive-speed-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #00f5ff;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 8px #00f5ff;
    }
    .autodrive-speed-value {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      min-width: 35px;
      text-align: right;
      text-shadow: 0 0 6px #00f5ff;
    }
    #autodriveHyperSpeed {
      background: transparent;
      border: 1px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 11px;
      padding: 6px 15px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
      transition: all 0.3s ease;
      border-radius: 4px;
      text-transform: uppercase;
      width: 100%;
      margin-top: 8px;
    }
    #autodriveHyperSpeed:hover {
      background: rgba(0, 245, 255, 0.1);
      color: #00ffff;
      border-color: #00ffff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      transform: scale(1.02);
      text-shadow: 0 0 15px #00ffff;
    }
    #autodriveStop {
      background: transparent;
      border: 1px solid #ff6b35;
      color: #ff6b35;
      font-family: 'Share Tech Mono', monospace;
      font-size: 12px;
      padding: 8px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #ff6b35;
      box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
      transition: all 0.3s ease;
      border-radius: 4px;
      text-transform: uppercase;
      width: 100%;
      margin-top: 5px;
    }
    #autodriveStop:hover {
      background: rgba(255, 107, 53, 0.1);
      color: #ff0040;
      border-color: #ff0040;
      box-shadow: 0 0 15px rgba(255, 0, 64, 0.8);
      transform: scale(1.02);
      text-shadow: 0 0 10px #ff0040;
    }
    @keyframes buttonGlitch {
      0%, 100% { transform: translateX(0); }
      10% { transform: translateX(-2px) translateY(1px); }
      20% { transform: translateX(2px) translateY(-1px); }
      30% { transform: translateX(-1px) translateY(2px); }
      40% { transform: translateX(1px) translateY(-2px); }
      50% { transform: translateX(-2px); }
      60% { transform: translateX(2px); }
      70% { transform: translateX(-1px); }
      80% { transform: translateX(1px); }
    }
    canvas.glitching {
      animation: boardGlitch 0.5s ease;
    }
    @keyframes boardGlitch {
      0%, 100% { 
        transform: translateX(0) translateY(0);
        filter: hue-rotate(0deg);
      }
      5% { 
        transform: translateX(-3px) translateY(2px);
        filter: hue-rotate(90deg);
      }
      10% { 
        transform: translateX(3px) translateY(-2px);
        filter: hue-rotate(-90deg);
      }
      15% { 
        transform: translateX(-2px) translateY(3px);
        filter: hue-rotate(180deg);
      }
      20% { 
        transform: translateX(2px) translateY(-3px);
        filter: hue-rotate(-180deg);
      }
      25% { 
        transform: translateX(-4px) translateY(1px);
        filter: hue-rotate(45deg);
      }
      30% { 
        transform: translateX(4px) translateY(-1px);
        filter: hue-rotate(-45deg);
      }
      35% { 
        transform: translateX(-1px) translateY(4px);
        filter: hue-rotate(135deg);
      }
      40% { 
        transform: translateX(1px) translateY(-4px);
        filter: hue-rotate(-135deg);
      }
      45% { 
        transform: translateX(-3px);
        filter: hue-rotate(90deg);
      }
      50% { 
        transform: translateX(3px);
        filter: hue-rotate(-90deg);
      }
      55% { 
        transform: translateX(-2px);
        filter: hue-rotate(0deg);
      }
      60% { 
        transform: translateX(2px);
        filter: hue-rotate(0deg);
      }
      65%, 100% { 
        transform: translateX(0) translateY(0);
        filter: hue-rotate(0deg);
      }
    }
    .score-display {
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      pointer-events: none;
      flex: 1;
    }
    .score-display strong {
      font-size: 32px;
      color: #00f5ff;
      text-shadow: 0 0 10px #00f5ff, 0 0 20px rgba(0, 245, 255, 0.5);
      font-family: 'Share Tech Mono', monospace;
    }
    .high-score-system {
      position: fixed;
      bottom: 40px;
      right: 80px;
      z-index: 100;
      font-family: 'Share Tech Mono', monospace;
      font-size: 16px;
      color: rgba(150, 150, 150, 0.6);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .high-score-system::before {
      content: '[SYS] ';
      color: rgba(0, 245, 255, 0.5);
    }
    .high-score-system strong {
      color: rgba(0, 245, 255, 0.7);
      font-weight: normal;
    }
    canvas {
      background: rgba(10, 10, 30, 0.3);
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.5), 0 0 40px rgba(255, 0, 255, 0.3), inset 0 0 12px rgba(0, 245, 255, 0.3);
      border: 2px solid rgba(0, 245, 255, 0.75);
      border-radius: 12px;
      image-rendering: pixelated;
      display: block;
      position: relative;
      z-index: 10;
    }
    #game-container {
      position: relative;
      display: inline-block;
    }
    .top-game-controls {
      position: absolute;
      top: -60px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
      width: 100%;
    }
    .top-game-controls-left {
      display: flex;
      align-items: center;
      gap: 0;
      flex: 0 0 auto;
      min-width: 44px;
    }
    .top-game-controls-right {
      display: flex;
      align-items: center;
      gap: 0;
      flex: 0 0 auto;
      min-width: 44px;
      justify-content: flex-end;
    }
    #gameOver {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(5, 0, 17, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }
    #gameOver.show {
      display: flex;
    }
    .game-over-content {
      text-align: center;
    }
    .flatlined-text {
      font-size: 72px;
      font-weight: bold;
      color: #ff0040;
      text-shadow: 
        0 0 4px rgba(255, 0, 64, 0.8),
        0 0 10px rgba(255, 0, 64, 0.48),
        0 0 18px rgba(255, 0, 64, 0.32),
        0 0 28px rgba(255, 0, 64, 0.24),
        0 0 40px rgba(255, 0, 64, 0.16);
      margin-bottom: 20px;
      letter-spacing: 8px;
      filter: brightness(1.1);
    }
    .game-over-subtitle {
      font-size: 24px;
      color: #ff0040;
      text-shadow: 0 0 10px #ff0040;
      margin-bottom: 30px;
    }
    .final-score {
      font-size: 42px;
      color: #00f5ff;
      text-shadow: 0 0 15px #00f5ff;
      margin-bottom: 40px;
    }
    .final-score span {
      display: block;
      font-size: 36px;
      color: #00f5ff;
      margin-top: 10px;
    }
    #restartGame {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      padding: 15px 40px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 15px #00f5ff;
      transition: all 0.3s ease;
      border-radius: 6px;
    }
    #restartGame:hover {
      background: rgba(0, 245, 255, 0.1);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 25px #ffeb3b;
      transform: scale(1.1);
      text-shadow: 0 0 15px #ffeb3b;
    }
    #startGame {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 24px;
      padding: 18px 50px;
      cursor: pointer;
      text-shadow: 0 0 10px #00f5ff;
      box-shadow: 0 0 20px #00f5ff;
      transition: all 0.3s ease;
      border-radius: 6px;
      text-transform: uppercase;
      letter-spacing: 2px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 200;
      display: none;
    }
    #startGame.show {
      display: block;
    }
    #startGame:hover {
      background: rgba(0, 245, 255, 0.15);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 30px #ffeb3b;
      transform: translate(-50%, -50%) scale(1.05);
      text-shadow: 0 0 20px #ffeb3b;
    }
    #startGame:active {
      transform: translate(-50%, -50%) scale(0.98);
    }
    #helpModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }
    #helpModal.show {
      display: flex;
    }
    #confirmModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }
    #confirmModal.show {
      display: flex;
    }
    .confirm-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 20px;
    }
    .confirm-btn {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 16px;
      padding: 12px 30px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
      transition: all 0.3s ease;
      border-radius: 6px;
      text-transform: uppercase;
    }
    .confirm-btn:hover {
      background: rgba(0, 245, 255, 0.1);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 25px rgba(255, 235, 59, 0.8);
      transform: scale(1.05);
      text-shadow: 0 0 15px #ffeb3b;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .help-content {
      background: linear-gradient(135deg, rgba(10, 10, 30, 0.95) 0%, rgba(15, 5, 25, 0.95) 100%);
      border: 2px solid #00f5ff;
      border-radius: 8px;
      padding: 40px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(0, 245, 255, 0.5), inset 0 0 20px rgba(0, 245, 255, 0.1);
      position: relative;
      animation: slideIn 0.3s ease;
    }
    @keyframes slideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .help-content h2 {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      margin: 0 0 20px 0;
      text-shadow: 0 0 10px #00f5ff;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .help-content h3 {
      color: #ffeb3b;
      font-family: 'Share Tech Mono', monospace;
      font-size: 18px;
      margin: 25px 0 10px 0;
      text-shadow: 0 0 8px rgba(255, 235, 59, 0.5);
    }
    .help-content p {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      line-height: 1.8;
      margin: 10px 0;
      text-shadow: 0 0 4px rgba(0, 245, 255, 0.3);
    }
    .help-content ul {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      line-height: 2;
      margin: 10px 0;
      padding-left: 25px;
      text-shadow: 0 0 4px rgba(0, 245, 255, 0.3);
    }
    .help-content li {
      margin: 8px 0;
    }
    .help-content .key {
      display: inline-block;
      background: rgba(0, 245, 255, 0.2);
      border: 1px solid #00f5ff;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: bold;
      color: #ffeb3b;
      text-shadow: 0 0 6px rgba(255, 235, 59, 0.8);
      margin: 0 2px;
    }
    #closeHelp {
      position: absolute;
      top: 15px;
      right: 15px;
      background: transparent;
      border: 1px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      width: 35px;
      height: 35px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
      transition: all 0.2s ease;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #closeHelp:hover {
      background: rgba(0, 245, 255, 0.1);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 15px rgba(255, 0, 64, 0.5);
      text-shadow: 0 0 10px #ff0040;
    }
    .direction-controls {
      position: fixed;
      bottom: 40px;
      left: 80px;
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      gap: 5px;
      z-index: 100;
    }
    .direction-btn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      border: 1px solid #00f5ff;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      outline: none;
    }
    .direction-btn:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    .direction-btn:active {
      background: rgba(0, 245, 255, 0.2);
      transform: scale(0.95);
    }
    .direction-btn.empty {
      background: transparent;
      border: none;
      cursor: default;
      box-shadow: none;
    }
    .direction-btn.empty:hover {
      background: transparent;
      box-shadow: none;
    }
    .direction-btn .material-icons {
      font-family: 'Material Icons';
      font-size: 24px;
      color: inherit;
      line-height: 1;
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body {
        overflow-y: auto;
        padding: 10px;
        min-height: 100vh;
        height: auto;
      }

      .game-title {
        top: 15px;
        left: 15px;
        position: fixed;
        max-width: calc(50% - 20px);
      }

      .game-title-main {
        font-size: 18px;
      }

      .game-title-sub {
        font-size: 14px;
        letter-spacing: 2px;
      }

      .top-game-controls {
        top: -50px;
      }

      #menuToggle {
        font-size: 24px;
        width: 36px;
        height: 36px;
      }

      #pauseBtnTop {
        font-size: 24px;
        width: 36px;
        height: 36px;
      }

      #pauseBtnTop .material-icons {
        font-size: 24px;
      }

      #autodriveBtn {
        font-size: 11px;
        padding: 8px 12px;
        min-height: 40px;
      }

      #autodriveBtn .material-icons {
        font-size: 16px;
      }

      #autodrivePanel {
        top: 10px;
        right: 10px;
        min-width: 200px;
        padding: 10px 12px;
      }

      .autodrive-panel-header h3 {
        font-size: 12px;
      }

      .autodrive-controls label {
        font-size: 11px;
      }

      .autodrive-speed-value {
        font-size: 12px;
      }

      #autodriveHyperSpeed {
        font-size: 10px;
        padding: 5px 12px;
      }

      #autodriveStop {
        font-size: 11px;
        padding: 6px 15px;
      }

      #soundBtn {
        font-size: 11px;
        padding: 8px 12px;
        min-height: 40px;
      }

      #soundBtn .material-icons {
        font-size: 16px;
      }

      .menu-dropdown {
        bottom: 42px;
        min-width: 140px;
      }

      .menu-dropdown button {
        font-size: 11px;
        padding: 6px 12px;
        white-space: nowrap;
      }

      .top-right-controls {
        top: 15px;
        right: 15px;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
        flex-direction: row;
        align-items: flex-start;
        max-width: calc(50% - 20px);
      }

      #restart {
        font-size: 11px;
        padding: 8px 12px;
        min-height: 40px;
        touch-action: manipulation;
        flex: 0 0 auto;
        min-width: 75px;
        white-space: nowrap;
      }

      #game-container {
        margin-top: 80px;
        margin-bottom: 20px;
      }

      canvas {
        width: 100% !important;
        max-width: 100vw;
        height: auto !important;
        max-height: calc(100vh - 300px);
        aspect-ratio: 1;
      }

      .score-display strong {
        font-size: 24px;
      }

      .high-score-system {
        bottom: 15px;
        right: 15px;
        font-size: 12px;
        position: fixed;
      }

      .code-stream, .text-artifacts {
        display: none;
      }

      .help-content {
        padding: 25px;
        max-width: 95%;
        max-height: 90vh;
      }

      .help-content h2 {
        font-size: 22px;
      }

      .help-content h3 {
        font-size: 16px;
      }

      .help-content p, .help-content li {
        font-size: 12px;
      }

      .game-over-content {
        padding: 20px;
      }

      .flatlined-text {
        font-size: 48px;
        text-shadow: 
          0 0 3px rgba(255, 0, 64, 0.8),
          0 0 7px rgba(255, 0, 64, 0.48),
          0 0 12px rgba(255, 0, 64, 0.32),
          0 0 20px rgba(255, 0, 64, 0.24),
          0 0 28px rgba(255, 0, 64, 0.16);
      }

      .game-over-subtitle {
        font-size: 18px;
      }

      #restartGame {
        font-size: 16px;
        padding: 12px 30px;
        min-height: 44px;
      }

      .direction-controls {
        bottom: 15px;
        left: 15px;
        grid-template-columns: repeat(3, 45px);
        grid-template-rows: repeat(3, 45px);
        gap: 4px;
      }

      .direction-btn {
        font-size: 18px;
      }

      .direction-btn .material-icons {
        font-size: 20px;
      }
    }

    @media (max-width: 480px) {
      .top-game-controls {
        top: -45px;
      }

      .game-title-main {
        font-size: 16px;
      }

      .game-title-sub {
        font-size: 12px;
      }

      .game-title {
        max-width: calc(45% - 15px);
      }

      .top-right-controls {
        gap: 6px;
        top: 10px;
        right: 10px;
        max-width: calc(55% - 15px);
      }

      #autodrivePanel {
        top: 8px;
        right: 8px;
        min-width: 180px;
        padding: 8px 10px;
      }

      .autodrive-panel-header h3 {
        font-size: 11px;
      }

      .autodrive-controls label {
        font-size: 10px;
      }

      .autodrive-speed-value {
        font-size: 11px;
      }

      #autodriveHyperSpeed {
        font-size: 9px;
        padding: 4px 10px;
      }

      #autodriveStop {
        font-size: 10px;
        padding: 5px 12px;
      }

      #restart {
        font-size: 10px;
        padding: 6px 10px;
        min-width: 65px;
        min-height: 38px;
      }

      #autodriveBtn {
        font-size: 10px;
        padding: 6px 10px;
        min-height: 38px;
      }

      #autodriveBtn .material-icons {
        font-size: 14px;
      }

      .score-display strong {
        font-size: 20px;
      }

      #menuToggle {
        font-size: 20px;
        width: 32px;
        height: 32px;
      }

      #pauseBtnTop {
        font-size: 20px;
        width: 32px;
        height: 32px;
      }

      #pauseBtnTop .material-icons {
        font-size: 20px;
      }

      #soundBtn {
        font-size: 10px;
        padding: 6px 10px;
        min-height: 38px;
      }

      #soundBtn .material-icons {
        font-size: 14px;
      }

      .high-score-system {
        font-size: 11px;
      }

      .help-content {
        padding: 20px;
      }

      .direction-controls {
        bottom: 10px;
        left: 10px;
        grid-template-columns: repeat(3, 40px);
        grid-template-rows: repeat(3, 40px);
        gap: 3px;
      }

      .direction-btn {
        font-size: 16px;
      }

      .direction-btn .material-icons {
        font-size: 18px;
      }

      #startGame {
        font-size: 18px;
        padding: 14px 35px;
      }
    }

    /* Prevent text selection on buttons for better mobile UX */
    button {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      user-select: none;
      -webkit-user-select: none;
    }

    /* Prevent pull-to-refresh on mobile */
    body {
      overscroll-behavior-y: contain;
    }

    canvas {
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="game-title">
    <div class="game-title-main">Cyberpunk</div>
    <div class="game-title-sub">SNAKE</div>
  </div>
  <div class="code-stream"></div>
  <div class="text-artifacts"></div>
  <div class="geometric-lines"></div>
  <div class="top-right-controls">
    <button id="restart" title="Restart">REBOOT<span class="material-icons">power_settings_new</span></button>
    <button id="autodriveBtn" title="Autodrive Mode"><span class="material-icons">settings</span>AUTODRIVE</button>
    <button id="soundBtn" title="Toggle Sound"><span class="material-icons">volume_up</span></button>
  </div>
  <div id="game-container">
    <div class="top-game-controls">
      <div class="top-game-controls-left">
        <div class="title-menu">
          <button id="menuToggle" title="Menu">☰</button>
          <div class="menu-dropdown" id="menuDropdown">
            <button id="clearHighScoreBtn" title="Clear High Score"><span class="material-icons">do_not_disturb</span> CLEAR HIGH SCORE</button>
            <button id="helpBtn" title="How to Play"><span class="material-icons">help</span> HELP</button>
          </div>
        </div>
      </div>
      <div class="score-display">
        <strong id="score">0</strong>
      </div>
      <div class="top-game-controls-right">
        <button id="pauseBtnTop" title="Pause/Resume"><span class="material-icons">pause</span></button>
      </div>
    </div>
    <canvas id="game"></canvas>
    <button id="startGame">START GAME</button>
  </div>
  <div id="helpModal">
    <div class="help-content">
      <button id="closeHelp" title="Close">×</button>
      <h2>HOW TO PLAY</h2>
      
      <h3>Objective</h3>
      <p>Control the snake to eat food and grow longer. Avoid hitting the walls or your own tail!</p>
      
      <h3>Controls</h3>
      <ul>
        <li><span class="key">↑</span> <span class="key">↓</span> <span class="key">←</span> <span class="key">→</span> Arrow keys to change direction</li>
        <li><span class="key">Swipe</span> on mobile devices</li>
        <li><span class="key">Direction Buttons</span> on mobile</li>
      </ul>
      
      <h3>Gameplay</h3>
      <ul>
        <li>The snake moves continuously in the current direction</li>
        <li>Eat the glowing food to grow and increase your score</li>
        <li>Each food item increases your score by 10 points</li>
        <li>The snake wraps around walls (goes through to the opposite side)</li>
        <li>The game ends only if you hit your own body</li>
        <li>The snake moves faster as your score increases</li>
      </ul>
      
      <h3>Tips</h3>
      <ul>
        <li>Plan your path to avoid trapping yourself</li>
        <li>Use wall wrapping to escape tight situations</li>
        <li>Keep moving - the snake never stops!</li>
      </ul>
    </div>
  </div>
  <div id="autodrivePanel">
    <div class="autodrive-panel-header">
      <h3>AUTODRIVE MODE</h3>
      <div class="autodrive-indicator"></div>
    </div>
    <div class="autodrive-controls">
      <label>SPEED:</label>
      <div class="autodrive-speed-container">
        <input type="range" id="autodriveSpeed" class="autodrive-speed-slider" min="0.5" max="100" step="0.5" value="1">
        <span id="autodriveSpeedValue" class="autodrive-speed-value">1x</span>
      </div>
      <button id="autodriveHyperSpeed">HYPER SPEED</button>
    </div>
    <button id="autodriveStop">STOP</button>
  </div>
  <div id="confirmModal">
    <div class="help-content">
      <h2>CONFIRM</h2>
      <p>Are you sure you want to clear your high score?</p>
      <div class="confirm-buttons">
        <button id="confirmYes" class="confirm-btn">YES</button>
        <button id="confirmNo" class="confirm-btn">NO - ONE MORE GIG</button>
      </div>
    </div>
  </div>
  <div class="high-score-system">
    HIGH SCORE: <strong id="highscore">0</strong>
  </div>
  <div class="direction-controls">
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnUp" title="Up"><span class="material-icons">arrow_upward</span></button>
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnLeft" title="Left"><span class="material-icons">arrow_back</span></button>
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnRight" title="Right"><span class="material-icons">arrow_forward</span></button>
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnDown" title="Down"><span class="material-icons">arrow_downward</span></button>
    <div class="direction-btn empty"></div>
  </div>
  <div id="gameOver">
    <div class="game-over-content">
      <div class="flatlined-text">FLATLINED</div>
      <div class="game-over-subtitle">SYSTEM FAILURE DETECTED</div>
      <div class="final-score">
        Final Score: <span id="finalScore">0</span>
      </div>
      <button id="restartGame">REBOOT SYSTEM</button>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highscoreEl = document.getElementById('highscore');
    const restartBtn = document.getElementById('restart');
    const gameOverEl = document.getElementById('gameOver');
    const finalScoreEl = document.getElementById('finalScore');
    const restartGameBtn = document.getElementById('restartGame');
    const startGameBtn = document.getElementById('startGame');

    // Game constants
    const GRID_SIZE = 20;
    const CELL_SIZE = 20;
    const INITIAL_SPEED = 150; // milliseconds per move (constant speed)

    // Game state
    let snake = [{ x: 0, y: 0 }]; // Start at top left
    let direction = { x: 1, y: 0 };
    let nextDirection = { x: 1, y: 0 };
    let directionQueue = []; // Queue to capture rapid key presses
    let food = [{ x: 4, y: 0 }]; // Array of food items - initial food at cell 4 in top row for immediate catch
    let score = 10; // Snake starts with 1 segment = 10 points
    let highscore = parseInt(localStorage.getItem('snakeHighscore') || '0', 10) || 0;
    let gameRunning = false;
    let gameOver = false;
    let gamePaused = false;
    let gameLoop = null;
    let currentSpeed = INITIAL_SPEED;
    let lastMoveTime = 0;
    let animationFrameId = null;
    let hyperSpeedLoopId = null;
    let autodriveActive = false;
    let autodriveSpeed = 1.0;

    // Responsive canvas sizing
    function getCanvasSize() {
      const maxSize = 500;
      const isMobile = window.innerWidth <= 768;
      if (isMobile) {
        const viewportWidth = window.innerWidth - 40;
        const viewportHeight = window.innerHeight - 300;
        return Math.min(viewportWidth, viewportHeight, maxSize);
      }
      return maxSize;
    }

    let logicalSize = getCanvasSize();
    const scale = window.devicePixelRatio || 1;
    let cellSize = Math.floor(logicalSize / GRID_SIZE);
    let gridSize = GRID_SIZE;

    function resizeCanvas() {
      logicalSize = getCanvasSize();
      if (logicalSize < 200) logicalSize = 200;
      
      cellSize = Math.floor(logicalSize / GRID_SIZE);
      const actualSize = cellSize * GRID_SIZE;
      
      canvas.width = actualSize * scale;
      canvas.height = actualSize * scale;
      canvas.style.width = actualSize + 'px';
      canvas.style.height = actualSize + 'px';
      ctx.setTransform(scale, 0, 0, scale, 0, 0);
      
      if (gameRunning || gameOver) {
        draw();
      }
    }

    resizeCanvas();
    window.addEventListener('resize', () => {
      setTimeout(resizeCanvas, 150);
    });
    window.addEventListener('orientationchange', () => {
      setTimeout(resizeCanvas, 100);
    });

    // Sound Manager
    const SoundManager = {
      audioContext: null,
      enabled: true,
      hasUserInteracted: false,
      
      init() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const soundPref = localStorage.getItem('soundEnabled');
          this.enabled = soundPref === null ? true : soundPref === 'true';
          this.updateButton();
        } catch (e) {
          console.warn('Web Audio API not supported:', e);
          this.enabled = false;
        }
      },
      
      updateButton() {
        const soundBtn = document.getElementById('soundBtn');
        if (soundBtn) {
          const icon = soundBtn.querySelector('.material-icons');
          if (icon) {
            if (this.enabled) {
              soundBtn.classList.remove('muted');
              icon.textContent = 'volume_up';
            } else {
              soundBtn.classList.add('muted');
              icon.textContent = 'volume_off';
            }
          }
        }
      },
      
      async ensureResumed() {
        if (!this.audioContext) return;
        if (this.audioContext.state === 'suspended') {
          if (!this.hasUserInteracted) return;
          try {
            await this.audioContext.resume();
          } catch (e) {}
        }
      },
      
      toggle() {
        this.enabled = !this.enabled;
        localStorage.setItem('soundEnabled', this.enabled.toString());
        this.updateButton();
        if (this.enabled) {
          this.playDirectionChange();
        }
      },
      
      activeOscillators: [],
      
      playTone(frequency, duration, type = 'sine', volume = 0.3) {
        if (!this.enabled || !this.audioContext) return;
        if (this.audioContext.state === 'suspended' && !this.hasUserInteracted) return;
        
        // Ensure audio context is resumed (non-blocking)
        this.ensureResumed().catch(() => {});
        
        // Play immediately - Web Audio API is already non-blocking
        try {
          if (this.audioContext.state === 'suspended') return;
          
          const now = this.audioContext.currentTime;
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);
          
          oscillator.type = type;
          oscillator.frequency.value = frequency;
          
          // Very quick envelope for immediate response
          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(volume, now + 0.002);
          gainNode.gain.linearRampToValueAtTime(0, now + duration);
          
          oscillator.start(now);
          oscillator.stop(now + duration);
          
          // Track active oscillators for potential cleanup
          this.activeOscillators.push(oscillator);
          oscillator.onended = () => {
            const index = this.activeOscillators.indexOf(oscillator);
            if (index > -1) {
              this.activeOscillators.splice(index, 1);
            }
          };
        } catch (e) {
          // Silently fail
        }
      },
      
      playDirectionChange() {
        // Super short basic cyber beep when switching direction
        this.playTone(400, 0.015, 'square', 0.12);
      },
      
      playEat() {
        // Non-blocking sound
        this.ensureResumed().catch(() => {});
        this.playTone(400, 0.1, 'sine', 0.25);
        setTimeout(() => {
          this.playTone(600, 0.08, 'sine', 0.2);
        }, 30);
      },
      
      playGameOver() {
        // Non-blocking sound
        this.ensureResumed().catch(() => {});
        const frequencies = [300, 250, 200, 150];
        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            this.playTone(freq, 0.2, 'sine', 0.3);
          }, index * 100);
        });
      },
      
      playGlitch() {
        // Non-blocking sound
        this.ensureResumed().catch(() => {});
        const frequencies = [200, 150, 250, 180];
        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            this.playTone(freq, 0.08, 'square', 0.15);
          }, index * 30);
        });
      },
      
      playVictory() {
        // Celebration sound - ascending tones
        this.ensureResumed().catch(() => {});
        const frequencies = [400, 500, 600, 700, 800, 900, 1000];
        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            this.playTone(freq, 0.15, 'sine', 0.3);
          }, index * 80);
        });
        // Add a final triumphant chord
        setTimeout(() => {
          this.playTone(600, 0.3, 'sine', 0.4);
          setTimeout(() => {
            this.playTone(800, 0.3, 'sine', 0.4);
            setTimeout(() => {
              this.playTone(1000, 0.3, 'sine', 0.4);
            }, 50);
          }, 50);
        }, frequencies.length * 80);
      }
    };
    
    SoundManager.init();

    // Resume audio context on first user interaction
    let audioContextResumed = false;
    function resumeAudioOnInteraction() {
      if (!audioContextResumed && SoundManager.audioContext) {
        audioContextResumed = true;
        SoundManager.hasUserInteracted = true;
        SoundManager.ensureResumed().catch(() => {});
      }
    }
    
    document.addEventListener('touchstart', resumeAudioOnInteraction, { once: true, passive: true, capture: true });
    document.addEventListener('click', resumeAudioOnInteraction, { once: true, capture: true });
    document.addEventListener('keydown', resumeAudioOnInteraction, { once: true, capture: true });
    window.addEventListener('touchstart', resumeAudioOnInteraction, { once: true, passive: true, capture: true });
    window.addEventListener('click', resumeAudioOnInteraction, { once: true, capture: true });

    function generateFood() {
      let newFood;
      do {
        newFood = {
          x: Math.floor(Math.random() * GRID_SIZE),
          y: Math.floor(Math.random() * GRID_SIZE)
        };
      } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
               food.some(f => f.x === newFood.x && f.y === newFood.y));
      return newFood;
    }
    
    // Add food items to the board (for autodrive mode)
    function addFood(count) {
      if (!gameRunning || gameOver) return;
      
      for (let i = 0; i < count; i++) {
        // Don't add food if we're at max score
        if (score >= 4000) break;
        const newFood = generateFood();
        food.push(newFood);
      }
      draw();
    }

    function updateScores() {
      // Update highscore first if current score is higher
      if (score > highscore) {
        highscore = score;
        try {
          localStorage.setItem('snakeHighscore', String(highscore));
        } catch (e) {}
      }
      
      // Then update the display with the current values
      if (scoreEl) scoreEl.textContent = score;
      if (highscoreEl) highscoreEl.textContent = highscore;
    }

    function draw() {
      // Clear canvas completely to remove any ghosting
      ctx.clearRect(0, 0, canvas.width / scale, canvas.height / scale);
      
      // Reset all shadow properties
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      
      // Draw background
      ctx.fillStyle = 'rgba(10, 10, 30, 0.3)';
      ctx.fillRect(0, 0, canvas.width / scale, canvas.height / scale);

      // Draw grid (subtle)
      ctx.strokeStyle = 'rgba(0, 245, 255, 0.1)';
      ctx.lineWidth = 0.5;
      for (let i = 0; i <= GRID_SIZE; i++) {
        const pos = i * cellSize;
        ctx.beginPath();
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, GRID_SIZE * cellSize);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, pos);
        ctx.lineTo(GRID_SIZE * cellSize, pos);
        ctx.stroke();
      }

      // Draw all food items with glow
      if (!Array.isArray(food)) {
        // Safety check: ensure food is an array
        food = [{ x: 4, y: 0 }];
      }
      for (const foodItem of food) {
        const foodX = foodItem.x * cellSize;
        const foodY = foodItem.y * cellSize;
        
        // Outer glow
        const foodGradient = ctx.createRadialGradient(
          foodX + cellSize / 2, foodY + cellSize / 2, 0,
          foodX + cellSize / 2, foodY + cellSize / 2, cellSize / 2
        );
        foodGradient.addColorStop(0, 'rgba(255, 235, 59, 0.8)');
        foodGradient.addColorStop(0.5, 'rgba(255, 235, 59, 0.4)');
        foodGradient.addColorStop(1, 'rgba(255, 235, 59, 0)');
        ctx.fillStyle = foodGradient;
        ctx.fillRect(foodX, foodY, cellSize, cellSize);
        
        // Food square
        ctx.fillStyle = '#ffeb3b';
        ctx.shadowColor = '#ffeb3b';
        ctx.shadowBlur = 10;
        ctx.fillRect(foodX + 2, foodY + 2, cellSize - 4, cellSize - 4);
      }
      // Reset shadow after food
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;

      // Draw snake with continuous gradient
      const snakeLength = snake.length;
      if (snakeLength === 0) return;
      
      // Define color stops for smooth gradient from head to tail
      const headColor = { r: 0, g: 245, b: 255 }; // #00f5ff
      const midColor = { r: 0, g: 170, b: 200 };  // #00aacc
      const tailColor = { r: 100, g: 50, b: 200 }; // Purple for visibility
      
      snake.forEach((segment, index) => {
        const x = segment.x * cellSize;
        const y = segment.y * cellSize;
        
        // Calculate position ratio (0 = head, 1 = tail)
        const ratio = index / (snakeLength - 1);
        
        // Interpolate color smoothly from head to tail
        let r, g, b;
        if (ratio < 0.5) {
          // First half: head to mid
          const t = ratio * 2; // 0 to 1
          r = Math.round(headColor.r + (midColor.r - headColor.r) * t);
          g = Math.round(headColor.g + (midColor.g - headColor.g) * t);
          b = Math.round(headColor.b + (midColor.b - headColor.b) * t);
        } else {
          // Second half: mid to tail
          const t = (ratio - 0.5) * 2; // 0 to 1
          r = Math.round(midColor.r + (tailColor.r - midColor.r) * t);
          g = Math.round(midColor.g + (tailColor.g - midColor.g) * t);
          b = Math.round(midColor.b + (tailColor.b - midColor.b) * t);
        }
        
        // Make tail segment(s) brighter and more visible
        const isTail = index === snakeLength - 1;
        const isNearTail = index >= snakeLength - 2;
        
        if (isTail) {
          // Tail: bright purple/cyan for maximum visibility
          r = 150;
          g = 100;
          b = 255;
        } else if (isNearTail) {
          // Near tail: slightly brighter
          r = Math.min(255, r + 30);
          g = Math.min(255, g + 20);
          b = Math.min(255, b + 30);
        }
        
        const color = `rgb(${r}, ${g}, ${b})`;
        ctx.fillStyle = color;
        
        // Shadow/glow effect - only for head and tail, reduced for body to prevent ghosting
        if (index === 0) {
          ctx.shadowColor = '#00f5ff';
          ctx.shadowBlur = 10;
        } else if (isTail) {
          ctx.shadowColor = `rgb(${r}, ${g}, ${b})`;
          ctx.shadowBlur = 8; // Reduced to prevent ghosting
        } else {
          // Body segments: minimal or no shadow to prevent ghosting
          ctx.shadowColor = 'transparent';
          ctx.shadowBlur = 0;
        }
        
        ctx.fillRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
        
        // Reset shadow before border to prevent bleeding
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        
        // Border - stronger on head and tail
        const borderAlpha = index === 0 ? 0.9 : (isTail ? 0.8 : 0.5);
        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${borderAlpha})`;
        ctx.lineWidth = index === 0 || isTail ? 1.5 : 1;
        ctx.strokeRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
      });
      
      // Ensure all shadow properties are reset after drawing snake
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
    }

    function moveSnake() {
      if (!gameRunning || gameOver || gamePaused) return;

      // Process direction queue - use the first queued direction if available
      // This ensures rapid key presses are all processed in order
      if (directionQueue.length > 0) {
        nextDirection = directionQueue.shift();
      }
      
      // Update direction from nextDirection
      direction = { ...nextDirection };

      // Calculate new head position
      const head = { ...snake[0] };
      head.x += direction.x;
      head.y += direction.y;

      // Wrap around walls
      if (head.x < 0) {
        head.x = GRID_SIZE - 1;
      } else if (head.x >= GRID_SIZE) {
        head.x = 0;
      }
      if (head.y < 0) {
        head.y = GRID_SIZE - 1;
      } else if (head.y >= GRID_SIZE) {
        head.y = 0;
      }

      // Check self collision
      if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        endGame();
        return;
      }

      snake.unshift(head);

      // Check food collision with all food items
      let ateFood = false;
      for (let i = food.length - 1; i >= 0; i--) {
        if (head.x === food[i].x && head.y === food[i].y) {
          // Remove this food item
          food.splice(i, 1);
          score += 10;
          updateScores();
          SoundManager.playEat();
          ateFood = true;
          
          // Check for victory (max score: 4000 = 400 cells * 10 points)
          if (score >= 4000) {
            victory();
            return;
          }
          
          // Generate new food if array is empty (but only if not at max score)
          if (food.length === 0 && score < 4000) {
            food.push(generateFood());
          }
          break;
        }
      }
      
      if (!ateFood) {
        snake.pop();
      }

      // Don't draw here - let the render loop handle it
    }

    // Smooth game loop using requestAnimationFrame
    function animationLoop(timestamp) {
      // Always render for smooth animations (even when paused or game over)
      if (gameRunning || gameOver) {
        draw();
      }

      // Update game logic based on speed (only when running and not paused)
      if (gameRunning && !gameOver && !gamePaused) {
        if (lastMoveTime === 0) {
          lastMoveTime = timestamp;
        }
        
        // Apply autodrive speed multiplier
        const effectiveSpeed = autodriveActive ? currentSpeed / autodriveSpeed : currentSpeed;
        
        const elapsed = timestamp - lastMoveTime;
        if (elapsed >= effectiveSpeed) {
          // Autodrive AI: calculate direction before moving
          if (autodriveActive) {
            const aiDirection = findPathToFood();
            if (aiDirection) {
              // Clear queue and set AI direction
              directionQueue = [];
              nextDirection = aiDirection;
            }
          }
          
          moveSnake();
          lastMoveTime = timestamp;
        }
      }

      // Continue the loop only if game is running or just ended
      if (gameRunning || gameOver) {
        animationFrameId = requestAnimationFrame(animationLoop);
      } else {
        animationFrameId = null;
      }
    }

    function startGame() {
      if (gameRunning) return;
      
      snake = [{ x: 0, y: 0 }]; // Start at top left
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      directionQueue = []; // Clear direction queue on restart
      // Don't regenerate food here - it should already be set at initialization
      // Food will only be regenerated when the snake eats it
      score = 10; // Snake starts with 1 segment = 10 points
      gameOver = false;
      gamePaused = false;
      gameRunning = true;
      currentSpeed = INITIAL_SPEED;
      lastMoveTime = 0;
      autodriveActive = false; // Reset autodrive on new game
      
      updateScores();
      hideGameOver();
      hideStartButton();
      updatePauseButton();
      if (autodriveBtn) autodriveBtn.classList.remove('active');
      if (autodrivePanel) autodrivePanel.classList.remove('show');
      draw();
      
      // Stop any existing loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Start smooth animation loop
      animationFrameId = requestAnimationFrame(animationLoop);
    }

    function togglePause() {
      if (!gameRunning || gameOver) return;
      
      gamePaused = !gamePaused;
      updatePauseButton();
      
      if (gamePaused) {
        SoundManager.playGlitch();
        // Keep rendering even when paused for smooth UI
      } else {
        lastMoveTime = performance.now();
      }
    }

    function updatePauseButton() {
      const pauseBtn = document.getElementById('pauseBtnTop');
      if (pauseBtn) {
        const icon = pauseBtn.querySelector('.material-icons');
        if (icon) {
          if (gamePaused) {
            icon.textContent = 'play_arrow';
            pauseBtn.title = 'Resume';
          } else {
            icon.textContent = 'pause';
            pauseBtn.title = 'Pause';
          }
        }
      }
    }

    function endGame() {
      if (!gameRunning) return;
      
      gameRunning = false;
      gameOver = true;
      
      // Stop animation loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Final render
      draw();
      
      // Ensure final score is saved to highscore
      updateScores();
      
      SoundManager.playGameOver();
      showGameOver();
      // Show start button after game over
      showStartButton();
    }
    
    function victory() {
      if (!gameRunning) return;
      
      gameRunning = false;
      gameOver = true;
      
      // Stop animation loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      if (hyperSpeedLoopId) {
        clearTimeout(hyperSpeedLoopId);
        hyperSpeedLoopId = null;
      }
      
      // Ensure score is exactly 4000
      score = 4000;
      updateScores();
      
      // Final render
      draw();
      
      // Play celebration sound
      SoundManager.playVictory();
      
      // Show victory message
      showVictory();
      // Show start button after victory
      showStartButton();
    }

    function showGameOver() {
      finalScoreEl.textContent = score;
      // Reset to normal game over message
      const flatlinedText = gameOverEl.querySelector('.flatlined-text');
      const subtitle = gameOverEl.querySelector('.game-over-subtitle');
      if (flatlinedText) flatlinedText.textContent = 'FLATLINED';
      if (subtitle) subtitle.textContent = 'SYSTEM FAILURE DETECTED';
      gameOverEl.classList.add('show');
    }
    
    function showVictory() {
      finalScoreEl.textContent = score;
      // Change to victory message
      const flatlinedText = gameOverEl.querySelector('.flatlined-text');
      const subtitle = gameOverEl.querySelector('.game-over-subtitle');
      if (flatlinedText) flatlinedText.textContent = 'PERFECT SCORE';
      if (subtitle) subtitle.textContent = 'MAX SCORE OF 4000 ACHIEVED';
      gameOverEl.classList.add('show');
    }

    function hideGameOver() {
      gameOverEl.classList.remove('show');
    }

    function showStartButton() {
      if (startGameBtn) {
        startGameBtn.classList.add('show');
      }
    }

    function hideStartButton() {
      if (startGameBtn) {
        startGameBtn.classList.remove('show');
      }
    }

    // Pre-computed Hamiltonian path that visits every cell exactly once
    // Pattern matches spreadsheet: Row 1 A→T, Row 2 T→B, Row 3 B→T, etc., then up column A
    let hamiltonianPath = null;
    
    function generateHamiltonianPath() {
      const path = [];
      
      // Row 1 (y=0): A1 to T1 (x=0 to x=GRID_SIZE-1, going right)
      // This ends at (GRID_SIZE-1, 0) = T1
      for (let x = 0; x < GRID_SIZE; x++) {
        path.push({ x, y: 0 });
      }
      
      // Rows 2 to GRID_SIZE (y=1 to y=GRID_SIZE-1): Zigzag pattern
      // Row 2 (y=1, even 1-indexed): T2 to B2 (x=GRID_SIZE-1 to x=1, going left)
      // Row 3 (y=2, odd 1-indexed): B3 to T3 (x=1 to x=GRID_SIZE-1, going right)
      // Row 4 (y=3, even 1-indexed): T4 to B4 (x=GRID_SIZE-1 to x=1, going left)
      // etc.
      for (let y = 1; y < GRID_SIZE; y++) {
        if (y % 2 === 1) {
          // Even row (1-indexed, y=1,3,5...): go left from T to B
          // Start at T (x=GRID_SIZE-1) - this is adjacent to where we ended in previous row
          for (let x = GRID_SIZE - 1; x >= 1; x--) {
            path.push({ x, y });
          }
          // Ends at B (x=1, y)
        } else {
          // Odd row (1-indexed, y=2,4,6...): go right from B to T
          // Start at B (x=1) - this is adjacent to where we ended in previous row
          for (let x = 1; x < GRID_SIZE; x++) {
            path.push({ x, y });
          }
          // Ends at T (x=GRID_SIZE-1, y)
        }
      }
      
      // After processing all rows, we end at either:
      // - (1, GRID_SIZE-1) if last row was even (1-indexed) - which means y=GRID_SIZE-1 is odd
      // - (GRID_SIZE-1, GRID_SIZE-1) if last row was odd (1-indexed) - which means y=GRID_SIZE-1 is even
      // Check: GRID_SIZE-1 = 19, which is odd, so last row (y=19) is even (1-indexed)
      // So we end at (1, GRID_SIZE-1) = B20
      
      // Go to A20 (x=0, y=GRID_SIZE-1) - this is adjacent to B20
      path.push({ x: 0, y: GRID_SIZE - 1 });
      
      // Go up column A from A20 to A2 (skip A1 since it's already visited)
      // This goes from (0, GRID_SIZE-1) to (0, 1)
      for (let y = GRID_SIZE - 2; y >= 1; y--) {
        path.push({ x: 0, y });
      }
      
      // Verify path is continuous and visits all cells
      const visited = new Set();
      for (let i = 0; i < path.length; i++) {
        const cell = path[i];
        const key = `${cell.x},${cell.y}`;
        if (visited.has(key)) {
          console.error('Duplicate cell in path:', cell, 'at index', i);
        }
        visited.add(key);
        
        // Check continuity (except for last cell)
        if (i < path.length - 1) {
          const next = path[i + 1];
          const dx = Math.abs(cell.x - next.x);
          const dy = Math.abs(cell.y - next.y);
          if (dx + dy !== 1) {
            console.error('Path not continuous at index', i, cell, '->', next);
          }
        }
      }
      
      if (visited.size !== GRID_SIZE * GRID_SIZE) {
        console.warn('Path incomplete:', visited.size, 'expected', GRID_SIZE * GRID_SIZE);
      }
      if (path.length !== GRID_SIZE * GRID_SIZE) {
        console.warn('Path length mismatch:', path.length, 'expected', GRID_SIZE * GRID_SIZE);
      }
      
      return path;
    }
    
    // Get the index of a cell in the Hamiltonian path
    function getPathIndex(x, y) {
      if (!hamiltonianPath) {
        hamiltonianPath = generateHamiltonianPath();
      }
      for (let i = 0; i < hamiltonianPath.length; i++) {
        if (hamiltonianPath[i].x === x && hamiltonianPath[i].y === y) {
          return i;
        }
      }
      return -1;
    }
    
    // Get the next cell in the path from current position
    function getNextInPath(x, y) {
      if (!hamiltonianPath) {
        hamiltonianPath = generateHamiltonianPath();
      }
      const currentIndex = getPathIndex(x, y);
      if (currentIndex === -1 || currentIndex >= hamiltonianPath.length - 1) {
        return null; // At end of path
      }
      return hamiltonianPath[currentIndex + 1];
    }
    
    // AI Pathfinding for Autodrive - Simple Hamiltonian path following
    // Just follows the predefined path, no additional logic needed
    function findPathToFood() {
      const head = snake[0];
      
      // Create a set of snake body positions (excluding tail which will move)
      const snakeBody = new Set();
      for (let i = 0; i < snake.length - 1; i++) {
        snakeBody.add(`${snake[i].x},${snake[i].y}`);
      }
      
      // Get the next cell in the predefined path
      const nextCell = getNextInPath(head.x, head.y);
      
      if (!nextCell) {
        // At the end of the path - game should be complete
        // Fallback: continue in current direction
        const currentDir = snake.length > 1 
          ? { x: snake[0].x - snake[1].x, y: snake[0].y - snake[1].y }
          : { x: 1, y: 0 };
        return currentDir;
      }
      
      // Calculate direction to the next cell
      const dirX = nextCell.x - head.x;
      const dirY = nextCell.y - head.y;
      
      // Verify this is an adjacent cell (distance = 1)
      if (Math.abs(dirX) + Math.abs(dirY) !== 1) {
        console.error('Next cell in path is not adjacent!', head, nextCell);
        const currentDir = snake.length > 1 
          ? { x: snake[0].x - snake[1].x, y: snake[0].y - snake[1].y }
          : { x: 1, y: 0 };
        return currentDir;
      }
      
      // Normalize direction
      const normalizedX = dirX !== 0 ? (dirX > 0 ? 1 : -1) : 0;
      const normalizedY = dirY !== 0 ? (dirY > 0 ? 1 : -1) : 0;
      
      // Check if this move is safe (won't hit body, excluding tail)
      const key = `${nextCell.x},${nextCell.y}`;
      if (!snakeBody.has(key) && nextCell.x >= 0 && nextCell.x < GRID_SIZE && 
          nextCell.y >= 0 && nextCell.y < GRID_SIZE) {
        return { x: normalizedX, y: normalizedY };
      }
      
      // If blocked, something is wrong - but this shouldn't happen with proper path
      console.warn('Next cell in path is blocked:', nextCell);
      
      // Fallback: try current direction
      const currentDir = snake.length > 1 
        ? { x: snake[0].x - snake[1].x, y: snake[0].y - snake[1].y }
        : { x: 1, y: 0 };
      const newX = head.x + currentDir.x;
      const newY = head.y + currentDir.y;
      if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && 
          !snakeBody.has(`${newX},${newY}`)) {
        return currentDir;
      }
      
      return { x: 1, y: 0 }; // Last resort
    }
    
    // BFS to find shortest path between two points
    function bfsPath(start, target, obstacles) {
      const queue = [{ x: start.x, y: start.y, path: [] }];
      const visited = new Set();
      visited.add(`${start.x},${start.y}`);
      
      const directions = [
        { x: 0, y: -1 }, // up
        { x: 1, y: 0 },  // right
        { x: 0, y: 1 },  // down
        { x: -1, y: 0 }  // left
      ];
      
      while (queue.length > 0) {
        const current = queue.shift();
        
        if (current.x === target.x && current.y === target.y) {
          return current.path;
        }
        
        for (const dir of directions) {
          let newX = (current.x + dir.x + GRID_SIZE) % GRID_SIZE;
          let newY = (current.y + dir.y + GRID_SIZE) % GRID_SIZE;
          
          const key = `${newX},${newY}`;
          
          if (!visited.has(key) && !obstacles.has(key)) {
            visited.add(key);
            queue.push({
              x: newX,
              y: newY,
              path: [...current.path, dir]
            });
          }
        }
      }
      
      return null; // No path found
    }
    
    // Find the safest move that maximizes future options
    function findSafeMove(head, snakeBody, target) {
      const directions = [
        { x: 0, y: -1 }, // up
        { x: 1, y: 0 },  // right
        { x: 0, y: 1 },  // down
        { x: -1, y: 0 }  // left
      ];
      
      // Score each possible move
      const moves = [];
      
      for (const dir of directions) {
        let newX = (head.x + dir.x + GRID_SIZE) % GRID_SIZE;
        let newY = (head.y + dir.y + GRID_SIZE) % GRID_SIZE;
        
        const key = `${newX},${newY}`;
        
        // Skip if would hit body
        if (snakeBody.has(key)) {
          continue;
        }
        
        // Calculate score for this move
        let score = 0;
        
        // Check if this move is safe (can reach tail after moving)
        const newSnakeBody = new Set(snakeBody);
        newSnakeBody.delete(`${snake[snake.length - 1].x},${snake[snake.length - 1].y}`); // Remove tail
        newSnakeBody.add(key); // Add new head position
        
        const tail = snake[snake.length - 1];
        const pathToTail = bfsPath({ x: newX, y: newY }, tail, newSnakeBody);
        
        if (pathToTail && pathToTail.length > 0) {
          score += 1000; // Safe move - can reach tail
        } else {
          // Unsafe move, but might be necessary
          score -= 500;
        }
        
        // Prefer moves that get closer to food (with wrapping)
        const dx = Math.min(Math.abs(newX - target.x), GRID_SIZE - Math.abs(newX - target.x));
        const dy = Math.min(Math.abs(newY - target.y), GRID_SIZE - Math.abs(newY - target.y));
        const wrappedDistToFood = dx + dy;
        score += (GRID_SIZE * 2 - wrappedDistToFood) * 10;
        
        // Count how many free spaces are reachable from this position
        const reachable = countReachableSpaces({ x: newX, y: newY }, newSnakeBody);
        score += reachable;
        
        moves.push({ dir, score, newX, newY });
      }
      
      // Sort by score (highest first)
      moves.sort((a, b) => b.score - a.score);
      
      // Return best move, or current direction if no safe moves
      if (moves.length > 0 && moves[0].score > -500) {
        return moves[0].dir;
      }
      
      // Last resort: try to continue in current direction if safe
      const currentDir = direction;
      let newX = (head.x + currentDir.x + GRID_SIZE) % GRID_SIZE;
      let newY = (head.y + currentDir.y + GRID_SIZE) % GRID_SIZE;
      const key = `${newX},${newY}`;
      if (!snakeBody.has(key)) {
        return currentDir;
      }
      
      // Any move is better than crashing
      return moves.length > 0 ? moves[0].dir : currentDir;
    }
    
    // Count how many spaces are reachable from a position (flood fill)
    function countReachableSpaces(start, obstacles) {
      const queue = [start];
      const visited = new Set();
      visited.add(`${start.x},${start.y}`);
      
      const directions = [
        { x: 0, y: -1 }, // up
        { x: 1, y: 0 },  // right
        { x: 0, y: 1 },  // down
        { x: -1, y: 0 }  // left
      ];
      
      let count = 0;
      
      while (queue.length > 0) {
        const current = queue.shift();
        count++;
        
        for (const dir of directions) {
          let newX = (current.x + dir.x + GRID_SIZE) % GRID_SIZE;
          let newY = (current.y + dir.y + GRID_SIZE) % GRID_SIZE;
          
          const key = `${newX},${newY}`;
          
          if (!visited.has(key) && !obstacles.has(key)) {
            visited.add(key);
            queue.push({ x: newX, y: newY });
          }
        }
      }
      
      return count;
    }

    function changeDirection(newDir) {
      // Don't auto-start on direction change - user must press start button
      if (!gameRunning || gameOver || gamePaused) return;
      
      // Don't allow manual direction changes when autodrive is active
      if (autodriveActive) return;
      
      // Determine what direction to check against
      // Use the last queued direction if queue exists, otherwise use nextDirection
      const checkDir = directionQueue.length > 0 
        ? directionQueue[directionQueue.length - 1] 
        : nextDirection;
      
      // Prevent reversing into itself
      if (newDir.x === -checkDir.x && newDir.y === -checkDir.y) {
        return;
      }
      
      // Check if direction is actually changing (not the same as current)
      const isDirectionChanging = newDir.x !== checkDir.x || newDir.y !== checkDir.y;
      
      // Add to queue to capture rapid key presses
      // Remove any duplicate of this direction from queue first
      directionQueue = directionQueue.filter(
        dir => !(dir.x === newDir.x && dir.y === newDir.y)
      );
      directionQueue.push(newDir);
      
      // Update nextDirection if queue was empty (for immediate responsiveness)
      // Otherwise, the queue will be processed in moveSnake
      if (directionQueue.length === 1) {
        nextDirection = newDir;
      }
      
      // Play super short cyber beep when direction actually changes
      if (isDirectionChanging) {
        SoundManager.playDirectionChange();
      }
      
      // Limit queue size to prevent memory issues (keep last 3 directions)
      if (directionQueue.length > 3) {
        directionQueue.shift();
      }
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (SoundManager.audioContext && !SoundManager.hasUserInteracted) {
        SoundManager.hasUserInteracted = true;
        SoundManager.ensureResumed();
      }
      
      switch (e.key) {
        case 'ArrowUp':
          e.preventDefault();
          changeDirection({ x: 0, y: -1 });
          break;
        case 'ArrowDown':
          e.preventDefault();
          changeDirection({ x: 0, y: 1 });
          break;
        case 'ArrowLeft':
          e.preventDefault();
          changeDirection({ x: -1, y: 0 });
          break;
        case 'ArrowRight':
          e.preventDefault();
          changeDirection({ x: 1, y: 0 });
          break;
        case ' ':
          e.preventDefault();
          if (gameRunning && !gameOver) {
            togglePause();
          }
          // Don't auto-start on spacebar - user must press start button
          break;
      }
    });

    // Touch/Swipe controls
    let touchStartX = null;
    let touchStartY = null;
    const minSwipeDistance = 30;

    function isInteractiveElement(target) {
      return target.tagName === 'BUTTON' || 
             target.closest('button') !== null ||
             target.closest('#gameOver') !== null ||
             target.closest('#helpModal') !== null ||
             target.closest('.menu-dropdown') !== null ||
             target.closest('.direction-controls') !== null;
    }

    document.addEventListener('touchstart', (e) => {
      if (SoundManager.audioContext && !SoundManager.hasUserInteracted) {
        SoundManager.hasUserInteracted = true;
        SoundManager.ensureResumed();
      }
      
      if (isInteractiveElement(e.target)) return;
      // Don't auto-start on touch - user must press start button
      if (!gameRunning || gameOver || gamePaused) return;
      
      e.preventDefault();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      if (isInteractiveElement(e.target)) return;
      if (touchStartX === null || touchStartY === null) return;
      
      e.preventDefault();
      const touch = e.changedTouches[0];
      const deltaX = touch.clientX - touchStartX;
      const deltaY = touch.clientY - touchStartY;
      const absDeltaX = Math.abs(deltaX);
      const absDeltaY = Math.abs(deltaY);
      
      if (absDeltaX > minSwipeDistance || absDeltaY > minSwipeDistance) {
        if (absDeltaX > absDeltaY) {
          if (deltaX > 0) {
            changeDirection({ x: 1, y: 0 });
          } else {
            changeDirection({ x: -1, y: 0 });
          }
        } else {
          if (deltaY > 0) {
            changeDirection({ x: 0, y: 1 });
          } else {
            changeDirection({ x: 0, y: -1 });
          }
        }
      }
      
      touchStartX = null;
      touchStartY = null;
    }, { passive: false });

    // Direction button controls
    document.getElementById('btnUp').addEventListener('click', () => changeDirection({ x: 0, y: -1 }));
    document.getElementById('btnDown').addEventListener('click', () => changeDirection({ x: 0, y: 1 }));
    document.getElementById('btnLeft').addEventListener('click', () => changeDirection({ x: -1, y: 0 }));
    document.getElementById('btnRight').addEventListener('click', () => changeDirection({ x: 1, y: 0 }));

    // Restart button
    restartBtn.addEventListener('click', () => {
      SoundManager.playGlitch();
      restartBtn.classList.add('clicking');
      setTimeout(() => {
        restartBtn.classList.remove('clicking');
      }, 400);
      
      canvas.classList.add('glitching');
      setTimeout(() => {
        canvas.classList.remove('glitching');
      }, 500);
      
      // Stop any existing loops first
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Reset all game state before restarting
      gameRunning = false;
      gameOver = false;
      gamePaused = false;
      score = 10; // Snake starts with 1 segment = 10 points
      snake = [{ x: 0, y: 0 }]; // Start at top left
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      directionQueue = [];
      currentSpeed = INITIAL_SPEED;
      lastMoveTime = 0;
      
      // Set initial food position (cell 4, top row) for immediate catch
      food = [{ x: 4, y: 0 }];
      
      // Hide game over screen if it's showing
      hideGameOver();
      
      // Don't auto-start - wait for user to press start button
      updateScores();
      showStartButton();
      draw();
    });

    restartGameBtn.addEventListener('click', () => {
      // Play glitch sound like reboot button
      SoundManager.playGlitch();
      
      // Add glitching animation to canvas
      canvas.classList.add('glitching');
      setTimeout(() => {
        canvas.classList.remove('glitching');
      }, 500);
      
      // Stop any existing loops first
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Reset all game state before restarting (same as reboot)
      gameRunning = false;
      gameOver = false;
      gamePaused = false;
      score = 10; // Snake starts with 1 segment = 10 points
      snake = [{ x: 0, y: 0 }]; // Start at top left
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      directionQueue = [];
      currentSpeed = INITIAL_SPEED;
      lastMoveTime = 0;
      
      // Set initial food position (cell 4, top row) for immediate catch
      food = [{ x: 4, y: 0 }];
      
      // Hide game over screen
      hideGameOver();
      
      // Don't auto-start - wait for user to press start button
      updateScores();
      showStartButton();
      draw();
    });

    // Menu toggle
    const menuToggle = document.getElementById('menuToggle');
    const menuDropdown = document.getElementById('menuDropdown');
    
    if (menuToggle && menuDropdown) {
      menuToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        menuDropdown.classList.toggle('show');
      });
      
      const closeMenuIfOutside = (e) => {
        const target = e.target;
        if (menuDropdown.classList.contains('show')) {
          if (!menuToggle.contains(target) && !menuDropdown.contains(target)) {
            menuDropdown.classList.remove('show');
          }
        }
      };
      
      document.addEventListener('click', closeMenuIfOutside);
      document.addEventListener('touchend', closeMenuIfOutside);
    }

    // Sound button
    const soundBtn = document.getElementById('soundBtn');
    if (soundBtn) {
      soundBtn.addEventListener('click', () => {
        SoundManager.toggle();
      });
    }

    // Autodrive button and controls
    const autodriveBtn = document.getElementById('autodriveBtn');
    const autodrivePanel = document.getElementById('autodrivePanel');
    const autodriveSpeedSlider = document.getElementById('autodriveSpeed');
    const autodriveSpeedValue = document.getElementById('autodriveSpeedValue');
    const autodriveHyperSpeed = document.getElementById('autodriveHyperSpeed');
    const autodriveStop = document.getElementById('autodriveStop');

    if (autodriveBtn && autodrivePanel) {
      autodriveBtn.addEventListener('click', () => {
        if (!gameRunning || gameOver) {
          // Start game first if not running
          startGame();
        }
        
        if (autodriveActive) {
          // Stop autodrive
          autodriveActive = false;
          autodriveBtn.classList.remove('active');
          autodrivePanel.classList.remove('show');
        } else {
          // Start autodrive
          autodriveActive = true;
          autodriveBtn.classList.add('active');
          autodrivePanel.classList.add('show');
          gamePaused = false; // Ensure game is not paused
        }
      });
    }

    if (autodriveSpeedSlider && autodriveSpeedValue) {
      autodriveSpeedSlider.addEventListener('input', (e) => {
        autodriveSpeed = parseFloat(e.target.value);
        autodriveSpeedValue.textContent = autodriveSpeed + 'x';
      });
    }

    if (autodriveHyperSpeed && autodriveSpeedSlider && autodriveSpeedValue) {
      autodriveHyperSpeed.addEventListener('click', () => {
        // Set to maximum speed (100x)
        const maxSpeed = 100;
        autodriveSpeed = maxSpeed;
        autodriveSpeedSlider.value = maxSpeed;
        autodriveSpeedValue.textContent = maxSpeed + 'x';
      });
    }

    if (autodriveStop) {
      autodriveStop.addEventListener('click', () => {
        autodriveActive = false;
        autodriveBtn.classList.remove('active');
        autodrivePanel.classList.remove('show');
        // Pause the game when stopping autodrive
        if (gameRunning && !gameOver) {
          gamePaused = true;
          updatePauseButton();
        }
      });
    }

    // Pause button
    const pauseBtnTop = document.getElementById('pauseBtnTop');
    if (pauseBtnTop) {
      pauseBtnTop.addEventListener('click', () => {
        togglePause();
      });
    }

    // Clear high score
    const clearHighScoreBtn = document.getElementById('clearHighScoreBtn');
    const confirmModal = document.getElementById('confirmModal');
    const confirmYes = document.getElementById('confirmYes');
    const confirmNo = document.getElementById('confirmNo');
    
    if (clearHighScoreBtn && confirmModal) {
      clearHighScoreBtn.addEventListener('click', () => {
        confirmModal.classList.add('show');
        if (menuDropdown) menuDropdown.classList.remove('show');
      });
    }

    if (confirmYes) {
      confirmYes.addEventListener('click', () => {
        highscore = 0;
        // Store as number (localStorage will convert to string, but this ensures consistency)
        localStorage.setItem('snakeHighscore', String(0));
        updateScores();
        if (confirmModal) confirmModal.classList.remove('show');
        // Don't auto-start game after clearing high score
      });
    }

    if (confirmNo) {
      confirmNo.addEventListener('click', () => {
        if (confirmModal) confirmModal.classList.remove('show');
      });
    }

    if (confirmModal) {
      confirmModal.addEventListener('click', (e) => {
        if (e.target === confirmModal) {
          confirmModal.classList.remove('show');
        }
      });
    }

    // Help modal
    const helpBtn = document.getElementById('helpBtn');
    const helpModal = document.getElementById('helpModal');
    const closeHelp = document.getElementById('closeHelp');

    if (helpBtn) {
      helpBtn.addEventListener('click', () => {
        helpModal.classList.add('show');
        menuDropdown.classList.remove('show');
      });
    }

    if (closeHelp) {
      closeHelp.addEventListener('click', () => {
        helpModal.classList.remove('show');
      });
    }

    if (helpModal) {
      helpModal.addEventListener('click', (e) => {
        if (e.target === helpModal) {
          helpModal.classList.remove('show');
        }
      });
    }

    // Close modals with Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (helpModal && helpModal.classList.contains('show')) {
          helpModal.classList.remove('show');
        }
        if (confirmModal && confirmModal.classList.contains('show')) {
          confirmModal.classList.remove('show');
        }
      }
    });

    // Initialize - set initial food position (cell 4, top row) for immediate catch
    food = [{ x: 4, y: 0 }];
    updateScores();
    draw();
    
    // Show start button initially
    showStartButton();
    
    // Start button click handler
    if (startGameBtn) {
      startGameBtn.addEventListener('click', () => {
        startGame();
      });
    }
  </script>
</body>
</html>



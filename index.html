<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Cyberpunk Snake">
  <meta name="description" content="A cyberpunk-themed Snake game with neon visuals, smooth animations, and retro aesthetics. Play now!">
  <meta name="keywords" content="snake, game, cyberpunk, neon, retro, html5">
  <title>Cyberpunk Snake - Neon Arcade Game</title>
  <link rel="icon" href="images/snake-logo.png" type="image/png">
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Sixtyfour&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(135deg, #1a0a1f 0%, #0f0515 30%, #0a030a 60%, #000000 100%);
      font-family: 'Share Tech Mono', monospace;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #0ff;
      overflow: hidden;
      text-shadow: 0 0 8px #0ff;
      position: relative;
    }
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.15) 1px, transparent 0),
        radial-gradient(circle at 2px 2px, rgba(0, 0, 0, 0.2) 1px, transparent 0),
        radial-gradient(circle at 3px 3px, rgba(255, 255, 255, 0.1) 1px, transparent 0);
      background-size: 4px 4px, 3px 3px, 5px 5px;
      pointer-events: none;
      z-index: 1;
      opacity: 0.4;
      mix-blend-mode: overlay;
    }
    .code-stream {
      position: fixed;
      left: 20px;
      top: 0;
      width: 60px;
      height: 100%;
      font-size: 9px;
      color: rgba(200, 200, 200, 0.25);
      font-family: 'Share Tech Mono', monospace;
      line-height: 1.3;
      overflow: hidden;
      z-index: 1;
    }
    .code-stream::before {
      content: '0x1A2B\A 0x3C4D\A 0x5E6F\A 0x7890\A 0xABCD\A 0xEF01\A 0x2345\A 0x6789\A 0xFEDC\A 0xBA98\A 0x7654\A 0x3210\A 0x9ABC\A 0xDEF0\A 0x1234\A 0x5678\A 0x9ABC\A 0xDEF0\A 0x2468\A 0xACE0\A 0x1357\A 0x9BDF\A 0x0246\A 0x8ACE\A 0x1357\A 0x9BDF\A 0x2468\A 0xACE0\A 0x1357\A 0x9BDF';
      white-space: pre;
      display: block;
    }
    .text-artifacts {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.15;
    }
    .text-artifacts::before {
      content: 'ERR_0x1A2B\A DATA_CORRUPT\A SYS_FAIL\A INIT_SEQ\A LOAD_FAIL\A MEM_ERR\A PROC_TERM\A EXEC_ERR\A STACK_OVF\A NULL_PTR\A ACCESS_DEN\A INVALID_OP\A TIMEOUT\A DEADLOCK\A RACE_COND\A BUFFER_OVF';
      position: absolute;
      top: 10%;
      left: 15%;
      font-size: 7px;
      color: rgba(150, 150, 150, 0.35);
      font-family: 'Share Tech Mono', monospace;
      white-space: pre;
      line-height: 1.4;
      transform: rotate(-1.5deg);
    }
    .text-artifacts::after {
      content: '[192.168.1.42]\A [10.0.0.15]\A [172.16.0.8]\A PORT:8080\A PORT:443\A PORT:22\A PID:1234\A PID:5678\A PID:9012\A /usr/bin/\A /var/log/\A /tmp/data\A /sys/kernel\A /proc/self\A /dev/null\A /etc/config';
      position: absolute;
      bottom: 20%;
      right: 10%;
      font-size: 8px;
      color: rgba(180, 180, 180, 0.3);
      font-family: 'Share Tech Mono', monospace;
      white-space: pre;
      line-height: 1.5;
      transform: rotate(1deg);
    }
    .geometric-lines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.2;
    }
    .geometric-lines::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(90deg, rgba(0, 245, 255, 0.1) 1px, transparent 1px),
        linear-gradient(rgba(0, 245, 255, 0.1) 1px, transparent 1px),
        linear-gradient(45deg, rgba(255, 0, 64, 0.05) 1px, transparent 1px),
        linear-gradient(-45deg, rgba(255, 0, 64, 0.05) 1px, transparent 1px);
      background-size: 50px 50px, 50px 50px, 100px 100px, 100px 100px;
      background-position: 0 0, 0 0, 0 0, 0 0;
    }
    .game-title {
      position: fixed;
      top: 40px;
      left: 80px;
      z-index: 100;
      pointer-events: none;
    }
    .title-menu {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0;
    }
    .sound-menu {
      position: relative;
      display: flex;
      align-items: center;
      gap: 0;
    }
    #menuToggle {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      width: 44px;
      height: 44px;
      padding: 0;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: text-shadow 0.2s ease, transform 0.2s ease;
      border: none;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      pointer-events: auto;
    }
    #menuToggle:hover {
      text-shadow: 0 0 10px #00f5ff;
      transform: scale(1.1);
    }
    #pauseBtnTop {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      width: 44px;
      height: 44px;
      padding: 0;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: text-shadow 0.2s ease, transform 0.2s ease;
      border: none;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      pointer-events: auto;
    }
    #pauseBtnTop:hover {
      text-shadow: 0 0 10px #00f5ff;
      transform: scale(1.1);
    }
    #pauseBtnTop .material-icons {
      font-family: 'Material Icons';
      font-size: 28px;
      color: inherit;
      line-height: 1;
      display: inline-block;
    }
    .menu-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 8px;
      background: rgba(10, 10, 30, 0.95);
      border: 1px solid #00f5ff;
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
      display: none;
      flex-direction: column;
      min-width: 160px;
      padding: 4px 0;
      pointer-events: auto;
      z-index: 200;
    }
    .menu-dropdown.open-above {
      top: auto;
      bottom: 100%;
      margin-top: 0;
      margin-bottom: 8px;
    }
    .menu-dropdown::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #00f5ff;
      pointer-events: none;
      z-index: 1;
    }
    .menu-dropdown.show {
      display: flex;
    }
    .menu-dropdown button {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 12px;
      padding: 8px 16px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: background 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      border: none;
      outline: none;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
    }
    .menu-dropdown button:hover {
      background: rgba(0, 245, 255, 0.1);
      text-shadow: 0 0 10px #00f5ff;
    }
    .menu-dropdown button .material-icons {
      font-family: 'Material Icons';
      font-size: 12px;
      color: inherit;
      line-height: 1;
      display: inline-block;
      margin-right: 4px;
      vertical-align: middle;
    }
    .game-title-main {
      font-size: 25px;
      font-weight: normal;
      color: #ffeb3b;
      text-shadow: 
        2px 2px 0 #00f5ff,
        0 0 4px rgba(0, 245, 255, 0.4),
        0 0 8px rgba(255, 235, 59, 0.8);
      letter-spacing: 2px;
      font-family: 'Sixtyfour', monospace;
      text-transform: uppercase;
      line-height: 1;
      margin-bottom: 5px;
      filter: drop-shadow(0 0 6px rgba(255, 235, 59, 0.5));
    }
    .game-title-sub {
      font-size: 20px;
      font-weight: bold;
      color: #ff6b35;
      text-shadow: 
        0 0 8px #ff6b35,
        0 0 15px rgba(255, 107, 53, 0.5);
      letter-spacing: 4px;
      font-family: 'Share Tech Mono', monospace;
      text-transform: uppercase;
      line-height: 1;
      margin-left: 2px;
    }
    .top-right-controls {
      position: fixed;
      top: 40px;
      right: 80px;
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 100;
    }
    #restart {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #restart::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #restart .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #restart:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #restart:active {
      background: rgba(255, 107, 53, 0.2);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 20px rgba(255, 0, 64, 0.8);
      text-shadow: 0 0 10px #ff0040;
    }
    #restart.clicking {
      animation: buttonGlitch 0.4s ease;
    }
    #pauseBtn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #pauseBtn::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #pauseBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #pauseBtn:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #pauseBtn:active {
      background: rgba(255, 107, 53, 0.2);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 20px rgba(255, 0, 64, 0.8);
      text-shadow: 0 0 10px #ff0040;
    }
    #soundBtn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease, opacity 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #soundBtn::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #soundBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #soundBtn:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #soundBtn.muted {
      opacity: 0.5;
    }
    #autodriveBtn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 7px 20px 7px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(255, 107, 53, 0.5);
      transition: background 0.2s ease, box-shadow 0.2s ease, text-shadow 0.2s ease;
      text-transform: uppercase;
      position: relative;
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px solid #ff6b35;
      outline: none;
    }
    #autodriveBtn::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #ff6b35;
      pointer-events: none;
      z-index: 1;
    }
    #autodriveBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 8px #00f5ff;
      margin-left: auto;
      position: relative;
      z-index: 1;
      display: inline-block;
      line-height: 1;
    }
    #autodriveBtn:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    #autodriveBtn.active {
      background: rgba(0, 245, 255, 0.1);
      border-color: #00f5ff;
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
    }
    #autodrivePanel {
      position: fixed;
      top: 40px;
      right: 80px;
      background: rgba(10, 10, 30, 0.95);
      border: 2px solid #00f5ff;
      border-radius: 8px;
      padding: 15px 20px;
      min-width: 280px;
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.5), inset 0 0 10px rgba(0, 245, 255, 0.1);
      z-index: 100;
      display: none;
      flex-direction: column;
      gap: 12px;
    }
    #autodrivePanel.show {
      display: flex;
    }
    .autodrive-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    .autodrive-panel-header h3 {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      margin: 0;
      text-shadow: 0 0 8px #00f5ff;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .autodrive-panel-header .autodrive-indicator {
      width: 8px;
      height: 8px;
      background: #ff6b35;
      border-radius: 50%;
      box-shadow: 0 0 8px #ff6b35;
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .autodrive-controls {
      margin: 0;
    }
    .autodrive-controls label {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 12px;
      display: block;
      margin-bottom: 8px;
      text-shadow: 0 0 4px rgba(0, 245, 255, 0.3);
    }
    .autodrive-speed-container {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .autodrive-speed-slider {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      background: rgba(0, 245, 255, 0.3);
      border-radius: 2px;
      outline: none;
      touch-action: pan-x;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      user-select: none;
    }
    .autodrive-speed-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      background: #00f5ff;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 8px #00f5ff;
      transition: box-shadow 0.2s ease;
      touch-action: none;
    }
    .autodrive-speed-slider::-webkit-slider-thumb:hover {
      box-shadow: 0 0 12px #00f5ff;
    }
    .autodrive-speed-slider::-webkit-slider-thumb:active {
      box-shadow: 0 0 15px #00f5ff;
      transform: scale(1.1);
    }
    .autodrive-speed-slider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      background: #00f5ff;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 8px #00f5ff;
      touch-action: none;
    }
    .autodrive-speed-slider::-moz-range-thumb:active {
      box-shadow: 0 0 15px #00f5ff;
      transform: scale(1.1);
    }
    .autodrive-speed-value {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      min-width: 35px;
      text-align: right;
      text-shadow: 0 0 6px #00f5ff;
    }
    #spawnSnack {
      background: transparent;
      border: 1px solid #ffeb3b;
      color: #ffeb3b;
      font-family: 'Share Tech Mono', monospace;
      font-size: 12px;
      padding: 8px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #ffeb3b;
      box-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
      transition: all 0.3s ease;
      border-radius: 4px;
      text-transform: uppercase;
      width: 100%;
      margin-top: 5px;
    }
    #spawnSnack:hover {
      background: rgba(255, 235, 59, 0.1);
      color: #ffff00;
      border-color: #ffff00;
      box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
      transform: scale(1.02);
      text-shadow: 0 0 15px #ffff00;
    }
    #spawnSnack:active {
      transform: scale(0.98);
    }
    #autodriveStop {
      background: transparent;
      border: 1px solid #ff6b35;
      color: #ff6b35;
      font-family: 'Share Tech Mono', monospace;
      font-size: 12px;
      padding: 8px 20px;
      cursor: pointer;
      text-shadow: 0 0 6px #ff6b35;
      box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
      transition: all 0.3s ease;
      border-radius: 4px;
      text-transform: uppercase;
      width: 100%;
      margin-top: 5px;
    }
    #autodriveStop:hover {
      background: rgba(255, 107, 53, 0.1);
      color: #ff0040;
      border-color: #ff0040;
      box-shadow: 0 0 15px rgba(255, 0, 64, 0.8);
      transform: scale(1.02);
      text-shadow: 0 0 10px #ff0040;
    }
    @keyframes buttonGlitch {
      0%, 100% { transform: translateX(0); }
      10% { transform: translateX(-2px) translateY(1px); }
      20% { transform: translateX(2px) translateY(-1px); }
      30% { transform: translateX(-1px) translateY(2px); }
      40% { transform: translateX(1px) translateY(-2px); }
      50% { transform: translateX(-2px); }
      60% { transform: translateX(2px); }
      70% { transform: translateX(-1px); }
      80% { transform: translateX(1px); }
    }
    canvas.glitching {
      animation: boardGlitch 0.5s ease;
    }
    @keyframes boardGlitch {
      0%, 100% { 
        transform: translateX(0) translateY(0);
        filter: hue-rotate(0deg);
      }
      5% { 
        transform: translateX(-3px) translateY(2px);
        filter: hue-rotate(90deg);
      }
      10% { 
        transform: translateX(3px) translateY(-2px);
        filter: hue-rotate(-90deg);
      }
      15% { 
        transform: translateX(-2px) translateY(3px);
        filter: hue-rotate(180deg);
      }
      20% { 
        transform: translateX(2px) translateY(-3px);
        filter: hue-rotate(-180deg);
      }
      25% { 
        transform: translateX(-4px) translateY(1px);
        filter: hue-rotate(45deg);
      }
      30% { 
        transform: translateX(4px) translateY(-1px);
        filter: hue-rotate(-45deg);
      }
      35% { 
        transform: translateX(-1px) translateY(4px);
        filter: hue-rotate(135deg);
      }
      40% { 
        transform: translateX(1px) translateY(-4px);
        filter: hue-rotate(-135deg);
      }
      45% { 
        transform: translateX(-3px);
        filter: hue-rotate(90deg);
      }
      50% { 
        transform: translateX(3px);
        filter: hue-rotate(-90deg);
      }
      55% { 
        transform: translateX(-2px);
        filter: hue-rotate(0deg);
      }
      60% { 
        transform: translateX(2px);
        filter: hue-rotate(0deg);
      }
      65%, 100% { 
        transform: translateX(0) translateY(0);
        filter: hue-rotate(0deg);
      }
    }
    .score-display {
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      pointer-events: none;
      flex: 1;
    }
    .score-display strong {
      font-size: 32px;
      color: #00f5ff;
      text-shadow: 0 0 10px #00f5ff, 0 0 20px rgba(0, 245, 255, 0.5);
      font-family: 'Share Tech Mono', monospace;
    }
    .high-score-system {
      position: fixed;
      bottom: 40px;
      right: 80px;
      z-index: 100;
      font-family: 'Share Tech Mono', monospace;
      font-size: 16px;
      color: rgba(150, 150, 150, 0.6);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .high-score-system::before {
      content: '[SYS] ';
      color: rgba(0, 245, 255, 0.5);
    }
    .high-score-system strong {
      color: rgba(0, 245, 255, 0.7);
      font-weight: normal;
    }
    canvas {
      background: rgba(10, 10, 30, 0.3);
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.5), 0 0 40px rgba(255, 0, 255, 0.3), inset 0 0 12px rgba(0, 245, 255, 0.3);
      border: 2px solid rgba(0, 245, 255, 0.75);
      border-radius: 12px;
      image-rendering: pixelated;
      display: block;
      position: relative;
      z-index: 10;
    }
    #game-container {
      position: relative;
      display: inline-block;
    }
    .top-game-controls {
      position: absolute;
      top: -60px;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 100;
      width: 100%;
    }
    .top-game-controls-left {
      display: flex;
      align-items: center;
      gap: 0;
      flex: 0 0 auto;
      min-width: 44px;
    }
    .top-game-controls-right {
      display: flex;
      align-items: center;
      gap: 0;
      flex: 0 0 auto;
      min-width: 44px;
      justify-content: flex-end;
    }
    #gameOver {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(5, 0, 17, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
    }
    #gameOver.show {
      display: flex;
    }
    .game-over-content {
      text-align: center;
    }
    .flatlined-text {
      font-size: 72px;
      font-weight: bold;
      color: #ff0040;
      text-shadow: 
        0 0 4px rgba(255, 0, 64, 0.8),
        0 0 10px rgba(255, 0, 64, 0.48),
        0 0 18px rgba(255, 0, 64, 0.32),
        0 0 28px rgba(255, 0, 64, 0.24),
        0 0 40px rgba(255, 0, 64, 0.16);
      margin-bottom: 20px;
      letter-spacing: 8px;
      filter: brightness(1.1);
    }
    .flatlined-text.perfect-score {
      color: #00ff00;
      text-shadow: 
        0 0 4px rgba(0, 255, 0, 0.8),
        0 0 10px rgba(0, 255, 0, 0.48),
        0 0 18px rgba(0, 255, 0, 0.32),
        0 0 28px rgba(0, 255, 0, 0.24),
        0 0 40px rgba(0, 255, 0, 0.16);
    }
    .game-over-subtitle {
      font-size: 24px;
      color: #ff0040;
      text-shadow: 0 0 10px #ff0040;
      margin-bottom: 30px;
    }
    .game-over-subtitle.perfect-score {
      color: #00ff00;
      text-shadow: 0 0 10px #00ff00;
    }
    .final-score {
      font-size: 42px;
      color: #00f5ff;
      text-shadow: 0 0 15px #00f5ff;
      margin-bottom: 40px;
    }
    .final-score span {
      display: block;
      font-size: 36px;
      color: #00f5ff;
      margin-top: 10px;
    }
    #restartGame {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      padding: 15px 40px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 15px #00f5ff;
      transition: all 0.3s ease;
      border-radius: 6px;
    }
    #restartGame:hover {
      background: rgba(0, 245, 255, 0.1);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 25px #ffeb3b;
      transform: scale(1.1);
      text-shadow: 0 0 15px #ffeb3b;
    }
    #startGame {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 24px;
      padding: 18px 50px;
      cursor: pointer;
      text-shadow: 0 0 10px #00f5ff;
      box-shadow: 0 0 20px #00f5ff;
      transition: all 0.3s ease;
      border-radius: 6px;
      text-transform: uppercase;
      letter-spacing: 2px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 200;
      display: none;
    }
    #startGame.show {
      display: block;
    }
    #startGame:hover {
      background: rgba(0, 245, 255, 0.15);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 30px #ffeb3b;
      transform: translate(-50%, -50%) scale(1.05);
      text-shadow: 0 0 20px #ffeb3b;
    }
    #startGame:active {
      transform: translate(-50%, -50%) scale(0.98);
    }
    #helpModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }
    #helpModal.show {
      display: flex;
    }
    #controlModeModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }
    #controlModeModal.show {
      display: flex;
    }
    #hamiltonianPathModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }
    #hamiltonianPathModal.show {
      display: flex;
    }
    #closeHamiltonianPath {
      position: absolute;
      top: 15px;
      right: 15px;
      background: transparent;
      border: 1px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      width: 35px;
      height: 35px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
      transition: all 0.2s ease;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #closeHamiltonianPath:hover {
      background: rgba(0, 245, 255, 0.1);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 15px rgba(255, 0, 64, 0.5);
      text-shadow: 0 0 10px #ff0040;
    }
    #hamiltonianPathCanvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #closeControlMode {
      position: absolute;
      top: 15px;
      right: 15px;
      background: transparent;
      border: 1px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      width: 35px;
      height: 35px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
      transition: all 0.2s ease;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #closeControlMode:hover {
      background: rgba(0, 245, 255, 0.1);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 15px rgba(255, 0, 64, 0.5);
      text-shadow: 0 0 10px #ff0040;
    }
    #confirmModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease;
    }
    #confirmModal.show {
      display: flex;
    }
    .confirm-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 20px;
    }
    .confirm-btn {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 16px;
      padding: 12px 30px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
      transition: all 0.3s ease;
      border-radius: 6px;
      text-transform: uppercase;
    }
    .confirm-btn:hover {
      background: rgba(0, 245, 255, 0.1);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 25px rgba(255, 235, 59, 0.8);
      transform: scale(1.05);
      text-shadow: 0 0 15px #ffeb3b;
    }
    .reset-btn {
      border-color: #ff6b35 !important;
      color: #ff6b35 !important;
      text-shadow: 0 0 8px #ff6b35 !important;
      box-shadow: 0 0 15px rgba(255, 107, 53, 0.5) !important;
    }
    .reset-btn:hover {
      background: rgba(255, 107, 53, 0.1) !important;
      color: #ff6b35 !important;
      border-color: #ff6b35 !important;
      box-shadow: 0 0 20px rgba(255, 107, 53, 0.7) !important;
      text-shadow: 0 0 12px #ff6b35 !important;
    }
    .reset-btn .material-icons {
      color: inherit !important;
      text-shadow: inherit !important;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .help-content {
      background: linear-gradient(135deg, rgba(10, 10, 30, 0.95) 0%, rgba(15, 5, 25, 0.95) 100%);
      border: 2px solid #00f5ff;
      border-radius: 8px;
      padding: 40px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(0, 245, 255, 0.5), inset 0 0 20px rgba(0, 245, 255, 0.1);
      position: relative;
      animation: slideIn 0.3s ease;
    }
    @keyframes slideIn {
      from {
        transform: translateY(-20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    .help-content h2 {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      margin: 0 0 20px 0;
      text-shadow: 0 0 10px #00f5ff;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .help-content h3 {
      color: #ffeb3b;
      font-family: 'Share Tech Mono', monospace;
      font-size: 18px;
      margin: 25px 0 10px 0;
      text-shadow: 0 0 8px rgba(255, 235, 59, 0.5);
    }
    .help-content p {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      line-height: 1.8;
      margin: 10px 0;
      text-shadow: 0 0 4px rgba(0, 245, 255, 0.3);
    }
    #confirmModal .help-content p {
      text-align: center;
    }
    .help-content ul {
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      line-height: 2;
      margin: 10px 0;
      padding-left: 25px;
      text-shadow: 0 0 4px rgba(0, 245, 255, 0.3);
    }
    .help-content li {
      margin: 8px 0;
    }
    .help-content .key {
      display: inline-block;
      background: rgba(0, 245, 255, 0.2);
      border: 1px solid #00f5ff;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: bold;
      color: #ffeb3b;
      text-shadow: 0 0 6px rgba(255, 235, 59, 0.8);
      margin: 0 2px;
    }
    #controlModeSelect {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2300f5ff' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 40px;
    }
    #controlModeSelect:hover {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.7);
    }
    #controlModeSelect:focus {
      background: rgba(10, 10, 30, 0.95);
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.7);
    }
    #controlModeSelect option {
      background: rgba(10, 10, 30, 0.95);
      color: #00f5ff;
    }
    #closeHelp {
      position: absolute;
      top: 15px;
      right: 15px;
      background: transparent;
      border: 1px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      width: 35px;
      height: 35px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
      transition: all 0.2s ease;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #closeHelp:hover {
      background: rgba(0, 245, 255, 0.1);
      border-color: #ff0040;
      color: #ff0040;
      box-shadow: 0 0 15px rgba(255, 0, 64, 0.5);
      text-shadow: 0 0 10px #ff0040;
    }
    .direction-controls {
      position: fixed;
      bottom: 40px;
      left: 80px;
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      gap: 5px;
      z-index: 1000;
      user-select: none;
    }
    .direction-controls.dragging {
      cursor: grabbing;
    }
    .direction-controls.dragging .direction-btn {
      pointer-events: none;
    }
    .direction-controls-handle {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 20px;
      background: rgba(10, 10, 30, 0.9);
      border: 1px solid #00f5ff;
      border-radius: 4px 4px 0 0;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      z-index: 1001;
      transition: all 0.2s ease;
    }
    .direction-controls-handle:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
    }
    .direction-controls-handle:active {
      cursor: grabbing;
    }
    .direction-controls-handle::before {
      content: '⋮⋮';
      color: #00f5ff;
      font-size: 12px;
      letter-spacing: 2px;
      text-shadow: 0 0 6px #00f5ff;
    }
    .relative-turn-control {
      position: fixed;
      z-index: 1000;
      user-select: none;
      display: none;
    }
    .relative-turn-control.show {
      display: block;
    }
    .relative-turn-control-handle {
      position: absolute;
      top: -25px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 20px;
      background: rgba(10, 10, 30, 0.9);
      border: 1px solid #00f5ff;
      border-radius: 4px 4px 0 0;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      z-index: 1001;
      transition: all 0.2s ease;
    }
    .relative-turn-control-handle:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
    }
    .relative-turn-control-handle:active {
      cursor: grabbing;
    }
    .relative-turn-control-handle::before {
      content: '⋮⋮';
      color: #00f5ff;
      font-size: 12px;
      letter-spacing: 2px;
      text-shadow: 0 0 6px #00f5ff;
    }
    .relative-turn-control.dragging .relative-turn-btn {
      pointer-events: none;
    }
    .relative-turn-btn {
      width: 60px;
      height: 60px;
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 24px;
      border: 2px solid #00f5ff;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      outline: none;
      border-radius: 8px;
    }
    .relative-turn-btn:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    .relative-turn-btn:active {
      background: rgba(0, 245, 255, 0.2);
      transform: scale(0.95);
    }
    .relative-turn-btn .material-icons {
      font-family: 'Material Icons';
      font-size: 32px;
      color: inherit;
      line-height: 1;
    }
    .split-control {
      position: fixed;
      z-index: 1000;
      user-select: none;
      display: none;
    }
    .split-control.show {
      display: block;
    }
    .split-control-handle {
      position: absolute;
      top: -25px;
      left: 0;
      width: 40px;
      height: 20px;
      background: rgba(10, 10, 30, 0.9);
      border: 1px solid #00f5ff;
      border-radius: 4px 4px 0 0;
      cursor: grab;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      z-index: 1001;
      transition: all 0.2s ease;
    }
    #splitControlLeftHandle {
      left: 60px; /* Center over column 2 (50px + 5px gap + 5px offset to center 40px handle) */
    }
    #splitControlRightHandle {
      left: 5px; /* Center over column 1 (5px offset to center 40px handle over 50px column) */
    }
    .split-control-handle:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
    }
    .split-control-handle:active {
      cursor: grabbing;
    }
    .split-control-handle::before {
      content: '⋮⋮';
      color: #00f5ff;
      font-size: 12px;
      letter-spacing: 2px;
      text-shadow: 0 0 6px #00f5ff;
    }
    .split-control.dragging .split-btn {
      pointer-events: none;
    }
    .split-control-buttons {
      display: grid;
      grid-template-columns: 50px 50px;
      grid-template-rows: 50px 50px 50px;
      gap: 5px;
      position: relative;
    }
    .split-btn {
      width: 50px;
      height: 50px;
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      border: 1px solid #00f5ff;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      outline: none;
      border-radius: 4px;
    }
    .split-btn:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    .split-btn:active {
      background: rgba(0, 245, 255, 0.2);
      transform: scale(0.95);
    }
    .split-btn .material-icons {
      font-family: 'Material Icons';
      font-size: 24px;
      color: inherit;
      line-height: 1;
    }
    .split-btn.empty {
      background: transparent;
      border: none;
      cursor: default;
      box-shadow: none;
    }
    .split-btn.empty:hover {
      background: transparent;
      box-shadow: none;
    }
    .direction-btn {
      background: rgba(10, 10, 30, 0.9);
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      border: 1px solid #00f5ff;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 8px rgba(0, 245, 255, 0.5);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      outline: none;
    }
    .direction-btn:hover {
      background: rgba(0, 245, 255, 0.1);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
      text-shadow: 0 0 10px #00f5ff;
    }
    .direction-btn:active {
      background: rgba(0, 245, 255, 0.2);
      transform: scale(0.95);
    }
    .direction-btn.empty {
      background: transparent;
      border: none;
      cursor: default;
      box-shadow: none;
    }
    .direction-btn.empty:hover {
      background: transparent;
      box-shadow: none;
    }
    .direction-btn .material-icons {
      font-family: 'Material Icons';
      font-size: 24px;
      color: inherit;
      line-height: 1;
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body {
        overflow-y: auto;
        padding: 10px;
        min-height: 100vh;
        height: auto;
      }

      .game-title {
        top: 15px;
        left: 15px;
        position: fixed;
        max-width: calc(50% - 20px);
      }

      .game-title-main {
        font-size: 18px;
      }

      .game-title-sub {
        font-size: 14px;
        letter-spacing: 2px;
      }

      .top-game-controls {
        top: -50px;
      }

      #menuToggle {
        font-size: 24px;
        width: 36px;
        height: 36px;
      }

      #pauseBtnTop {
        font-size: 24px;
        width: 36px;
        height: 36px;
      }

      #pauseBtnTop .material-icons {
        font-size: 24px;
      }

      #autodriveBtn {
        font-size: 11px;
        padding: 8px 12px;
        min-height: 40px;
      }

      #autodriveBtn .material-icons {
        font-size: 16px;
      }

      #autodrivePanel {
        top: 10px;
        right: 10px;
        min-width: 200px;
        padding: 10px 12px;
      }

      .autodrive-panel-header h3 {
        font-size: 12px;
      }

      .autodrive-controls label {
        font-size: 11px;
      }

      .autodrive-speed-value {
        font-size: 12px;
      }


      #spawnSnack {
        font-size: 11px;
        padding: 6px 15px;
      }

      #autodriveStop {
        font-size: 11px;
        padding: 6px 15px;
      }

      #soundBtn {
        font-size: 11px;
        padding: 8px 12px;
        min-height: 40px;
      }

      #soundBtn .material-icons {
        font-size: 16px;
      }

      .menu-dropdown {
        bottom: 42px;
        min-width: 140px;
      }

      .menu-dropdown button {
        font-size: 11px;
        padding: 6px 12px;
        white-space: nowrap;
      }

      .top-right-controls {
        top: 15px;
        right: 15px;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
        flex-direction: row;
        align-items: flex-start;
        max-width: calc(50% - 20px);
      }

      #restart {
        font-size: 11px;
        padding: 8px 12px;
        min-height: 40px;
        touch-action: manipulation;
        flex: 0 0 auto;
        min-width: 75px;
        white-space: nowrap;
      }

      #game-container {
        margin-top: 80px;
        margin-bottom: 20px;
      }

      canvas {
        width: 100% !important;
        max-width: 100vw;
        height: auto !important;
        max-height: calc(100vh - 300px);
        aspect-ratio: 1;
      }

      .score-display strong {
        font-size: 24px;
      }

      .high-score-system {
        bottom: 15px;
        right: 15px;
        font-size: 12px;
        position: fixed;
      }

      .code-stream, .text-artifacts {
        display: none;
      }

      .help-content {
        padding: 25px;
        max-width: 95%;
        max-height: 90vh;
      }

      .help-content h2 {
        font-size: 22px;
      }

      .help-content h3 {
        font-size: 16px;
      }

      .help-content p, .help-content li {
        font-size: 12px;
      }

      .game-over-content {
        padding: 20px;
      }

      .flatlined-text {
        font-size: 48px;
        text-shadow: 
          0 0 3px rgba(255, 0, 64, 0.8),
          0 0 7px rgba(255, 0, 64, 0.48),
          0 0 12px rgba(255, 0, 64, 0.32),
          0 0 20px rgba(255, 0, 64, 0.24),
          0 0 28px rgba(255, 0, 64, 0.16);
      }
      .flatlined-text.perfect-score {
        text-shadow: 
          0 0 3px rgba(0, 255, 0, 0.8),
          0 0 7px rgba(0, 255, 0, 0.48),
          0 0 12px rgba(0, 255, 0, 0.32),
          0 0 20px rgba(0, 255, 0, 0.24),
          0 0 28px rgba(0, 255, 0, 0.16);
      }

      .game-over-subtitle {
        font-size: 18px;
      }
      .game-over-subtitle.perfect-score {
        color: #00ff00;
        text-shadow: 0 0 8px #00ff00;
      }

      #restartGame {
        font-size: 16px;
        padding: 12px 30px;
        min-height: 44px;
      }

      .direction-controls {
        bottom: 15px;
        left: 15px;
        grid-template-columns: repeat(3, 45px);
        grid-template-rows: repeat(3, 45px);
        gap: 4px;
      }

      .direction-btn {
        font-size: 18px;
      }

      .direction-btn .material-icons {
        font-size: 20px;
      }
    }

    @media (max-width: 480px) {
      .top-game-controls {
        top: -45px;
      }

      .game-title-main {
        font-size: 16px;
      }

      .game-title-sub {
        font-size: 12px;
      }

      .game-title {
        max-width: calc(45% - 15px);
      }

      .top-right-controls {
        gap: 6px;
        top: 10px;
        right: 10px;
        max-width: calc(55% - 15px);
      }

      #autodrivePanel {
        top: 8px;
        right: 8px;
        min-width: 180px;
        padding: 8px 10px;
      }

      .autodrive-panel-header h3 {
        font-size: 11px;
      }

      .autodrive-controls label {
        font-size: 10px;
      }

      .autodrive-speed-value {
        font-size: 11px;
      }


      #spawnSnack {
        font-size: 10px;
        padding: 5px 12px;
      }

      #autodriveStop {
        font-size: 10px;
        padding: 5px 12px;
      }

      #restart {
        font-size: 10px;
        padding: 6px 10px;
        min-width: 65px;
        min-height: 38px;
      }

      #autodriveBtn {
        font-size: 10px;
        padding: 6px 10px;
        min-height: 38px;
      }

      #autodriveBtn .material-icons {
        font-size: 14px;
      }

      .score-display strong {
        font-size: 20px;
      }

      #menuToggle {
        font-size: 20px;
        width: 32px;
        height: 32px;
      }

      #pauseBtnTop {
        font-size: 20px;
        width: 32px;
        height: 32px;
      }

      #pauseBtnTop .material-icons {
        font-size: 20px;
      }

      #soundBtn {
        font-size: 10px;
        padding: 6px 10px;
        min-height: 38px;
      }

      #soundBtn .material-icons {
        font-size: 14px;
      }

      .high-score-system {
        font-size: 11px;
      }

      .help-content {
        padding: 20px;
      }

      .direction-controls {
        bottom: 10px;
        left: 10px;
        grid-template-columns: repeat(3, 40px);
        grid-template-rows: repeat(3, 40px);
        gap: 3px;
      }

      .direction-btn {
        font-size: 16px;
      }

      .direction-btn .material-icons {
        font-size: 18px;
      }

      #startGame {
        font-size: 18px;
        padding: 14px 35px;
      }
    }

    /* Prevent text selection on buttons for better mobile UX */
    button {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      user-select: none;
      -webkit-user-select: none;
    }

    /* Prevent pull-to-refresh on mobile */
    body {
      overscroll-behavior-y: contain;
    }

    canvas {
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="game-title">
    <div class="game-title-main">Cyberpunk</div>
    <div class="game-title-sub">SNAKE</div>
  </div>
  <div class="code-stream"></div>
  <div class="text-artifacts"></div>
  <div class="geometric-lines"></div>
  <div class="top-right-controls">
    <button id="restart" title="Restart">REBOOT<span class="material-icons">power_settings_new</span></button>
    <button id="autodriveBtn" title="Autodrive Mode"><span class="material-icons">settings</span>AUTODRIVE</button>
    <button id="soundBtn" title="Toggle Sound"><span class="material-icons">volume_up</span></button>
  </div>
  <div id="game-container">
    <div class="top-game-controls">
      <div class="top-game-controls-left">
        <div class="title-menu">
          <button id="menuToggle" title="Menu">☰</button>
          <div class="menu-dropdown" id="menuDropdown">
            <button id="clearHighScoreBtn" title="Clear High Score"><span class="material-icons">do_not_disturb</span> CLEAR HIGH SCORE</button>
            <button id="controlModeBtn" title="Control Mode"><span class="material-icons">gamepad</span> CONTROL MODE</button>
            <button id="hamiltonianPathBtn" title="Configure Hamiltonian Path"><span class="material-icons">route</span> HAMILTONIAN PATH</button>
            <button id="helpBtn" title="How to Play"><span class="material-icons">help</span> HELP</button>
          </div>
        </div>
      </div>
      <div class="score-display">
        <strong id="score">0</strong>
      </div>
      <div class="top-game-controls-right">
        <button id="pauseBtnTop" title="Pause/Resume"><span class="material-icons">pause</span></button>
      </div>
    </div>
    <canvas id="game"></canvas>
    <button id="startGame">START GAME</button>
  </div>
  <div id="helpModal">
    <div class="help-content">
      <button id="closeHelp" title="Close">×</button>
      <h2>HOW TO PLAY</h2>
      
      <h3>Objective</h3>
      <p>Control the snake to eat food and grow longer. Avoid hitting the walls or your own tail!</p>
      
      <h3>Controls</h3>
      <ul>
        <li><span class="key">↑</span> <span class="key">↓</span> <span class="key">←</span> <span class="key">→</span> Arrow keys to change direction</li>
        <li><span class="key">Swipe</span> on mobile devices</li>
        <li><span class="key">Direction Buttons</span> on mobile</li>
      </ul>
      
      <h3>Gameplay</h3>
      <ul>
        <li>The snake moves continuously in the current direction</li>
        <li>Eat the glowing food to grow and increase your score</li>
        <li>Each food item increases your score by 10 points</li>
        <li>The snake wraps around walls (goes through to the opposite side)</li>
        <li>The game ends only if you hit your own body</li>
        <li>The snake moves faster as your score increases</li>
      </ul>
      
      <h3>Tips</h3>
      <ul>
        <li>Plan your path to avoid trapping yourself</li>
        <li>Use wall wrapping to escape tight situations</li>
        <li>Keep moving - the snake never stops!</li>
      </ul>
    </div>
  </div>
  <div id="autodrivePanel">
    <div class="autodrive-panel-header">
      <h3>AUTODRIVE MODE</h3>
      <div class="autodrive-indicator"></div>
    </div>
    <div class="autodrive-controls">
      <label>SPEED:</label>
      <div class="autodrive-speed-container">
        <input type="range" id="autodriveSpeed" class="autodrive-speed-slider" min="0.5" max="10" step="0.5" value="1">
        <span id="autodriveSpeedValue" class="autodrive-speed-value">1x</span>
      </div>
      <button id="spawnSnack">SPAWN SNACKS</button>
    </div>
    <button id="autodriveStop">STOP</button>
  </div>
  <div id="confirmModal">
    <div class="help-content">
      <h2>CONFIRM</h2>
      <p>Are you sure you want to clear your high score?</p>
      <div class="confirm-buttons">
        <button id="confirmYes" class="confirm-btn">YES</button>
        <button id="confirmNo" class="confirm-btn">NO - ONE MORE GIG</button>
      </div>
    </div>
  </div>
  <div id="controlModeModal">
    <div class="help-content">
      <button id="closeControlMode" title="Close">×</button>
      <h2>CONTROL MODE</h2>
      <p>Choose how the directional controls work:</p>
      <div style="margin-top: 20px;">
        <select id="controlModeSelect" style="width: 100%; padding: 12px; background: rgba(10, 10, 30, 0.9); border: 2px solid #00f5ff; color: #00f5ff; font-family: 'Share Tech Mono', monospace; font-size: 14px; border-radius: 6px; text-transform: uppercase; cursor: pointer; outline: none; box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);">
          <option value="none">NONE</option>
          <option value="absolute">ABSOLUTE DIRECTIONS</option>
          <option value="relative">RELATIVE TURNS (LEFT/RIGHT)</option>
          <option value="split">SPLIT DIRECTIONS (LEFT/RIGHT SIDES)</option>
        </select>
        <p id="controlModeDescription" style="margin-top: 15px; font-size: 12px; opacity: 0.8; color: #00f5ff; text-shadow: 0 0 4px rgba(0, 245, 255, 0.3); padding-left: 4px; min-height: 40px;">
          No touch controls displayed. Use keyboard or swipe gestures to play.
        </p>
        <button id="resetControlPositions" class="confirm-btn reset-btn" style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px; margin-top: 20px;">
          <span class="material-icons" style="font-size: 20px; line-height: 1; display: flex; align-items: center;">refresh</span>
          <span>RESET CONTROL POSITIONS</span>
        </button>
        <p style="margin-top: 8px; font-size: 12px; opacity: 0.8; color: #ff6b35; text-shadow: 0 0 4px rgba(255, 107, 53, 0.3); padding-left: 4px;">
          Reset all control positions to their default locations.
        </p>
      </div>
    </div>
  </div>
  <div id="hamiltonianPathModal">
    <div class="help-content" style="max-width: 90vw; max-height: 90vh; overflow: auto;">
      <button id="closeHamiltonianPath" title="Close">×</button>
      <h2>CONFIGURE HAMILTONIAN PATH</h2>
      <div style="margin: 20px 0;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
          <div style="flex: 1; min-width: 200px;">
            <div style="color: #00f5ff; font-size: 14px; margin-bottom: 5px;">Step: <strong id="hamiltonianStep">0</strong> / <strong id="hamiltonianTotal">400</strong></div>
            <div style="color: #ff6b35; font-size: 14px;">Remaining: <strong id="hamiltonianRemaining">400</strong> cells</div>
          </div>
          <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
            <label style="color: #00f5ff; font-size: 14px;">Preset:</label>
            <select id="hamiltonianPathPreset" style="padding: 8px 12px; background: rgba(10, 10, 30, 0.9); border: 2px solid #00f5ff; color: #00f5ff; font-family: 'Share Tech Mono', monospace; font-size: 14px; border-radius: 6px; cursor: pointer; outline: none; box-shadow: 0 0 10px rgba(0, 245, 255, 0.3); min-width: 150px;">
              <option value="">Custom / None</option>
              <option value="basic">Basic Hamilton</option>
              <option value="christmas">Christmas Tree</option>
              <option value="spaghetti">Spaghetti</option>
              <option value="squiggle">Squiggle</option>
            </select>
          </div>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <button id="undoHamiltonianPath" class="confirm-btn" style="background: #9664ff;" title="Undo (Ctrl+Z / Cmd+Z)">UNDO</button>
            <button id="redohamiltonianPath" class="confirm-btn" style="background: #9664ff;" title="Redo (Ctrl+Shift+Z / Cmd+Shift+Z)">REDO</button>
            <button id="clearHamiltonianPath" class="confirm-btn" style="background: #ff0040;">CLEAR</button>
            <button id="importHamiltonianPath" class="confirm-btn" style="background: #ff6b35;">IMPORT</button>
            <button id="exportHamiltonianPath" class="confirm-btn" style="background: #00f5ff; color: #000;">EXPORT</button>
            <button id="saveHamiltonianPath" class="confirm-btn" style="background: #00ff00; color: #000;">SAVE</button>
          </div>
        </div>
        <div style="position: relative; border: 2px solid #00f5ff; border-radius: 6px; background: rgba(10, 10, 30, 0.9); padding: 10px; box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);">
          <canvas id="hamiltonianPathCanvas" tabindex="0" style="display: block; width: 100%; max-width: 600px; margin: 0 auto; cursor: crosshair; outline: none;"></canvas>
          <input type="file" id="hamiltonianPathFileInput" accept=".json" style="display: none;">
        </div>
        <div id="hamiltonianPathStatus" style="margin-top: 15px; padding: 10px; border-radius: 6px; font-size: 14px; text-align: center;"></div>
        <div style="margin-top: 15px; font-size: 12px; color: #00f5ff; opacity: 0.8;">
          <p><strong>Instructions:</strong></p>
          <ul style="margin: 10px 0; padding-left: 20px;">
            <li>Click and drag to draw the path</li>
            <li>Use arrow keys to navigate step by step</li>
            <li>Clicking a distant cell will auto-fill a straight path if clear</li>
            <li>Use Undo/Redo buttons or Ctrl+Z / Ctrl+Shift+Z (Cmd on Mac)</li>
            <li>Path must start and end at the top-left corner (0, 0)</li>
            <li>All cells must be visited exactly once</li>
            <li>Path must be continuous (adjacent cells only)</li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  <div class="high-score-system">
    HIGH SCORE: <strong id="highscore">0</strong>
  </div>
  <div class="direction-controls" id="directionControls">
    <div class="direction-controls-handle" id="directionControlsHandle"></div>
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnUp" title="Up"><span class="material-icons">arrow_upward</span></button>
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnLeft" title="Left"><span class="material-icons">arrow_back</span></button>
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnRight" title="Right"><span class="material-icons">arrow_forward</span></button>
    <div class="direction-btn empty"></div>
    <button class="direction-btn" id="btnDown" title="Down"><span class="material-icons">arrow_downward</span></button>
    <div class="direction-btn empty"></div>
  </div>
  <div class="relative-turn-control" id="relativeTurnLeft">
    <div class="relative-turn-control-handle" id="relativeTurnLeftHandle"></div>
    <button class="relative-turn-btn" id="btnTurnLeft" title="Turn Left"><span class="material-icons">rotate_left</span></button>
  </div>
  <div class="relative-turn-control" id="relativeTurnRight">
    <div class="relative-turn-control-handle" id="relativeTurnRightHandle"></div>
    <button class="relative-turn-btn" id="btnTurnRight" title="Turn Right"><span class="material-icons">rotate_right</span></button>
  </div>
  <div class="split-control" id="splitControlLeft">
    <div class="split-control-handle" id="splitControlLeftHandle"></div>
    <div class="split-control-buttons">
      <button class="split-btn" id="splitBtnUpLeft" title="Up" style="grid-column: 2; grid-row: 1;"><span class="material-icons">arrow_upward</span></button>
      <button class="split-btn" id="splitBtnDownLeft" title="Down" style="grid-column: 2; grid-row: 2;"><span class="material-icons">arrow_downward</span></button>
      <button class="split-btn" id="splitBtnLeft" title="Left" style="grid-column: 1; grid-row: 1; margin-top: 30px"><span class="material-icons">arrow_back</span></button>
    </div>
  </div>
  <div class="split-control" id="splitControlRight">
    <div class="split-control-handle" id="splitControlRightHandle"></div>
    <div class="split-control-buttons">
      <button class="split-btn" id="splitBtnUpRight" title="Up" style="grid-column: 1; grid-row: 1;"><span class="material-icons">arrow_upward</span></button>
      <button class="split-btn" id="splitBtnDownRight" title="Down" style="grid-column: 1; grid-row: 2;"><span class="material-icons">arrow_downward</span></button>
      <button class="split-btn" id="splitBtnRight" title="Right" style="grid-column: 2; grid-row: 1; margin-top: 30px;"><span class="material-icons">arrow_forward</span></button>
    </div>
  </div>
  <div id="gameOver">
    <div class="game-over-content">
      <div class="flatlined-text">FLATLINED</div>
      <div class="game-over-subtitle">SYSTEM FAILURE DETECTED</div>
      <div class="final-score">
        Final Score: <span id="finalScore">0</span>
      </div>
      <button id="restartGame">REBOOT SYSTEM</button>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highscoreEl = document.getElementById('highscore');
    const restartBtn = document.getElementById('restart');
    const gameOverEl = document.getElementById('gameOver');
    const finalScoreEl = document.getElementById('finalScore');
    const restartGameBtn = document.getElementById('restartGame');
    const startGameBtn = document.getElementById('startGame');

    // Game constants
    const GRID_SIZE = 20;
    const CELL_SIZE = 20;
    const INITIAL_SPEED = 150; // milliseconds per move (constant speed)

    // Game state
    let snake = [{ x: 0, y: 0 }]; // Start at top left
    let direction = { x: 1, y: 0 };
    let nextDirection = { x: 1, y: 0 };
    let directionQueue = []; // Queue to capture rapid key presses
    let food = [{ x: 4, y: 0, type: null }]; // Array of food items - initial food at cell 4 in top row for immediate catch (type will be set in draw)
    let score = 10; // Snake starts with 1 segment = 10 points
    let highscore = parseInt(localStorage.getItem('snakeHighscore') || '0', 10) || 0;
    let gameRunning = false;
    let gameOver = false;
    let gamePaused = false;
    let gameLoop = null;
    let currentSpeed = INITIAL_SPEED;
    let lastMoveTime = 0;
    let animationFrameId = null;
    let hyperSpeedLoopId = null;
    let autodriveActive = false;
    let autodriveSpeed = 1.0;
    let tongueAnimation = 0; // 0 to 1, cycles for tongue animation
    let scalePattern = null; // Cached scale pattern for performance
    let eyeBlinkState = 0; // 0 = open, 1 = fully closed, animates between
    let nextBlinkTime = 0; // When the next blink should start

    // Responsive canvas sizing
    function getCanvasSize() {
      const maxSize = 500;
      const isMobile = window.innerWidth <= 768;
      if (isMobile) {
        const viewportWidth = window.innerWidth - 40;
        const viewportHeight = window.innerHeight - 300;
        return Math.min(viewportWidth, viewportHeight, maxSize);
      }
      return maxSize;
    }

    let logicalSize = getCanvasSize();
    const scale = window.devicePixelRatio || 1;
    let cellSize = Math.floor(logicalSize / GRID_SIZE);
    let gridSize = GRID_SIZE;

    function resizeCanvas() {
      logicalSize = getCanvasSize();
      if (logicalSize < 200) logicalSize = 200;
      
      cellSize = Math.floor(logicalSize / GRID_SIZE);
      const actualSize = cellSize * GRID_SIZE;
      
      canvas.width = actualSize * scale;
      canvas.height = actualSize * scale;
      canvas.style.width = actualSize + 'px';
      canvas.style.height = actualSize + 'px';
      ctx.setTransform(scale, 0, 0, scale, 0, 0);
      
      if (gameRunning || gameOver) {
        draw();
      }
    }

    resizeCanvas();
    window.addEventListener('resize', () => {
      setTimeout(resizeCanvas, 150);
      // Reposition controls if in relative or split mode and not manually positioned
      if (controlMode === 'relative') {
        setTimeout(() => {
          positionRelativeControlsAtBottom();
        }, 200);
      } else if (controlMode === 'split') {
        setTimeout(() => {
          positionSplitControlsOnSides();
        }, 200);
      }
    });
    window.addEventListener('orientationchange', () => {
      setTimeout(resizeCanvas, 100);
      // Reposition controls if in relative or split mode and not manually positioned
      if (controlMode === 'relative') {
        setTimeout(() => {
          positionRelativeControlsAtBottom();
        }, 200);
      } else if (controlMode === 'split') {
        setTimeout(() => {
          positionSplitControlsOnSides();
        }, 200);
      }
    });

    // Sound Manager
    const SoundManager = {
      audioContext: null,
      masterGain: null,
      enabled: true,
      hasUserInteracted: false,
      noteIndex: 0, // Track current note in sequence for musical patterns
      
      // Musical scale (pentatonic scale in C major) - sounds pleasing in any order
      // C, D, E, G, A, C (octave)
      musicalScale: [261.63, 293.66, 329.63, 392.00, 440.00, 523.25],
      
      init() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          // Create master gain node for better control and to prevent clipping
          this.masterGain = this.audioContext.createGain();
          this.masterGain.gain.value = 0.9; // Slight headroom to prevent clipping
          this.masterGain.connect(this.audioContext.destination);
          
          const soundPref = localStorage.getItem('soundEnabled');
          this.enabled = soundPref === null ? true : soundPref === 'true';
          this.updateButton();
        } catch (e) {
          console.warn('Web Audio API not supported:', e);
          this.enabled = false;
        }
      },
      
      getNextNote() {
        const note = this.musicalScale[this.noteIndex];
        this.noteIndex = (this.noteIndex + 1) % this.musicalScale.length;
        return note;
      },
      
      resetSequence() {
        this.noteIndex = 0;
      },
      
      updateButton() {
        const soundBtn = document.getElementById('soundBtn');
        if (soundBtn) {
          const icon = soundBtn.querySelector('.material-icons');
          if (icon) {
            if (this.enabled) {
              soundBtn.classList.remove('muted');
              icon.textContent = 'volume_up';
            } else {
              soundBtn.classList.add('muted');
              icon.textContent = 'volume_off';
            }
          }
        }
      },
      
      async ensureResumed() {
        if (!this.audioContext) return;
        if (this.audioContext.state === 'suspended') {
          if (!this.hasUserInteracted) return;
          try {
            await this.audioContext.resume();
          } catch (e) {}
        }
      },
      
      toggle() {
        this.enabled = !this.enabled;
        localStorage.setItem('soundEnabled', this.enabled.toString());
        this.updateButton();
        if (this.enabled) {
          this.playDirectionChange();
        }
      },
      
      activeOscillators: [],
      
      playTone(frequency, duration, type = 'sine', volume = 0.3) {
        if (!this.enabled || !this.audioContext || !this.masterGain) return;
        if (this.audioContext.state === 'suspended' && !this.hasUserInteracted) return;
        
        // Ensure audio context is resumed (non-blocking)
        this.ensureResumed().catch(() => {});
        
        // Play immediately - Web Audio API is already non-blocking
        try {
          if (this.audioContext.state === 'suspended') return;
          
          const now = this.audioContext.currentTime;
          const startTime = now + 0.01; // Longer delay to ensure gain envelope is set before oscillator starts
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          
          // Connect through master gain for better control
          oscillator.connect(gainNode);
          gainNode.connect(this.masterGain);
          
          oscillator.type = type;
          oscillator.frequency.setValueAtTime(frequency, startTime);
          
          // Smooth envelope with exponential curves to prevent clicks/pops
          const attackTime = 0.02; // Longer attack (20ms) for smooth, click-free start
          const releaseTime = Math.min(0.02, duration * 0.3); // Release time (20ms or 30% of duration)
          const sustainTime = Math.max(0, duration - attackTime - releaseTime);
          
          // Set initial gain BEFORE oscillator starts to prevent clicks
          // Use a very small value (exponential ramps can't start from 0)
          const initialGain = 0.00001;
          gainNode.gain.setValueAtTime(initialGain, now); // Set immediately, before startTime
          
          // Smooth attack using exponential ramp
          gainNode.gain.exponentialRampToValueAtTime(volume, startTime + attackTime);
          
          // Sustain
          if (sustainTime > 0) {
            gainNode.gain.setValueAtTime(volume, startTime + attackTime + sustainTime);
          }
          
          // Smooth release using exponential ramp
          gainNode.gain.exponentialRampToValueAtTime(initialGain, startTime + duration);
          
          oscillator.start(startTime);
          oscillator.stop(startTime + duration + 0.01); // Small buffer for cleanup
          
          // Track active oscillators for potential cleanup
          this.activeOscillators.push(oscillator);
          oscillator.onended = () => {
            const index = this.activeOscillators.indexOf(oscillator);
            if (index > -1) {
              this.activeOscillators.splice(index, 1);
            }
            // Clean up nodes
            try {
              oscillator.disconnect();
              gainNode.disconnect();
            } catch (e) {}
          };
        } catch (e) {
          // Silently fail
        }
      },
      
      playDirectionChange() {
        // Simple tick sound for direction changes
        this.ensureResumed().catch(() => {});
        this.playTone(800, 0.05, 'sine', 0.15);
      },
      
      playEat() {
        // Two-tone ascending cyber beep for eating snacks
        this.ensureResumed().catch(() => {});
        this.playTone(500, 0.08, 'sine', 0.2);
        setTimeout(() => {
          this.playTone(700, 0.08, 'sine', 0.2);
        }, 50);
      },
      
      playInvalidMove() {
        // Simple short error beep for invalid moves
        if (!this.enabled || !this.audioContext) return;
        
        // Mark user interaction if not already marked (for error sounds)
        if (!this.hasUserInteracted) {
          this.hasUserInteracted = true;
        }
        
        this.ensureResumed().catch(() => {});
        this.playTone(300, 0.06, 'sine', 0.12);
      },
      
      playGameOver() {
        // Non-blocking sound
        this.ensureResumed().catch(() => {});
        const frequencies = [300, 250, 200, 150];
        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            this.playTone(freq, 0.2, 'sine', 0.3);
          }, index * 100);
        });
      },
      
      playGlitch() {
        // Non-blocking sound
        this.ensureResumed().catch(() => {});
        const frequencies = [200, 150, 250, 180];
        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            this.playTone(freq, 0.08, 'square', 0.15);
          }, index * 30);
        });
      },
      
      playPause() {
        // Simple pause beep
        this.ensureResumed().catch(() => {});
        this.playTone(400, 0.06, 'sine', 0.15);
      },
      
      playReboot() {
        // Simple reboot beep - different from pause
        this.ensureResumed().catch(() => {});
        this.playTone(350, 0.05, 'sine', 0.15);
      },
      
      playVictory() {
        // Simple victory sound - ascending three-tone beep
        this.ensureResumed().catch(() => {});
        this.playTone(500, 0.1, 'sine', 0.2);
        setTimeout(() => {
          this.playTone(650, 0.1, 'sine', 0.2);
          setTimeout(() => {
            this.playTone(800, 0.12, 'sine', 0.2);
          }, 60);
        }, 60);
      }
    };
    
    SoundManager.init();

    // Resume audio context on first user interaction
    let audioContextResumed = false;
    function resumeAudioOnInteraction() {
      if (!audioContextResumed && SoundManager.audioContext) {
        audioContextResumed = true;
        SoundManager.hasUserInteracted = true;
        SoundManager.ensureResumed().catch(() => {});
      }
    }
    
    document.addEventListener('touchstart', resumeAudioOnInteraction, { once: true, passive: true, capture: true });
    document.addEventListener('click', resumeAudioOnInteraction, { once: true, capture: true });
    document.addEventListener('keydown', resumeAudioOnInteraction, { once: true, capture: true });
    window.addEventListener('touchstart', resumeAudioOnInteraction, { once: true, passive: true, capture: true });
    window.addEventListener('click', resumeAudioOnInteraction, { once: true, capture: true });

    // Food types with different shapes and colors (same size)
    const foodTypes = [
      { shape: 'circle', size: 0.7, color: '#ffeb3b', glowColor: 'rgba(255, 235, 59, 0.8)' }, // Yellow circle
      { shape: 'square', size: 0.7, color: '#ff6b35', glowColor: 'rgba(255, 107, 53, 0.8)' }, // Orange square
      { shape: 'diamond', size: 0.7, color: '#00f5ff', glowColor: 'rgba(0, 245, 255, 0.8)' }, // Cyan diamond
      { shape: 'star', size: 0.7, color: '#ff0040', glowColor: 'rgba(255, 0, 64, 0.8)' }, // Red star
      { shape: 'triangle', size: 0.7, color: '#9664ff', glowColor: 'rgba(150, 100, 255, 0.8)' }, // Purple triangle
      { shape: 'hexagon', size: 0.7, color: '#00ff88', glowColor: 'rgba(0, 255, 136, 0.8)' }, // Green hexagon
      { shape: 'plus', size: 0.7, color: '#ffaa00', glowColor: 'rgba(255, 170, 0, 0.8)' }, // Orange plus
      { shape: 'circle', size: 0.7, color: '#ff00ff', glowColor: 'rgba(255, 0, 255, 0.8)' }, // Magenta circle
      { shape: 'square', size: 0.7, color: '#00ffff', glowColor: 'rgba(0, 255, 255, 0.8)' }, // Aqua square
      { shape: 'diamond', size: 0.7, color: '#ffff00', glowColor: 'rgba(255, 255, 0, 0.8)' } // Yellow diamond
    ];
    
    function generateFood() {
      let newFood;
      do {
        newFood = {
          x: Math.floor(Math.random() * GRID_SIZE),
          y: Math.floor(Math.random() * GRID_SIZE),
          type: foodTypes[Math.floor(Math.random() * foodTypes.length)] // Random food type
        };
      } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
               food.some(f => f.x === newFood.x && f.y === newFood.y));
      return newFood;
    }
    
    // Add food items to the board (for autodrive mode)
    function addFood(count) {
      if (!gameRunning || gameOver) return;
      
      for (let i = 0; i < count; i++) {
        // Don't add food if we're at max score
        if (score >= 4000) break;
        const newFood = generateFood();
        food.push(newFood);
      }
      draw();
    }

    function updateScores() {
      // Update highscore first if current score is higher
      if (score > highscore) {
        highscore = score;
        try {
          localStorage.setItem('snakeHighscore', String(highscore));
        } catch (e) {}
      }
      
      // Then update the display with the current values
      if (scoreEl) scoreEl.textContent = score;
      if (highscoreEl) highscoreEl.textContent = highscore;
    }

    function draw() {
      // Clear canvas completely to remove any ghosting
      ctx.clearRect(0, 0, canvas.width / scale, canvas.height / scale);
      
      // Reset all shadow properties
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      
      // Draw background
      ctx.fillStyle = 'rgba(10, 10, 30, 0.3)';
      ctx.fillRect(0, 0, canvas.width / scale, canvas.height / scale);

      // Draw grid (subtle)
      ctx.strokeStyle = 'rgba(0, 245, 255, 0.1)';
      ctx.lineWidth = 0.5;
      for (let i = 0; i <= GRID_SIZE; i++) {
        const pos = i * cellSize;
        ctx.beginPath();
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, GRID_SIZE * cellSize);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, pos);
        ctx.lineTo(GRID_SIZE * cellSize, pos);
        ctx.stroke();
      }

      // Draw all food items with different shapes, sizes, and colors
      if (!Array.isArray(food)) {
        // Safety check: ensure food is an array
        food = [{ x: 4, y: 0, type: foodTypes[0] }];
      }
      for (const foodItem of food) {
        const foodX = foodItem.x * cellSize;
        const foodY = foodItem.y * cellSize;
        const centerX = foodX + cellSize / 2;
        const centerY = foodY + cellSize / 2;
        
        // Get food type (assign random type if not set, for backwards compatibility)
        let foodType = foodItem.type;
        if (!foodType) {
          foodType = foodTypes[Math.floor(Math.random() * foodTypes.length)];
          foodItem.type = foodType; // Cache it for next draw
        }
        const size = cellSize * foodType.size;
        const halfSize = size / 2;
        
        // Outer glow
        const foodGradient = ctx.createRadialGradient(
          centerX, centerY, 0,
          centerX, centerY, cellSize / 2
        );
        foodGradient.addColorStop(0, foodType.glowColor);
        foodGradient.addColorStop(0.5, foodType.glowColor.replace('0.8', '0.4'));
        foodGradient.addColorStop(1, foodType.glowColor.replace('0.8', '0'));
        ctx.fillStyle = foodGradient;
        ctx.fillRect(foodX, foodY, cellSize, cellSize);
        
        // Draw food shape
        ctx.fillStyle = foodType.color;
        ctx.shadowColor = foodType.color;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        
        switch (foodType.shape) {
          case 'circle':
            ctx.arc(centerX, centerY, halfSize, 0, Math.PI * 2);
            break;
          case 'square':
            ctx.fillRect(centerX - halfSize, centerY - halfSize, size, size);
            break;
          case 'diamond':
            ctx.moveTo(centerX, centerY - halfSize);
            ctx.lineTo(centerX + halfSize, centerY);
            ctx.lineTo(centerX, centerY + halfSize);
            ctx.lineTo(centerX - halfSize, centerY);
            ctx.closePath();
            break;
          case 'star':
            const starPoints = 5;
            const outerRadius = halfSize;
            const innerRadius = halfSize * 0.5;
            for (let i = 0; i < starPoints * 2; i++) {
              const angle = (Math.PI * i) / starPoints - Math.PI / 2;
              const radius = i % 2 === 0 ? outerRadius : innerRadius;
              const x = centerX + Math.cos(angle) * radius;
              const y = centerY + Math.sin(angle) * radius;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            break;
          case 'triangle':
            ctx.moveTo(centerX, centerY - halfSize);
            ctx.lineTo(centerX + halfSize, centerY + halfSize);
            ctx.lineTo(centerX - halfSize, centerY + halfSize);
            ctx.closePath();
            break;
          case 'hexagon':
            const hexPoints = 6;
            for (let i = 0; i < hexPoints; i++) {
              const angle = (Math.PI * 2 * i) / hexPoints - Math.PI / 2;
              const x = centerX + Math.cos(angle) * halfSize;
              const y = centerY + Math.sin(angle) * halfSize;
              if (i === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            }
            ctx.closePath();
            break;
          case 'plus':
            const plusWidth = halfSize * 0.3;
            const plusLength = halfSize * 0.7;
            // Horizontal bar
            ctx.fillRect(centerX - plusLength, centerY - plusWidth, plusLength * 2, plusWidth * 2);
            // Vertical bar
            ctx.fillRect(centerX - plusWidth, centerY - plusLength, plusWidth * 2, plusLength * 2);
            break;
        }
        
        if (foodType.shape !== 'square' && foodType.shape !== 'plus') {
          ctx.fill();
        }
      }
      // Reset shadow after food
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;

      // Draw snake as a solid curved path
      const snakeLength = snake.length;
      if (snakeLength === 0) return;
      
      // Calculate center points for each segment (using actual grid positions)
      const centers = snake.map(segment => ({
        x: segment.x * cellSize + cellSize / 2,
        y: segment.y * cellSize + cellSize / 2,
        gridX: segment.x,
        gridY: segment.y
      }));
      
      const canvasSize = GRID_SIZE * cellSize;
      const radius = cellSize * 0.4; // Snake body radius
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      // Helper function to detect if two segments wrap around an edge
      function detectWrap(p1, p2) {
        const dx = p2.gridX - p1.gridX;
        const dy = p2.gridY - p1.gridY;
        
        // Check for horizontal wrap
        // If the absolute difference is more than half the grid size, it wrapped
        // Also check if segments are at opposite edges (0 and GRID_SIZE-1)
        const wrapsX = Math.abs(dx) > GRID_SIZE / 2 || 
                       (Math.abs(dx) === GRID_SIZE - 1 && (p1.gridX === 0 || p2.gridX === 0));
        
        // Check for vertical wrap
        const wrapsY = Math.abs(dy) > GRID_SIZE / 2 || 
                       (Math.abs(dy) === GRID_SIZE - 1 && (p1.gridY === 0 || p2.gridY === 0));
        
        return { wrapsX, wrapsY };
      }
      
      // Split snake into continuous segments at wrap points
      const segments = [];
      let currentSegment = [centers[0]];
      
      for (let i = 1; i < centers.length; i++) {
        const prev = centers[i - 1];
        const curr = centers[i];
        const wrap = detectWrap(prev, curr);
        
        if (wrap.wrapsX || wrap.wrapsY) {
          // Wrap detected - close current segment and start new one
          if (currentSegment.length > 0) {
            segments.push(currentSegment);
          }
          currentSegment = [curr];
        } else {
          // No wrap - continue current segment
          currentSegment.push(curr);
        }
      }
      
      // Add the last segment
      if (currentSegment.length > 0) {
        segments.push(currentSegment);
      }
      
      // Create scale pattern overlay (cached for performance)
      if (!scalePattern) {
        const patternSize = Math.max(cellSize * 0.5, 16); // Larger pattern for less repetition
        const patternCanvas = document.createElement('canvas');
        patternCanvas.width = patternSize;
        patternCanvas.height = patternSize;
        const patternCtx = patternCanvas.getContext('2d');
        
        // Draw subtle snake scale pattern - diamond/hexagonal shapes
        patternCtx.fillStyle = 'rgba(0, 0, 0, 0.1)'; // Subtle dark overlay
        patternCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)'; // Subtle border
        patternCtx.lineWidth = 1;
        
        const scaleWidth = patternSize * 0.6;
        const scaleHeight = patternSize * 0.5;
        const rowOffset = scaleWidth * 0.5; // Stagger rows for snake skin effect
        
        // Draw scales in rows with offset (like real snake skin)
        for (let row = 0; row < 3; row++) {
          const y = row * scaleHeight * 0.7;
          const rowStartX = (row % 2 === 0) ? 0 : rowOffset; // Alternate row offset
          
          for (let col = 0; col < 3; col++) {
            const x = rowStartX + col * scaleWidth;
            
            // Draw diamond/hexagonal scale shape (more like snake scales)
            patternCtx.beginPath();
            const centerX = x + scaleWidth / 2;
            const centerY = y + scaleHeight / 2;
            
            // Create diamond shape with rounded corners
            const points = 4;
            for (let i = 0; i < points; i++) {
              const angle = (Math.PI * 2 * i) / points - Math.PI / 4; // Rotate 45 degrees
              const px = centerX + Math.cos(angle) * scaleWidth * 0.35;
              const py = centerY + Math.sin(angle) * scaleHeight * 0.35;
              
              if (i === 0) {
                patternCtx.moveTo(px, py);
              } else {
                patternCtx.lineTo(px, py);
              }
            }
            patternCtx.closePath();
            patternCtx.fill();
            patternCtx.stroke();
          }
        }
        
        scalePattern = ctx.createPattern(patternCanvas, 'repeat');
      }
      
      // Draw each segment separately
      for (let segIdx = 0; segIdx < segments.length; segIdx++) {
        const segment = segments[segIdx];
        if (segment.length === 0) continue;
        
        // Build path for this segment
        const segmentPath = new Path2D();
        segmentPath.moveTo(segment[0].x, segment[0].y);
        
        for (let i = 1; i < segment.length; i++) {
          const prev = segment[i - 1];
          const curr = segment[i];
          const next = i < segment.length - 1 ? segment[i + 1] : null;
          
          if (next) {
            // Calculate direction vectors
            const dir1 = { x: curr.x - prev.x, y: curr.y - prev.y };
            const dir2 = { x: next.x - curr.x, y: next.y - curr.y };
            
            // Normalize direction vectors
            const len1 = Math.sqrt(dir1.x * dir1.x + dir1.y * dir1.y);
            const len2 = Math.sqrt(dir2.x * dir2.x + dir2.y * dir2.y);
            
            if (len1 > 0 && len2 > 0) {
              dir1.x /= len1;
              dir1.y /= len1;
              dir2.x /= len2;
              dir2.y /= len2;
              
              // Check if turning (not going straight)
              const dot = dir1.x * dir2.x + dir1.y * dir2.y;
              const isTurning = dot < 0.99; // Not perfectly aligned
              
              if (isTurning) {
                // Draw curve at corner
                const curveRadius = Math.min(radius * 0.6, cellSize * 0.3);
                const cornerX = curr.x - dir1.x * curveRadius;
                const cornerY = curr.y - dir1.y * curveRadius;
                const cornerX2 = curr.x + dir2.x * curveRadius;
                const cornerY2 = curr.y + dir2.y * curveRadius;
                
                segmentPath.lineTo(cornerX, cornerY);
                segmentPath.quadraticCurveTo(curr.x, curr.y, cornerX2, cornerY2);
              } else {
                // Straight line
                segmentPath.lineTo(curr.x, curr.y);
              }
            } else {
              segmentPath.lineTo(curr.x, curr.y);
            }
          } else {
            // Last segment - just line to tail
            segmentPath.lineTo(curr.x, curr.y);
          }
        }
        
        // Create gradient for this segment
        const segmentStart = segment[0];
        const segmentEnd = segment[segment.length - 1];
        const gradient = ctx.createLinearGradient(
          segmentStart.x, segmentStart.y,
          segmentEnd.x, segmentEnd.y
        );
        
        // Calculate position in overall snake for gradient colors
        const segmentStartIdx = segIdx === 0 ? 0 : segments.slice(0, segIdx).reduce((sum, s) => sum + s.length, 0);
        const segmentEndIdx = segmentStartIdx + segment.length - 1;
        const headPos = 0;
        const tailPos = snakeLength - 1;
        const startRatio = tailPos > 0 ? segmentStartIdx / tailPos : 0;
        const endRatio = tailPos > 0 ? segmentEndIdx / tailPos : 0;
        
        // Interpolate colors based on position in snake
        const headColor = '#00f5ff'; // Cyan
        const midColor = '#00aacc'; // Darker cyan
        const tailColor = '#9664ff'; // Purple
        
        if (startRatio < 0.5) {
          const t = startRatio * 2;
          const startColor = interpolateColor(headColor, midColor, t);
          gradient.addColorStop(0, startColor);
        } else {
          const t = (startRatio - 0.5) * 2;
          const startColor = interpolateColor(midColor, tailColor, t);
          gradient.addColorStop(0, startColor);
        }
        
        if (endRatio < 0.5) {
          const t = endRatio * 2;
          const endColor = interpolateColor(headColor, midColor, t);
          gradient.addColorStop(1, endColor);
        } else {
          const t = (endRatio - 0.5) * 2;
          const endColor = interpolateColor(midColor, tailColor, t);
          gradient.addColorStop(1, endColor);
        }
        
        // Draw the segment body with gradient
        ctx.strokeStyle = gradient;
        ctx.lineWidth = radius * 2;
        ctx.shadowColor = 'rgba(0, 245, 255, 0.5)';
        ctx.shadowBlur = 8;
        ctx.stroke(segmentPath);
        
        // Apply scale pattern overlay to snake body
        ctx.save();
        ctx.globalCompositeOperation = 'multiply'; // Blend with gradient
        ctx.strokeStyle = scalePattern;
        ctx.lineWidth = radius * 2;
        ctx.shadowBlur = 0; // No shadow on pattern overlay
        ctx.stroke(segmentPath); // Reuse the same path
        ctx.restore();
        
        // Draw connection at wrap points (draw segment on both sides of wrap)
        if (segIdx < segments.length - 1) {
          const currentEnd = segment[segment.length - 1];
          const nextStart = segments[segIdx + 1][0];
          const wrap = detectWrap(currentEnd, nextStart);
          
          if (wrap.wrapsX || wrap.wrapsY) {
            // Draw the connecting segment on both sides of the wrap
            const wrapPath = new Path2D();
            
            // Calculate wrap exit point (on current segment's edge)
            let exitX = currentEnd.x;
            let exitY = currentEnd.y;
            let entryX = nextStart.x;
            let entryY = nextStart.y;
            
            if (wrap.wrapsX) {
              // Horizontal wrap - draw on left and right edges
              if (currentEnd.gridX > nextStart.gridX) {
                // Wrapped from right to left
                exitX = canvasSize;
                entryX = 0;
              } else {
                // Wrapped from left to right
                exitX = 0;
                entryX = canvasSize;
              }
              exitY = currentEnd.y;
              entryY = nextStart.y;
            }
            
            if (wrap.wrapsY) {
              // Vertical wrap - draw on top and bottom edges
              if (currentEnd.gridY > nextStart.gridY) {
                // Wrapped from bottom to top
                exitY = canvasSize;
                entryY = 0;
              } else {
                // Wrapped from top to bottom
                exitY = 0;
                entryY = canvasSize;
              }
              exitX = currentEnd.x;
              entryX = nextStart.x;
            }
            
            // Draw connecting path on exit side
            wrapPath.moveTo(currentEnd.x, currentEnd.y);
            wrapPath.lineTo(exitX, exitY);
            
            // Draw connecting path on entry side
            wrapPath.moveTo(entryX, entryY);
            wrapPath.lineTo(nextStart.x, nextStart.y);
            
            // Use color from the middle of the snake for wrap connections
            const wrapGradient = ctx.createLinearGradient(exitX, exitY, entryX, entryY);
            wrapGradient.addColorStop(0, midColor);
            wrapGradient.addColorStop(1, midColor);
            
            ctx.strokeStyle = wrapGradient;
            ctx.lineWidth = radius * 2;
            ctx.shadowColor = 'rgba(0, 245, 255, 0.5)';
            ctx.shadowBlur = 8;
            ctx.stroke(wrapPath);
            
            // Apply scale pattern to wrap
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.strokeStyle = scalePattern;
            ctx.lineWidth = radius * 2;
            ctx.shadowBlur = 0;
            ctx.stroke(wrapPath);
            ctx.restore();
          }
        }
      }
      
      // Helper function to interpolate between two hex colors
      function interpolateColor(color1, color2, t) {
        const c1 = hexToRgb(color1);
        const c2 = hexToRgb(color2);
        const r = Math.round(c1.r + (c2.r - c1.r) * t);
        const g = Math.round(c1.g + (c2.g - c1.g) * t);
        const b = Math.round(c1.b + (c2.b - c1.b) * t);
        return `rgb(${r}, ${g}, ${b})`;
      }
      
      function hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
      }
      
      // Draw rounded tail cap
      const tailSegment = segments[segments.length - 1];
      if (tailSegment && tailSegment.length > 1) {
        const tailX = tailSegment[tailSegment.length - 1].x;
        const tailY = tailSegment[tailSegment.length - 1].y;
        const prevTail = tailSegment[tailSegment.length - 2];
        
        // Calculate tail direction for proper positioning
        const dirX = tailX - prevTail.x;
        const dirY = tailY - prevTail.y;
        const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
        
        if (dirLen > 0) {
          const tailDir = { x: dirX / dirLen, y: dirY / dirLen };
          
          // Position tail cap slightly back along the path to overlap with the stroke
          const overlap = radius * 0.3; // Overlap with the path
          const tailCapX = tailX - (tailDir.x * overlap);
          const tailCapY = tailY - (tailDir.y * overlap);
          
          // Create radial gradient for seamless blending
          const tailGradient = ctx.createRadialGradient(
            tailCapX, tailCapY, 0,
            tailCapX, tailCapY, radius
          );
          tailGradient.addColorStop(0, '#9664ff'); // Center - tail purple
          tailGradient.addColorStop(0.7, '#9664ff'); // Most of the circle
          tailGradient.addColorStop(1, '#9664ff'); // Edge matches path color
          
          // Draw tail cap with gradient
          ctx.save();
          ctx.fillStyle = tailGradient;
          ctx.shadowColor = 'rgba(150, 100, 255, 0.3)';
          ctx.shadowBlur = 4;
          ctx.beginPath();
          ctx.arc(tailCapX, tailCapY, radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Apply scale pattern overlay to tail cap for consistency
          ctx.globalCompositeOperation = 'multiply';
          ctx.fillStyle = scalePattern;
          ctx.fill();
          ctx.restore();
        }
      } else if (tailSegment && tailSegment.length === 1) {
        // Single segment - just draw a circle at the tail
        const tailX = tailSegment[0].x;
        const tailY = tailSegment[0].y;
        ctx.save();
        ctx.fillStyle = '#9664ff';
        ctx.shadowColor = 'rgba(150, 100, 255, 0.3)';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(tailX, tailY, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = 'multiply';
        ctx.fillStyle = scalePattern;
        ctx.fill();
        ctx.restore();
      }
      
      // Draw head with top-down view
      const headSegment = segments[0];
      const headX = headSegment[0].x;
      const headY = headSegment[0].y;
      const headRadius = radius;
      
      // Calculate head direction for tongue
      let headDir = { x: 1, y: 0 };
      if (headSegment.length > 1) {
        const dirX = headSegment[0].x - headSegment[1].x;
        const dirY = headSegment[0].y - headSegment[1].y;
        const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
        if (dirLen > 0) {
          headDir = { x: dirX / dirLen, y: dirY / dirLen };
        }
      } else if (segments.length > 1 && segments[1].length > 0) {
        // If head is a single segment, use direction to next segment
        const nextSegment = segments[1];
        const dirX = nextSegment[0].x - headSegment[0].x;
        const dirY = nextSegment[0].y - headSegment[0].y;
        const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
        if (dirLen > 0) {
          headDir = { x: dirX / dirLen, y: dirY / dirLen };
        }
      }
      
      // Draw head body (circular, top-down view)
      ctx.fillStyle = '#00f5ff';
      ctx.shadowColor = '#00f5ff';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw eyes (top-down view - snake eyes, elliptical/oval, vertical)
      ctx.fillStyle = '#ffffff'; // White eyes
      ctx.shadowBlur = 0;
      const eyeWidth = headRadius * 0.25; // Horizontal radius (narrower)
      const eyeHeight = headRadius * 0.4; // Vertical radius (taller, vertical snake eyes)
      const eyeOffsetX = headRadius * 0.35;
      const eyeOffsetY = -headRadius * 0.2;
      
      // Draw eyes with blinking animation
      if (eyeBlinkState > 0) {
        // Eyes are blinking - draw as horizontal lines (closed)
        const closedHeight = eyeHeight * (1 - eyeBlinkState); // Animate from full height to 0
        ctx.fillStyle = '#ffffff';
        // Left eye (closed - horizontal line)
        ctx.fillRect(headX - eyeOffsetX - eyeWidth, headY + eyeOffsetY - closedHeight / 2, eyeWidth * 2, closedHeight);
        // Right eye (closed - horizontal line)
        ctx.fillRect(headX + eyeOffsetX - eyeWidth, headY + eyeOffsetY - closedHeight / 2, eyeWidth * 2, closedHeight);
      } else {
        // Eyes are open - draw normally
        // Left eye (elliptical, vertical)
        ctx.beginPath();
        ctx.ellipse(headX - eyeOffsetX, headY + eyeOffsetY, eyeWidth, eyeHeight, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Right eye (elliptical, vertical)
        ctx.beginPath();
        ctx.ellipse(headX + eyeOffsetX, headY + eyeOffsetY, eyeWidth, eyeHeight, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw pupils (black, vertical slit-like) - only when eyes are open
        ctx.fillStyle = '#000000';
        const pupilWidth = eyeWidth * 0.5;
        const pupilHeight = eyeHeight * 0.6;
        ctx.beginPath();
        ctx.ellipse(headX - eyeOffsetX, headY + eyeOffsetY, pupilWidth, pupilHeight, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(headX + eyeOffsetX, headY + eyeOffsetY, pupilWidth, pupilHeight, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Animate tongue (appears and disappears completely)
      tongueAnimation += 0.02; // Slower animation
      if (tongueAnimation > Math.PI * 2) {
        tongueAnimation = 0;
      }
      
      // Animate eye blinking
      const currentTime = performance.now();
      if (nextBlinkTime === 0) {
        // Initialize first blink time (random between 2-5 seconds from now)
        nextBlinkTime = currentTime + 2000 + Math.random() * 3000;
      }
      
      if (currentTime >= nextBlinkTime) {
        // Start blinking
        const blinkDuration = 150; // Blink lasts 150ms
        const timeSinceBlinkStart = currentTime - nextBlinkTime;
        
        if (timeSinceBlinkStart < blinkDuration) {
          // Animate blink (smooth close and open)
          const blinkProgress = timeSinceBlinkStart / blinkDuration;
          // Use a smooth curve: close quickly, open quickly
          if (blinkProgress < 0.5) {
            // Closing (0 to 1)
            eyeBlinkState = blinkProgress * 2;
          } else {
            // Opening (1 to 0)
            eyeBlinkState = 2 - (blinkProgress * 2);
          }
        } else {
          // Blink finished, schedule next one
          eyeBlinkState = 0;
          nextBlinkTime = currentTime + 2000 + Math.random() * 3000; // Next blink in 2-5 seconds
        }
      }
      
      // Tongue only shows when sin is positive (about half the time)
      const tongueVisible = Math.sin(tongueAnimation) > 0;
      
      if (tongueVisible) {
        // Draw simple line tongue in direction of movement
        const tongueLength = headRadius * 0.8;
        const tongueBaseX = headX + headDir.x * headRadius * 0.8;
        const tongueBaseY = headY + headDir.y * headRadius * 0.8;
        const tongueTipX = tongueBaseX + headDir.x * tongueLength;
        const tongueTipY = tongueBaseY + headDir.y * tongueLength;
        
        // Create gradient from head color (cyan) to red
        const tongueGradient = ctx.createLinearGradient(
          tongueBaseX, tongueBaseY,
          tongueTipX, tongueTipY
        );
        tongueGradient.addColorStop(0, '#00f5ff'); // Cyan at base (blends with head)
        tongueGradient.addColorStop(0.3, '#ff6b9d'); // Pink transition
        tongueGradient.addColorStop(1, '#ff0040'); // Red at tip
        
        ctx.strokeStyle = tongueGradient;
        ctx.lineWidth = headRadius * 0.1;
        ctx.lineCap = 'round';
        
        // Simple line tongue
        ctx.beginPath();
        ctx.moveTo(tongueBaseX, tongueBaseY);
        ctx.lineTo(tongueTipX, tongueTipY);
        ctx.stroke();
      }
      
      // Tail is now part of the continuous path, no need for separate circle
      
      // Reset shadow properties
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
    }

    function moveSnake() {
      if (!gameRunning || gameOver || gamePaused) return;

      // Process direction queue for rapid key presses
      // The queue processes directions in order (FIFO) to handle rapid key presses correctly
      // Each move consumes one direction from the queue
      if (directionQueue.length > 0) {
        // Use the oldest direction from queue (first in, first out)
        nextDirection = directionQueue.shift();
      }
      // If queue is empty, nextDirection remains as the last set direction
      
      // Update direction from nextDirection
      direction = { ...nextDirection };

      // Calculate new head position
      const head = { ...snake[0] };
      head.x += direction.x;
      head.y += direction.y;

      // Wrap around walls
      if (head.x < 0) {
        head.x = GRID_SIZE - 1;
      } else if (head.x >= GRID_SIZE) {
        head.x = 0;
      }
      if (head.y < 0) {
        head.y = GRID_SIZE - 1;
      } else if (head.y >= GRID_SIZE) {
        head.y = 0;
      }

      // Check self collision
      if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        endGame();
        return;
      }

      snake.unshift(head);

      // Check food collision with all food items
      let ateFood = false;
      for (let i = food.length - 1; i >= 0; i--) {
        if (head.x === food[i].x && head.y === food[i].y) {
          // Remove this food item
          food.splice(i, 1);
          score += 10;
          updateScores();
          SoundManager.playEat();
          ateFood = true;
          
          // Check for victory (max score: 4000 = 400 cells * 10 points)
          if (score >= 4000) {
            victory();
            return;
          }
          
          // Generate new food if array is empty (but only if not at max score)
          if (food.length === 0 && score < 4000) {
            food.push(generateFood());
          }
          break;
        }
      }
      
      if (!ateFood) {
        snake.pop();
      }

      // Don't draw here - let the render loop handle it
    }

    // Smooth game loop using requestAnimationFrame
    function animationLoop(timestamp) {
      // Always render for smooth animations (even when paused or game over)
      if (gameRunning || gameOver) {
        draw();
      }

      // Update game logic based on speed (only when running and not paused)
      if (gameRunning && !gameOver && !gamePaused) {
        if (lastMoveTime === 0) {
          lastMoveTime = timestamp;
        }
        
        // Apply autodrive speed multiplier
        const effectiveSpeed = autodriveActive ? currentSpeed / autodriveSpeed : currentSpeed;
        
        const elapsed = timestamp - lastMoveTime;
        if (elapsed >= effectiveSpeed) {
          // Autodrive AI: calculate direction before moving
          if (autodriveActive) {
            const aiDirection = findPathToFood();
            if (aiDirection) {
              // Check if direction is actually changing
              const checkDir = directionQueue.length > 0 
                ? directionQueue[directionQueue.length - 1] 
                : nextDirection;
              const isDirectionChanging = aiDirection.x !== checkDir.x || aiDirection.y !== checkDir.y;
              
              // Clear queue and set AI direction
              directionQueue = [];
              nextDirection = aiDirection;
              
              // Play sound when direction changes
              if (isDirectionChanging) {
                SoundManager.playDirectionChange();
              }
            }
          }
          
          moveSnake();
          lastMoveTime = timestamp;
        }
      }

      // Continue the loop only if game is running or just ended
      if (gameRunning || gameOver) {
        animationFrameId = requestAnimationFrame(animationLoop);
      } else {
        animationFrameId = null;
      }
    }

    function startGame() {
      if (gameRunning) return;
      
      snake = [{ x: 0, y: 0 }]; // Start at top left
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      directionQueue = []; // Clear direction queue on restart
      // Don't regenerate food here - it should already be set at initialization
      // Food will only be regenerated when the snake eats it
      score = 10; // Snake starts with 1 segment = 10 points
      gameOver = false;
      gamePaused = false;
      gameRunning = true;
      currentSpeed = INITIAL_SPEED;
      lastMoveTime = 0;
      autodriveActive = false; // Reset autodrive on new game
      eyeBlinkState = 0; // Reset blink state
      nextBlinkTime = 0; // Reset blink timer
      
      // Reset musical sequence for a fresh start
      SoundManager.resetSequence();
      
      updateScores();
      hideGameOver();
      hideStartButton();
      updatePauseButton();
      if (autodriveBtn) autodriveBtn.classList.remove('active');
      if (autodrivePanel) autodrivePanel.classList.remove('show');
      draw();
      
      // Stop any existing loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Start smooth animation loop
      animationFrameId = requestAnimationFrame(animationLoop);
    }

    function togglePause() {
      if (!gameRunning || gameOver) return;
      
      gamePaused = !gamePaused;
      updatePauseButton();
      
      if (gamePaused) {
        SoundManager.playPause();
        // Keep rendering even when paused for smooth UI
      } else {
        lastMoveTime = performance.now();
      }
    }

    function updatePauseButton() {
      const pauseBtn = document.getElementById('pauseBtnTop');
      if (pauseBtn) {
        const icon = pauseBtn.querySelector('.material-icons');
        if (icon) {
          if (gamePaused) {
            icon.textContent = 'play_arrow';
            pauseBtn.title = 'Resume';
          } else {
            icon.textContent = 'pause';
            pauseBtn.title = 'Pause';
          }
        }
      }
    }

    function endGame() {
      if (!gameRunning) return;
      
      gameRunning = false;
      gameOver = true;
      
      // Stop animation loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Final render
      draw();
      
      // Ensure final score is saved to highscore
      updateScores();
      
      SoundManager.playGameOver();
      showGameOver();
      // Show start button after game over
      showStartButton();
    }
    
    function victory() {
      if (!gameRunning) return;
      
      gameRunning = false;
      gameOver = true;
      
      // Stop animation loop
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      if (hyperSpeedLoopId) {
        clearTimeout(hyperSpeedLoopId);
        hyperSpeedLoopId = null;
      }
      
      // Ensure score is exactly 4000
      score = 4000;
      updateScores();
      
      // Final render
      draw();
      
      // Play celebration sound
      SoundManager.playVictory();
      
      // Show victory message
      showVictory();
      // Show start button after victory
      showStartButton();
    }

    function showGameOver() {
      finalScoreEl.textContent = score;
      // Reset to normal game over message
      const flatlinedText = gameOverEl.querySelector('.flatlined-text');
      const subtitle = gameOverEl.querySelector('.game-over-subtitle');
      if (flatlinedText) {
        flatlinedText.textContent = 'FLATLINED';
        flatlinedText.classList.remove('perfect-score');
      }
      if (subtitle) {
        subtitle.textContent = 'SYSTEM FAILURE DETECTED';
        subtitle.classList.remove('perfect-score');
      }
      gameOverEl.classList.add('show');
    }
    
    function showVictory() {
      finalScoreEl.textContent = score;
      // Change to victory message
      const flatlinedText = gameOverEl.querySelector('.flatlined-text');
      const subtitle = gameOverEl.querySelector('.game-over-subtitle');
      if (flatlinedText) {
        flatlinedText.textContent = 'PERFECT SCORE';
        flatlinedText.classList.add('perfect-score');
      }
      if (subtitle) {
        subtitle.textContent = 'MAX SCORE OF 4000 ACHIEVED';
        subtitle.classList.add('perfect-score');
      }
      gameOverEl.classList.add('show');
    }

    function hideGameOver() {
      gameOverEl.classList.remove('show');
    }

    function showStartButton() {
      if (startGameBtn) {
        startGameBtn.classList.add('show');
      }
    }

    function hideStartButton() {
      if (startGameBtn) {
        startGameBtn.classList.remove('show');
      }
    }

    // Pre-computed Hamiltonian path that visits every cell exactly once
    // Pattern matches spreadsheet: Row 1 A→T, Row 2 T→B, Row 3 B→T, etc., then up column A
    let hamiltonianPath = null;
    let customHamiltonianPath = null; // User-configured custom path
    
    function generateHamiltonianPath() {
      const path = [];
      
      // Row 1 (y=0): A1 to T1 (x=0 to x=GRID_SIZE-1, going right)
      // This ends at (GRID_SIZE-1, 0) = T1
      for (let x = 0; x < GRID_SIZE; x++) {
        path.push({ x, y: 0 });
      }
      
      // Rows 2 to GRID_SIZE (y=1 to y=GRID_SIZE-1): Zigzag pattern
      // Row 2 (y=1, even 1-indexed): T2 to B2 (x=GRID_SIZE-1 to x=1, going left)
      // Row 3 (y=2, odd 1-indexed): B3 to T3 (x=1 to x=GRID_SIZE-1, going right)
      // Row 4 (y=3, even 1-indexed): T4 to B4 (x=GRID_SIZE-1 to x=1, going left)
      // etc.
      for (let y = 1; y < GRID_SIZE; y++) {
        if (y % 2 === 1) {
          // Even row (1-indexed, y=1,3,5...): go left from T to B
          // Start at T (x=GRID_SIZE-1) - this is adjacent to where we ended in previous row
          for (let x = GRID_SIZE - 1; x >= 1; x--) {
            path.push({ x, y });
          }
          // Ends at B (x=1, y)
        } else {
          // Odd row (1-indexed, y=2,4,6...): go right from B to T
          // Start at B (x=1) - this is adjacent to where we ended in previous row
          for (let x = 1; x < GRID_SIZE; x++) {
            path.push({ x, y });
          }
          // Ends at T (x=GRID_SIZE-1, y)
        }
      }
      
      // After processing all rows, we end at either:
      // - (1, GRID_SIZE-1) if last row was even (1-indexed) - which means y=GRID_SIZE-1 is odd
      // - (GRID_SIZE-1, GRID_SIZE-1) if last row was odd (1-indexed) - which means y=GRID_SIZE-1 is even
      // Check: GRID_SIZE-1 = 19, which is odd, so last row (y=19) is even (1-indexed)
      // So we end at (1, GRID_SIZE-1) = B20
      
      // Go to A20 (x=0, y=GRID_SIZE-1) - this is adjacent to B20
      path.push({ x: 0, y: GRID_SIZE - 1 });
      
      // Go up column A from A20 to A2 (skip A1 since it's already visited)
      // This goes from (0, GRID_SIZE-1) to (0, 1)
      for (let y = GRID_SIZE - 2; y >= 1; y--) {
        path.push({ x: 0, y });
      }
      
      // Verify path is continuous and visits all cells
      const visited = new Set();
      for (let i = 0; i < path.length; i++) {
        const cell = path[i];
        const key = `${cell.x},${cell.y}`;
        if (visited.has(key)) {
          console.error('Duplicate cell in path:', cell, 'at index', i);
        }
        visited.add(key);
        
        // Check continuity (except for last cell)
        if (i < path.length - 1) {
          const next = path[i + 1];
          const dx = Math.abs(cell.x - next.x);
          const dy = Math.abs(cell.y - next.y);
          if (dx + dy !== 1) {
            console.error('Path not continuous at index', i, cell, '->', next);
          }
        }
      }
      
      if (visited.size !== GRID_SIZE * GRID_SIZE) {
        console.warn('Path incomplete:', visited.size, 'expected', GRID_SIZE * GRID_SIZE);
      }
      if (path.length !== GRID_SIZE * GRID_SIZE) {
        console.warn('Path length mismatch:', path.length, 'expected', GRID_SIZE * GRID_SIZE);
      }
      
      return path;
    }
    
    // Get the index of a cell in the Hamiltonian path
    function getPathIndex(x, y, pathToUse = null) {
      const path = pathToUse || customHamiltonianPath || (hamiltonianPath || generateHamiltonianPath());
      for (let i = 0; i < path.length; i++) {
        if (path[i].x === x && path[i].y === y) {
          return i;
        }
      }
      return -1;
    }
    
    // Get the next cell in the path from current position
    function getNextInPath(x, y) {
      // Use custom path if available, otherwise use default
      const pathToUse = customHamiltonianPath || (hamiltonianPath || generateHamiltonianPath());
      const currentIndex = getPathIndex(x, y, pathToUse);
      if (currentIndex === -1 || currentIndex >= pathToUse.length - 1) {
        // If at end of path and it's a cycle, wrap to beginning
        if (currentIndex === pathToUse.length - 1 && pathToUse[0].x === 0 && pathToUse[0].y === 0) {
          return pathToUse[0];
        }
        return null; // At end of path
      }
      return pathToUse[currentIndex + 1];
    }
    
    // AI Pathfinding for Autodrive - Simple Hamiltonian path following
    // Just follows the predefined path, no additional logic needed
    function findPathToFood() {
      const head = snake[0];
      
      // Create a set of snake body positions (excluding tail which will move)
      const snakeBody = new Set();
      for (let i = 0; i < snake.length - 1; i++) {
        snakeBody.add(`${snake[i].x},${snake[i].y}`);
      }
      
      // Get the next cell in the predefined path
      const nextCell = getNextInPath(head.x, head.y);
      
      if (!nextCell) {
        // At the end of the path - game should be complete
        // Fallback: continue in current direction
        const currentDir = snake.length > 1 
          ? { x: snake[0].x - snake[1].x, y: snake[0].y - snake[1].y }
          : { x: 1, y: 0 };
        return currentDir;
      }
      
      // Calculate direction to the next cell
      const dirX = nextCell.x - head.x;
      const dirY = nextCell.y - head.y;
      
      // Verify this is an adjacent cell (distance = 1)
      if (Math.abs(dirX) + Math.abs(dirY) !== 1) {
        console.error('Next cell in path is not adjacent!', head, nextCell);
        const currentDir = snake.length > 1 
          ? { x: snake[0].x - snake[1].x, y: snake[0].y - snake[1].y }
          : { x: 1, y: 0 };
        return currentDir;
      }
      
      // Normalize direction
      const normalizedX = dirX !== 0 ? (dirX > 0 ? 1 : -1) : 0;
      const normalizedY = dirY !== 0 ? (dirY > 0 ? 1 : -1) : 0;
      
      // Check if this move is safe (won't hit body, excluding tail)
      const key = `${nextCell.x},${nextCell.y}`;
      if (!snakeBody.has(key) && nextCell.x >= 0 && nextCell.x < GRID_SIZE && 
          nextCell.y >= 0 && nextCell.y < GRID_SIZE) {
        return { x: normalizedX, y: normalizedY };
      }
      
      // If blocked, something is wrong - but this shouldn't happen with proper path
      console.warn('Next cell in path is blocked:', nextCell);
      
      // Fallback: try current direction
      const currentDir = snake.length > 1 
        ? { x: snake[0].x - snake[1].x, y: snake[0].y - snake[1].y }
        : { x: 1, y: 0 };
      const newX = head.x + currentDir.x;
      const newY = head.y + currentDir.y;
      if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && 
          !snakeBody.has(`${newX},${newY}`)) {
        return currentDir;
      }
      
      return { x: 1, y: 0 }; // Last resort
    }
    
    // BFS to find shortest path between two points
    function bfsPath(start, target, obstacles) {
      const queue = [{ x: start.x, y: start.y, path: [] }];
      const visited = new Set();
      visited.add(`${start.x},${start.y}`);
      
      const directions = [
        { x: 0, y: -1 }, // up
        { x: 1, y: 0 },  // right
        { x: 0, y: 1 },  // down
        { x: -1, y: 0 }  // left
      ];
      
      while (queue.length > 0) {
        const current = queue.shift();
        
        if (current.x === target.x && current.y === target.y) {
          return current.path;
        }
        
        for (const dir of directions) {
          let newX = (current.x + dir.x + GRID_SIZE) % GRID_SIZE;
          let newY = (current.y + dir.y + GRID_SIZE) % GRID_SIZE;
          
          const key = `${newX},${newY}`;
          
          if (!visited.has(key) && !obstacles.has(key)) {
            visited.add(key);
            queue.push({
              x: newX,
              y: newY,
              path: [...current.path, dir]
            });
          }
        }
      }
      
      return null; // No path found
    }
    
    // Find the safest move that maximizes future options
    function findSafeMove(head, snakeBody, target) {
      const directions = [
        { x: 0, y: -1 }, // up
        { x: 1, y: 0 },  // right
        { x: 0, y: 1 },  // down
        { x: -1, y: 0 }  // left
      ];
      
      // Score each possible move
      const moves = [];
      
      for (const dir of directions) {
        let newX = (head.x + dir.x + GRID_SIZE) % GRID_SIZE;
        let newY = (head.y + dir.y + GRID_SIZE) % GRID_SIZE;
        
        const key = `${newX},${newY}`;
        
        // Skip if would hit body
        if (snakeBody.has(key)) {
          continue;
        }
        
        // Calculate score for this move
        let score = 0;
        
        // Check if this move is safe (can reach tail after moving)
        const newSnakeBody = new Set(snakeBody);
        newSnakeBody.delete(`${snake[snake.length - 1].x},${snake[snake.length - 1].y}`); // Remove tail
        newSnakeBody.add(key); // Add new head position
        
        const tail = snake[snake.length - 1];
        const pathToTail = bfsPath({ x: newX, y: newY }, tail, newSnakeBody);
        
        if (pathToTail && pathToTail.length > 0) {
          score += 1000; // Safe move - can reach tail
        } else {
          // Unsafe move, but might be necessary
          score -= 500;
        }
        
        // Prefer moves that get closer to food (with wrapping)
        const dx = Math.min(Math.abs(newX - target.x), GRID_SIZE - Math.abs(newX - target.x));
        const dy = Math.min(Math.abs(newY - target.y), GRID_SIZE - Math.abs(newY - target.y));
        const wrappedDistToFood = dx + dy;
        score += (GRID_SIZE * 2 - wrappedDistToFood) * 10;
        
        // Count how many free spaces are reachable from this position
        const reachable = countReachableSpaces({ x: newX, y: newY }, newSnakeBody);
        score += reachable;
        
        moves.push({ dir, score, newX, newY });
      }
      
      // Sort by score (highest first)
      moves.sort((a, b) => b.score - a.score);
      
      // Return best move, or current direction if no safe moves
      if (moves.length > 0 && moves[0].score > -500) {
        return moves[0].dir;
      }
      
      // Last resort: try to continue in current direction if safe
      const currentDir = direction;
      let newX = (head.x + currentDir.x + GRID_SIZE) % GRID_SIZE;
      let newY = (head.y + currentDir.y + GRID_SIZE) % GRID_SIZE;
      const key = `${newX},${newY}`;
      if (!snakeBody.has(key)) {
        return currentDir;
      }
      
      // Any move is better than crashing
      return moves.length > 0 ? moves[0].dir : currentDir;
    }
    
    // Count how many spaces are reachable from a position (flood fill)
    function countReachableSpaces(start, obstacles) {
      const queue = [start];
      const visited = new Set();
      visited.add(`${start.x},${start.y}`);
      
      const directions = [
        { x: 0, y: -1 }, // up
        { x: 1, y: 0 },  // right
        { x: 0, y: 1 },  // down
        { x: -1, y: 0 }  // left
      ];
      
      let count = 0;
      
      while (queue.length > 0) {
        const current = queue.shift();
        count++;
        
        for (const dir of directions) {
          let newX = (current.x + dir.x + GRID_SIZE) % GRID_SIZE;
          let newY = (current.y + dir.y + GRID_SIZE) % GRID_SIZE;
          
          const key = `${newX},${newY}`;
          
          if (!visited.has(key) && !obstacles.has(key)) {
            visited.add(key);
            queue.push({ x: newX, y: newY });
          }
        }
      }
      
      return count;
    }

    function changeDirection(newDir) {
      // Don't auto-start on direction change - user must press start button
      if (!gameRunning || gameOver || gamePaused) {
        SoundManager.playInvalidMove();
        return;
      }
      
      // Don't allow manual direction changes when autodrive is active
      if (autodriveActive) {
        SoundManager.playInvalidMove();
        return;
      }
      
      // Check against nextDirection (where snake will move next), not current direction
      // This allows rapid direction changes to work correctly
      const checkDir = directionQueue.length > 0 
        ? directionQueue[directionQueue.length - 1] 
        : nextDirection;
      
      // Prevent reversing into itself (backwards) - check against next direction, not current
      if (newDir.x === -checkDir.x && newDir.y === -checkDir.y) {
        SoundManager.playInvalidMove();
        return;
      }
      
      // Check if direction is actually changing
      const isDirectionChanging = newDir.x !== checkDir.x || newDir.y !== checkDir.y;
      
      // Add to queue to capture rapid key presses
      // Allow same direction multiple times - user might press same key rapidly
      directionQueue.push(newDir);
      
      // Update nextDirection immediately for responsiveness
      // This ensures instant feedback, and moveSnake will process the queue correctly
      nextDirection = newDir;
      
      // Play sound when direction actually changes
      if (isDirectionChanging) {
        SoundManager.playDirectionChange();
      }
      
      // Limit queue size to prevent memory issues (keep last 5 directions for rapid presses)
      if (directionQueue.length > 5) {
        directionQueue.shift();
      }
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (SoundManager.audioContext && !SoundManager.hasUserInteracted) {
        SoundManager.hasUserInteracted = true;
        SoundManager.ensureResumed();
      }
      
      switch (e.key) {
        case 'ArrowUp':
          e.preventDefault();
          changeDirection({ x: 0, y: -1 });
          break;
        case 'ArrowDown':
          e.preventDefault();
          changeDirection({ x: 0, y: 1 });
          break;
        case 'ArrowLeft':
          e.preventDefault();
          changeDirection({ x: -1, y: 0 });
          break;
        case 'ArrowRight':
          e.preventDefault();
          changeDirection({ x: 1, y: 0 });
          break;
        case ' ':
          e.preventDefault();
          // If game over screen is showing, restart the game
          if (gameOverEl && gameOverEl.classList.contains('show')) {
            // Play reboot sound
            SoundManager.playReboot();
            
            // Add glitching animation to canvas
            canvas.classList.add('glitching');
            setTimeout(() => {
              canvas.classList.remove('glitching');
            }, 500);
            
            // Stop any existing loops first
            if (animationFrameId) {
              cancelAnimationFrame(animationFrameId);
              animationFrameId = null;
            }
            if (gameLoop) {
              clearInterval(gameLoop);
              gameLoop = null;
            }
            
            // Reset all game state before restarting
            gameRunning = false;
            gameOver = false;
            gamePaused = false;
            score = 10; // Snake starts with 1 segment = 10 points
            snake = [{ x: 0, y: 0 }]; // Start at top left
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            directionQueue = [];
            currentSpeed = INITIAL_SPEED;
            lastMoveTime = 0;
            
            // Set initial food position (cell 4, top row) for immediate catch
            food = [{ x: 4, y: 0, type: null }];
            
            // Hide game over screen and show start button (don't auto-start)
            hideGameOver();
            updateScores();
            showStartButton();
            draw();
          } else if (gameRunning && !gameOver) {
            togglePause();
          } else if (!gameRunning && !gameOver) {
            // Start the game if not running and not on game over screen
            startGame();
          }
          break;
      }
    });

    // Touch/Swipe controls
    let touchStartX = null;
    let touchStartY = null;
    const minSwipeDistance = 30;

    function isInteractiveElement(target) {
      return target.tagName === 'BUTTON' || 
             target.closest('button') !== null ||
             target.closest('#gameOver') !== null ||
             target.closest('#helpModal') !== null ||
             target.closest('.menu-dropdown') !== null ||
             target.closest('.direction-controls') !== null;
    }

    document.addEventListener('touchstart', (e) => {
      if (SoundManager.audioContext && !SoundManager.hasUserInteracted) {
        SoundManager.hasUserInteracted = true;
        SoundManager.ensureResumed();
      }
      
      if (isInteractiveElement(e.target)) return;
      // Don't auto-start on touch - user must press start button
      if (!gameRunning || gameOver || gamePaused) return;
      
      e.preventDefault();
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
      if (isInteractiveElement(e.target)) return;
      if (touchStartX === null || touchStartY === null) return;
      
      e.preventDefault();
      const touch = e.changedTouches[0];
      const deltaX = touch.clientX - touchStartX;
      const deltaY = touch.clientY - touchStartY;
      const absDeltaX = Math.abs(deltaX);
      const absDeltaY = Math.abs(deltaY);
      
      if (absDeltaX > minSwipeDistance || absDeltaY > minSwipeDistance) {
        if (absDeltaX > absDeltaY) {
          if (deltaX > 0) {
            changeDirection({ x: 1, y: 0 });
          } else {
            changeDirection({ x: -1, y: 0 });
          }
        } else {
          if (deltaY > 0) {
            changeDirection({ x: 0, y: 1 });
          } else {
            changeDirection({ x: 0, y: -1 });
          }
        }
      }
      
      touchStartX = null;
      touchStartY = null;
    }, { passive: false });

    // Control mode state (absolute, relative, or split)
    let controlMode = localStorage.getItem('controlMode') || 'none'; // 'none', 'absolute', 'relative', or 'split'
    
    // Function to calculate relative turn direction
    function getRelativeDirection(turn) {
      // turn: 'left' or 'right'
      // Get current direction - use directionQueue if available, otherwise nextDirection, otherwise direction
      let currentDir;
      if (directionQueue.length > 0) {
        currentDir = directionQueue[directionQueue.length - 1];
      } else if (nextDirection.x !== 0 || nextDirection.y !== 0) {
        currentDir = nextDirection;
      } else {
        currentDir = direction;
      }
      
      // If snake has multiple segments, we can also check the actual movement direction
      if (snake.length > 1) {
        const head = snake[0];
        const neck = snake[1];
        const actualDir = { x: head.x - neck.x, y: head.y - neck.y };
        // Normalize in case of wrapping
        if (actualDir.x !== 0 || actualDir.y !== 0) {
          currentDir = {
            x: actualDir.x > 0 ? 1 : (actualDir.x < 0 ? -1 : 0),
            y: actualDir.y > 0 ? 1 : (actualDir.y < 0 ? -1 : 0)
          };
        }
      }
      
      // Calculate relative turn
      // Current direction vectors:
      // Up: {x: 0, y: -1}
      // Right: {x: 1, y: 0}
      // Down: {x: 0, y: 1}
      // Left: {x: -1, y: 0}
      
      if (turn === 'left') {
        // Turn left: rotate 90 degrees counter-clockwise
        // Up -> Left, Left -> Down, Down -> Right, Right -> Up
        return { x: currentDir.y, y: -currentDir.x };
      } else if (turn === 'right') {
        // Turn right: rotate 90 degrees clockwise
        // Up -> Right, Right -> Down, Down -> Left, Left -> Up
        return { x: -currentDir.y, y: currentDir.x };
      }
      return currentDir;
    }
    
    // Function to position split controls below the game board
    function positionSplitControlsOnSides() {
      const splitControlLeft = document.getElementById('splitControlLeft');
      const splitControlRight = document.getElementById('splitControlRight');
      const leftPos = localStorage.getItem('splitControlLeftPosition');
      const rightPos = localStorage.getItem('splitControlRightPosition');
      
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
          const containerRect = gameContainer.getBoundingClientRect();
          const controlHeight = 105; // Height of 2 buttons stacked (50px + 5px gap + 50px)
          const controlWidth = 105; // Width of 2 columns (50px + 5px gap + 50px)
          const padding = 20; // Padding from edges
          const spacingBelow = 25; // Space below the game container
          const gapBetweenControls = 150; // Space between left and right controls
          
          // Position below the game container
          const bottomY = containerRect.bottom + spacingBelow;
          
          // Calculate center position for both controls
          const centerX = containerRect.left + (containerRect.width / 2);
          
          // Position left control if not already saved
          if (!leftPos && splitControlLeft) {
            // Position on left side of center with gap
            splitControlLeft.style.left = (centerX - controlWidth - gapBetweenControls / 2) + 'px';
            splitControlLeft.style.top = bottomY + 'px';
            splitControlLeft.style.transform = 'none';
            splitControlLeft.style.bottom = 'auto';
            splitControlLeft.style.right = 'auto';
          }
          
          // Position right control if not already saved
          if (!rightPos && splitControlRight) {
            // Position on right side of center with gap
            splitControlRight.style.left = (centerX + gapBetweenControls / 2) + 'px';
            splitControlRight.style.top = bottomY + 'px';
            splitControlRight.style.transform = 'none';
            splitControlRight.style.bottom = 'auto';
            splitControlRight.style.right = 'auto';
          }
      } else {
        // Fallback if game container not found
        if (!leftPos && splitControlLeft) {
          splitControlLeft.style.left = '20px';
          splitControlLeft.style.bottom = '20px';
          splitControlLeft.style.top = 'auto';
          splitControlLeft.style.transform = 'none';
          splitControlLeft.style.right = 'auto';
        }
        if (!rightPos && splitControlRight) {
          splitControlRight.style.right = '20px';
          splitControlRight.style.bottom = '20px';
          splitControlRight.style.top = 'auto';
          splitControlRight.style.transform = 'none';
          splitControlRight.style.left = 'auto';
        }
      }
    }
    
    // Function to position relative controls at bottom of game area
    function positionRelativeControlsAtBottom() {
      const relativeTurnLeft = document.getElementById('relativeTurnLeft');
      const relativeTurnRight = document.getElementById('relativeTurnRight');
      const leftPos = localStorage.getItem('relativeTurnLeftPosition');
      const rightPos = localStorage.getItem('relativeTurnRightPosition');
      
      // Only position if not already saved
      if (!leftPos || !rightPos) {
        // Calculate position below game area (not inside it)
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
          const containerRect = gameContainer.getBoundingClientRect();
          const controlHeight = 60; // Height of the control button
          const controlWidth = 60; // Width of the control button
          const padding = 20; // Padding from edges
          const spacingBelow = 25; // Space below the game container
          
          // Position below the game container
          const bottomY = containerRect.bottom + spacingBelow;
          
          if (!leftPos && relativeTurnLeft) {
            // Position at bottom-left, below game area
            relativeTurnLeft.style.left = (containerRect.left + padding) + 'px';
            relativeTurnLeft.style.top = bottomY + 'px';
            relativeTurnLeft.style.transform = 'none';
            relativeTurnLeft.style.bottom = 'auto';
            relativeTurnLeft.style.right = 'auto';
          }
          
          if (!rightPos && relativeTurnRight) {
            // Position at bottom-right, below game area
            relativeTurnRight.style.left = (containerRect.right - controlWidth - padding) + 'px';
            relativeTurnRight.style.top = bottomY + 'px';
            relativeTurnRight.style.transform = 'none';
            relativeTurnRight.style.bottom = 'auto';
            relativeTurnRight.style.right = 'auto';
          }
        } else {
          // Fallback if game container not found
          if (!leftPos && relativeTurnLeft) {
            relativeTurnLeft.style.left = '20px';
            relativeTurnLeft.style.bottom = '20px';
            relativeTurnLeft.style.top = 'auto';
            relativeTurnLeft.style.transform = 'none';
            relativeTurnLeft.style.right = 'auto';
          }
          if (!rightPos && relativeTurnRight) {
            relativeTurnRight.style.right = '20px';
            relativeTurnRight.style.bottom = '20px';
            relativeTurnRight.style.top = 'auto';
            relativeTurnRight.style.transform = 'none';
            relativeTurnRight.style.left = 'auto';
          }
        }
      }
    }
    
    // Update direction button handlers based on control mode
    function updateDirectionButtons() {
      const directionControls = document.getElementById('directionControls');
      const relativeTurnLeft = document.getElementById('relativeTurnLeft');
      const relativeTurnRight = document.getElementById('relativeTurnRight');
      const btnTurnLeft = document.getElementById('btnTurnLeft');
      const btnTurnRight = document.getElementById('btnTurnRight');
      
      const splitControlLeft = document.getElementById('splitControlLeft');
      const splitControlRight = document.getElementById('splitControlRight');
      
      if (controlMode === 'none') {
        // Hide all touch controls
        directionControls.style.display = 'none';
        relativeTurnLeft.classList.remove('show');
        relativeTurnRight.classList.remove('show');
        if (splitControlLeft) splitControlLeft.classList.remove('show');
        if (splitControlRight) splitControlRight.classList.remove('show');
      } else if (controlMode === 'relative') {
        // Hide absolute direction controls and split controls
        directionControls.style.display = 'none';
        if (splitControlLeft) splitControlLeft.classList.remove('show');
        if (splitControlRight) splitControlRight.classList.remove('show');
        
        // Show relative turn controls
        relativeTurnLeft.classList.add('show');
        relativeTurnRight.classList.add('show');
        
        // Remove existing listeners by cloning and replacing buttons
        const newBtnTurnLeft = btnTurnLeft.cloneNode(true);
        const newBtnTurnRight = btnTurnRight.cloneNode(true);
        btnTurnLeft.parentNode.replaceChild(newBtnTurnLeft, btnTurnLeft);
        btnTurnRight.parentNode.replaceChild(newBtnTurnRight, btnTurnRight);
        
        // Update references
        const updatedBtnTurnLeft = document.getElementById('btnTurnLeft');
        const updatedBtnTurnRight = document.getElementById('btnTurnRight');
        
        // Set up relative turn buttons
        updatedBtnTurnLeft.addEventListener('click', () => {
          const newDir = getRelativeDirection('left');
          changeDirection(newDir);
        });
        updatedBtnTurnRight.addEventListener('click', () => {
          const newDir = getRelativeDirection('right');
          changeDirection(newDir);
        });
        
        // Position relative controls at bottom of game area (if not already positioned)
        // Use setTimeout to ensure game container is rendered
        setTimeout(() => {
          positionRelativeControlsAtBottom();
        }, 100);
      } else if (controlMode === 'split') {
        // Hide absolute direction controls and relative turn controls
        directionControls.style.display = 'none';
        relativeTurnLeft.classList.remove('show');
        relativeTurnRight.classList.remove('show');
        
        // Show split controls
        if (splitControlLeft) splitControlLeft.classList.add('show');
        if (splitControlRight) splitControlRight.classList.add('show');
        
        // Get split control buttons
        const splitBtnUpLeft = document.getElementById('splitBtnUpLeft');
        const splitBtnLeft = document.getElementById('splitBtnLeft');
        const splitBtnDownLeft = document.getElementById('splitBtnDownLeft');
        const splitBtnUpRight = document.getElementById('splitBtnUpRight');
        const splitBtnRight = document.getElementById('splitBtnRight');
        const splitBtnDownRight = document.getElementById('splitBtnDownRight');
        
        // Remove existing listeners by cloning and replacing
        const newSplitBtnUpLeft = splitBtnUpLeft.cloneNode(true);
        const newSplitBtnLeft = splitBtnLeft.cloneNode(true);
        const newSplitBtnDownLeft = splitBtnDownLeft.cloneNode(true);
        const newSplitBtnUpRight = splitBtnUpRight.cloneNode(true);
        const newSplitBtnRight = splitBtnRight.cloneNode(true);
        const newSplitBtnDownRight = splitBtnDownRight.cloneNode(true);
        
        splitBtnUpLeft.parentNode.replaceChild(newSplitBtnUpLeft, splitBtnUpLeft);
        splitBtnLeft.parentNode.replaceChild(newSplitBtnLeft, splitBtnLeft);
        splitBtnDownLeft.parentNode.replaceChild(newSplitBtnDownLeft, splitBtnDownLeft);
        splitBtnUpRight.parentNode.replaceChild(newSplitBtnUpRight, splitBtnUpRight);
        splitBtnRight.parentNode.replaceChild(newSplitBtnRight, splitBtnRight);
        splitBtnDownRight.parentNode.replaceChild(newSplitBtnDownRight, splitBtnDownRight);
        
        // Set up split control buttons
        newSplitBtnUpLeft.addEventListener('click', () => changeDirection({ x: 0, y: -1 }));
        newSplitBtnLeft.addEventListener('click', () => changeDirection({ x: -1, y: 0 }));
        newSplitBtnDownLeft.addEventListener('click', () => changeDirection({ x: 0, y: 1 }));
        newSplitBtnUpRight.addEventListener('click', () => changeDirection({ x: 0, y: -1 }));
        newSplitBtnRight.addEventListener('click', () => changeDirection({ x: 1, y: 0 }));
        newSplitBtnDownRight.addEventListener('click', () => changeDirection({ x: 0, y: 1 }));
        
        // Position split controls on sides (if not already positioned)
        setTimeout(() => {
          positionSplitControlsOnSides();
        }, 100);
      } else if (controlMode === 'absolute') {
        // Hide relative turn controls and split controls
        relativeTurnLeft.classList.remove('show');
        relativeTurnRight.classList.remove('show');
        if (splitControlLeft) splitControlLeft.classList.remove('show');
        if (splitControlRight) splitControlRight.classList.remove('show');
        
        // Show absolute direction controls
        directionControls.style.display = 'grid';
        
        // Set up absolute direction buttons
        const btnUp = document.getElementById('btnUp');
        const btnDown = document.getElementById('btnDown');
        const btnLeft = document.getElementById('btnLeft');
        const btnRight = document.getElementById('btnRight');
        
        // Remove existing listeners by cloning and replacing
        const newBtnUp = btnUp.cloneNode(true);
        const newBtnDown = btnDown.cloneNode(true);
        const newBtnLeft = btnLeft.cloneNode(true);
        const newBtnRight = btnRight.cloneNode(true);
        
        btnUp.parentNode.replaceChild(newBtnUp, btnUp);
        btnDown.parentNode.replaceChild(newBtnDown, btnDown);
        btnLeft.parentNode.replaceChild(newBtnLeft, btnLeft);
        btnRight.parentNode.replaceChild(newBtnRight, btnRight);
        
        newBtnUp.addEventListener('click', () => changeDirection({ x: 0, y: -1 }));
        newBtnDown.addEventListener('click', () => changeDirection({ x: 0, y: 1 }));
        newBtnLeft.addEventListener('click', () => changeDirection({ x: -1, y: 0 }));
        newBtnRight.addEventListener('click', () => changeDirection({ x: 1, y: 0 }));
      }
    }
    
    // Initialize direction buttons
    updateDirectionButtons();
    
    // Draggable direction controls
    const directionControls = document.getElementById('directionControls');
    const directionControlsHandle = document.getElementById('directionControlsHandle');
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };
    
    // Load saved position
    const savedPosition = localStorage.getItem('directionControlsPosition');
    if (savedPosition) {
      const pos = JSON.parse(savedPosition);
      directionControls.style.left = pos.left + 'px';
      directionControls.style.top = pos.top + 'px';
      directionControls.style.bottom = 'auto';
      directionControls.style.right = 'auto';
    }
    
    function savePosition() {
      const rect = directionControls.getBoundingClientRect();
      localStorage.setItem('directionControlsPosition', JSON.stringify({
        left: rect.left,
        top: rect.top
      }));
    }
    
    // Handle drag start
    function startDrag(e) {
      // Only drag from handle, not from buttons
      const target = e.target;
      if (target !== directionControlsHandle && 
          !directionControlsHandle.contains(target) &&
          !target.closest('.direction-controls-handle')) {
        return;
      }
      isDragging = true;
      directionControls.classList.add('dragging');
      const rect = directionControls.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      dragOffset.x = clientX - rect.left;
      dragOffset.y = clientY - rect.top;
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Handle drag
    function doDrag(e) {
      if (!isDragging) return;
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
      let newLeft = clientX - dragOffset.x;
      let newTop = clientY - dragOffset.y;
      
      // Constrain to viewport
      const rect = directionControls.getBoundingClientRect();
      const maxLeft = window.innerWidth - rect.width;
      const maxTop = window.innerHeight - rect.height;
      
      newLeft = Math.max(0, Math.min(newLeft, maxLeft));
      newTop = Math.max(0, Math.min(newTop, maxTop));
      
      directionControls.style.left = newLeft + 'px';
      directionControls.style.top = newTop + 'px';
      directionControls.style.bottom = 'auto';
      directionControls.style.right = 'auto';
      
      e.preventDefault();
    }
    
    // Handle drag end
    function endDrag() {
      if (isDragging) {
        isDragging = false;
        directionControls.classList.remove('dragging');
        savePosition();
      }
    }
    
    // Add event listeners for dragging
    directionControlsHandle.addEventListener('mousedown', startDrag);
    directionControlsHandle.addEventListener('touchstart', startDrag, { passive: false });
    document.addEventListener('mousemove', doDrag);
    document.addEventListener('touchmove', doDrag, { passive: false });
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchend', endDrag);
    
    // Prevent button clicks from triggering drag
    directionControls.addEventListener('mousedown', (e) => {
      const target = e.target;
      // Allow buttons to work normally
      if (target.closest('.direction-btn') && !target.closest('.direction-controls-handle')) {
        return; // Let button click handlers work
      }
      // Only allow drag from handle
      if (target !== directionControlsHandle && !target.closest('.direction-controls-handle')) {
        e.stopPropagation();
      }
    });
    
    // Draggable relative turn controls (will be initialized after updateDirectionButtons)
    let relativeTurnLeft = document.getElementById('relativeTurnLeft');
    let relativeTurnRight = document.getElementById('relativeTurnRight');
    let relativeTurnLeftHandle = document.getElementById('relativeTurnLeftHandle');
    let relativeTurnRightHandle = document.getElementById('relativeTurnRightHandle');
    let isDraggingLeft = false;
    let isDraggingRight = false;
    let dragOffsetLeft = { x: 0, y: 0 };
    let dragOffsetRight = { x: 0, y: 0 };
    
    // Load saved positions for relative controls
    const savedLeftPos = localStorage.getItem('relativeTurnLeftPosition');
    const savedRightPos = localStorage.getItem('relativeTurnRightPosition');
    if (savedLeftPos) {
      const pos = JSON.parse(savedLeftPos);
      relativeTurnLeft.style.left = pos.left + 'px';
      relativeTurnLeft.style.top = pos.top + 'px';
      relativeTurnLeft.style.bottom = 'auto';
      relativeTurnLeft.style.right = 'auto';
      relativeTurnLeft.style.transform = 'none';
    }
    if (savedRightPos) {
      const pos = JSON.parse(savedRightPos);
      relativeTurnRight.style.left = pos.left + 'px';
      relativeTurnRight.style.top = pos.top + 'px';
      relativeTurnRight.style.bottom = 'auto';
      relativeTurnRight.style.right = 'auto';
      relativeTurnRight.style.transform = 'none';
    }
    
    function saveRelativePosition(control, isLeft) {
      const rect = control.getBoundingClientRect();
      const key = isLeft ? 'relativeTurnLeftPosition' : 'relativeTurnRightPosition';
      localStorage.setItem(key, JSON.stringify({
        left: rect.left,
        top: rect.top
      }));
    }
    
    // Handle drag start for left control
    function startDragLeft(e) {
      const target = e.target;
      if (target !== relativeTurnLeftHandle && 
          !relativeTurnLeftHandle.contains(target) &&
          !target.closest('.relative-turn-control-handle')) {
        return;
      }
      isDraggingLeft = true;
      relativeTurnLeft.classList.add('dragging');
      const rect = relativeTurnLeft.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      dragOffsetLeft.x = clientX - rect.left;
      dragOffsetLeft.y = clientY - rect.top;
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Handle drag start for right control
    function startDragRight(e) {
      const target = e.target;
      if (target !== relativeTurnRightHandle && 
          !relativeTurnRightHandle.contains(target) &&
          !target.closest('.relative-turn-control-handle')) {
        return;
      }
      isDraggingRight = true;
      relativeTurnRight.classList.add('dragging');
      const rect = relativeTurnRight.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      dragOffsetRight.x = clientX - rect.left;
      dragOffsetRight.y = clientY - rect.top;
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Handle drag for relative controls
    function doDragRelative(e) {
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
      if (isDraggingLeft) {
        let newLeft = clientX - dragOffsetLeft.x;
        let newTop = clientY - dragOffsetLeft.y;
        
        const rect = relativeTurnLeft.getBoundingClientRect();
        const maxLeft = window.innerWidth - rect.width;
        const maxTop = window.innerHeight - rect.height;
        
        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        newTop = Math.max(0, Math.min(newTop, maxTop));
        
        relativeTurnLeft.style.left = newLeft + 'px';
        relativeTurnLeft.style.top = newTop + 'px';
        relativeTurnLeft.style.bottom = 'auto';
        relativeTurnLeft.style.right = 'auto';
        relativeTurnLeft.style.transform = 'none';
      }
      
      if (isDraggingRight) {
        let newLeft = clientX - dragOffsetRight.x;
        let newTop = clientY - dragOffsetRight.y;
        
        const rect = relativeTurnRight.getBoundingClientRect();
        const maxLeft = window.innerWidth - rect.width;
        const maxTop = window.innerHeight - rect.height;
        
        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        newTop = Math.max(0, Math.min(newTop, maxTop));
        
        relativeTurnRight.style.left = newLeft + 'px';
        relativeTurnRight.style.top = newTop + 'px';
        relativeTurnRight.style.bottom = 'auto';
        relativeTurnRight.style.right = 'auto';
        relativeTurnRight.style.transform = 'none';
      }
      
      if (isDraggingLeft || isDraggingRight) {
        e.preventDefault();
      }
    }
    
    // Handle drag end for relative controls
    function endDragRelative() {
      if (isDraggingLeft) {
        isDraggingLeft = false;
        relativeTurnLeft.classList.remove('dragging');
        saveRelativePosition(relativeTurnLeft, true);
      }
      if (isDraggingRight) {
        isDraggingRight = false;
        relativeTurnRight.classList.remove('dragging');
        saveRelativePosition(relativeTurnRight, false);
      }
    }
    
    // Add event listeners for dragging relative controls
    relativeTurnLeftHandle.addEventListener('mousedown', startDragLeft);
    relativeTurnLeftHandle.addEventListener('touchstart', startDragLeft, { passive: false });
    relativeTurnRightHandle.addEventListener('mousedown', startDragRight);
    relativeTurnRightHandle.addEventListener('touchstart', startDragRight, { passive: false });
    
    // Update global drag handlers to include relative controls
    document.addEventListener('mousemove', doDragRelative);
    document.addEventListener('touchmove', doDragRelative, { passive: false });
    document.addEventListener('mouseup', endDragRelative);
    document.addEventListener('touchend', endDragRelative);
    
    // Prevent button clicks from triggering drag on relative controls
    relativeTurnLeft.addEventListener('mousedown', (e) => {
      const target = e.target;
      if (target.closest('.relative-turn-btn') && !target.closest('.relative-turn-control-handle')) {
        return;
      }
      if (target !== relativeTurnLeftHandle && !target.closest('.relative-turn-control-handle')) {
        e.stopPropagation();
      }
    });
    
    relativeTurnRight.addEventListener('mousedown', (e) => {
      const target = e.target;
      if (target.closest('.relative-turn-btn') && !target.closest('.relative-turn-control-handle')) {
        return;
      }
      if (target !== relativeTurnRightHandle && !target.closest('.relative-turn-control-handle')) {
        e.stopPropagation();
      }
    });
    
    // Draggable split controls
    let splitControlLeft = document.getElementById('splitControlLeft');
    let splitControlRight = document.getElementById('splitControlRight');
    let splitControlLeftHandle = document.getElementById('splitControlLeftHandle');
    let splitControlRightHandle = document.getElementById('splitControlRightHandle');
    let isDraggingSplitLeft = false;
    let isDraggingSplitRight = false;
    let dragOffsetSplitLeft = { x: 0, y: 0 };
    let dragOffsetSplitRight = { x: 0, y: 0 };
    
    // Load saved positions for split controls
    const savedSplitLeftPos = localStorage.getItem('splitControlLeftPosition');
    const savedSplitRightPos = localStorage.getItem('splitControlRightPosition');
    if (savedSplitLeftPos && splitControlLeft) {
      const pos = JSON.parse(savedSplitLeftPos);
      splitControlLeft.style.left = pos.left + 'px';
      splitControlLeft.style.top = pos.top + 'px';
      splitControlLeft.style.bottom = 'auto';
      splitControlLeft.style.right = 'auto';
      splitControlLeft.style.transform = 'none';
    }
    if (savedSplitRightPos && splitControlRight) {
      const pos = JSON.parse(savedSplitRightPos);
      splitControlRight.style.left = pos.left + 'px';
      splitControlRight.style.top = pos.top + 'px';
      splitControlRight.style.bottom = 'auto';
      splitControlRight.style.right = 'auto';
      splitControlRight.style.transform = 'none';
    }
    
    function saveSplitPosition(control, isLeft) {
      const rect = control.getBoundingClientRect();
      const key = isLeft ? 'splitControlLeftPosition' : 'splitControlRightPosition';
      localStorage.setItem(key, JSON.stringify({
        left: rect.left,
        top: rect.top
      }));
    }
    
    // Handle drag start for split left control
    function startDragSplitLeft(e) {
      const target = e.target;
      if (target !== splitControlLeftHandle && 
          !splitControlLeftHandle.contains(target) &&
          !target.closest('.split-control-handle')) {
        return;
      }
      isDraggingSplitLeft = true;
      splitControlLeft.classList.add('dragging');
      const rect = splitControlLeft.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      dragOffsetSplitLeft.x = clientX - rect.left;
      dragOffsetSplitLeft.y = clientY - rect.top;
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Handle drag start for split right control
    function startDragSplitRight(e) {
      const target = e.target;
      if (target !== splitControlRightHandle && 
          !splitControlRightHandle.contains(target) &&
          !target.closest('.split-control-handle')) {
        return;
      }
      isDraggingSplitRight = true;
      splitControlRight.classList.add('dragging');
      const rect = splitControlRight.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      dragOffsetSplitRight.x = clientX - rect.left;
      dragOffsetSplitRight.y = clientY - rect.top;
      e.preventDefault();
      e.stopPropagation();
    }
    
    // Handle drag for split controls
    function doDragSplit(e) {
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
      if (isDraggingSplitLeft && splitControlLeft) {
        let newLeft = clientX - dragOffsetSplitLeft.x;
        let newTop = clientY - dragOffsetSplitLeft.y;
        
        const rect = splitControlLeft.getBoundingClientRect();
        const maxLeft = window.innerWidth - rect.width;
        
        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        // Allow positioning anywhere vertically, including below the viewport
        
        splitControlLeft.style.left = newLeft + 'px';
        splitControlLeft.style.top = newTop + 'px';
        splitControlLeft.style.bottom = 'auto';
        splitControlLeft.style.right = 'auto';
        splitControlLeft.style.transform = 'none';
      }
      
      if (isDraggingSplitRight && splitControlRight) {
        let newLeft = clientX - dragOffsetSplitRight.x;
        let newTop = clientY - dragOffsetSplitRight.y;
        
        const rect = splitControlRight.getBoundingClientRect();
        const maxLeft = window.innerWidth - rect.width;
        
        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        // Allow positioning anywhere vertically, including below the viewport
        
        splitControlRight.style.left = newLeft + 'px';
        splitControlRight.style.top = newTop + 'px';
        splitControlRight.style.bottom = 'auto';
        splitControlRight.style.right = 'auto';
        splitControlRight.style.transform = 'none';
      }
      
      if (isDraggingSplitLeft || isDraggingSplitRight) {
        e.preventDefault();
      }
    }
    
    // Handle drag end for split controls
    function endDragSplit() {
      if (isDraggingSplitLeft && splitControlLeft) {
        isDraggingSplitLeft = false;
        splitControlLeft.classList.remove('dragging');
        saveSplitPosition(splitControlLeft, true);
      }
      if (isDraggingSplitRight && splitControlRight) {
        isDraggingSplitRight = false;
        splitControlRight.classList.remove('dragging');
        saveSplitPosition(splitControlRight, false);
      }
    }
    
    // Add event listeners for dragging split controls
    if (splitControlLeftHandle) {
      splitControlLeftHandle.addEventListener('mousedown', startDragSplitLeft);
      splitControlLeftHandle.addEventListener('touchstart', startDragSplitLeft, { passive: false });
    }
    if (splitControlRightHandle) {
      splitControlRightHandle.addEventListener('mousedown', startDragSplitRight);
      splitControlRightHandle.addEventListener('touchstart', startDragSplitRight, { passive: false });
    }
    
    // Update global drag handlers to include split controls
    document.addEventListener('mousemove', doDragSplit);
    document.addEventListener('touchmove', doDragSplit, { passive: false });
    document.addEventListener('mouseup', endDragSplit);
    document.addEventListener('touchend', endDragSplit);
    
    // Prevent button clicks from triggering drag on split controls
    if (splitControlLeft) {
      splitControlLeft.addEventListener('mousedown', (e) => {
        const target = e.target;
        if (target.closest('.split-btn') && !target.closest('.split-control-handle')) {
          return;
        }
        if (target !== splitControlLeftHandle && !target.closest('.split-control-handle')) {
          e.stopPropagation();
        }
      });
    }
    
    if (splitControlRight) {
      splitControlRight.addEventListener('mousedown', (e) => {
        const target = e.target;
        if (target.closest('.split-btn') && !target.closest('.split-control-handle')) {
          return;
        }
        if (target !== splitControlRightHandle && !target.closest('.split-control-handle')) {
          e.stopPropagation();
        }
      });
    }

    // Restart button
    restartBtn.addEventListener('click', () => {
      SoundManager.playGlitch();
      restartBtn.classList.add('clicking');
      setTimeout(() => {
        restartBtn.classList.remove('clicking');
      }, 400);
      
      canvas.classList.add('glitching');
      setTimeout(() => {
        canvas.classList.remove('glitching');
      }, 500);
      
      // Stop any existing loops first
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Reset all game state before restarting
      gameRunning = false;
      gameOver = false;
      gamePaused = false;
      score = 10; // Snake starts with 1 segment = 10 points
      snake = [{ x: 0, y: 0 }]; // Start at top left
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      directionQueue = [];
      currentSpeed = INITIAL_SPEED;
      lastMoveTime = 0;
      
      // Set initial food position (cell 4, top row) for immediate catch
      food = [{ x: 4, y: 0 }];
      
      // Hide game over screen if it's showing
      hideGameOver();
      
      // Don't auto-start - wait for user to press start button
      updateScores();
      showStartButton();
      draw();
    });

    restartGameBtn.addEventListener('click', () => {
      // Play reboot sound
      SoundManager.playReboot();
      
      // Add glitching animation to canvas
      canvas.classList.add('glitching');
      setTimeout(() => {
        canvas.classList.remove('glitching');
      }, 500);
      
      // Stop any existing loops first
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      // Reset all game state before restarting (same as reboot)
      gameRunning = false;
      gameOver = false;
      gamePaused = false;
      score = 10; // Snake starts with 1 segment = 10 points
      snake = [{ x: 0, y: 0 }]; // Start at top left
      direction = { x: 1, y: 0 };
      nextDirection = { x: 1, y: 0 };
      directionQueue = [];
      currentSpeed = INITIAL_SPEED;
      lastMoveTime = 0;
      
      // Set initial food position (cell 4, top row) for immediate catch
      food = [{ x: 4, y: 0 }];
      
      // Hide game over screen
      hideGameOver();
      
      // Don't auto-start - wait for user to press start button
      updateScores();
      showStartButton();
      draw();
    });

    // Menu toggle
    const menuToggle = document.getElementById('menuToggle');
    const menuDropdown = document.getElementById('menuDropdown');
    
    if (menuToggle && menuDropdown) {
      menuToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        const isShowing = menuDropdown.classList.contains('show');
        
        if (!isShowing) {
          // Show temporarily to measure
          menuDropdown.style.display = 'flex';
          menuDropdown.style.visibility = 'hidden';
          
          const toggleRect = menuToggle.getBoundingClientRect();
          const dropdownRect = menuDropdown.getBoundingClientRect();
          const spaceBelow = window.innerHeight - toggleRect.bottom;
          const spaceAbove = toggleRect.top;
          const dropdownHeight = dropdownRect.height;
          
          // Reset display
          menuDropdown.style.display = '';
          menuDropdown.style.visibility = '';
          
          // If not enough space below but enough space above, open above
          if (spaceBelow < dropdownHeight + 20 && spaceAbove > dropdownHeight + 20) {
            menuDropdown.classList.add('open-above');
          } else {
            menuDropdown.classList.remove('open-above');
          }
        }
        
        menuDropdown.classList.toggle('show');
      });
      
      const closeMenuIfOutside = (e) => {
        const target = e.target;
        if (menuDropdown.classList.contains('show')) {
          if (!menuToggle.contains(target) && !menuDropdown.contains(target)) {
            menuDropdown.classList.remove('show');
          }
        }
      };
      
      document.addEventListener('click', closeMenuIfOutside);
      document.addEventListener('touchend', closeMenuIfOutside);
    }

    // Sound button
    const soundBtn = document.getElementById('soundBtn');
    if (soundBtn) {
      soundBtn.addEventListener('click', () => {
        SoundManager.toggle();
      });
    }

    // Autodrive button and controls
    const autodriveBtn = document.getElementById('autodriveBtn');
    const autodrivePanel = document.getElementById('autodrivePanel');
    const autodriveSpeedSlider = document.getElementById('autodriveSpeed');
    const autodriveSpeedValue = document.getElementById('autodriveSpeedValue');
    const autodriveStop = document.getElementById('autodriveStop');

    if (autodriveBtn && autodrivePanel) {
      autodriveBtn.addEventListener('click', () => {
        if (!gameRunning || gameOver) {
          // Start game first if not running
          startGame();
        }
        
        if (autodriveActive) {
          // Stop autodrive
          autodriveActive = false;
          autodriveBtn.classList.remove('active');
          autodrivePanel.classList.remove('show');
        } else {
          // Start autodrive
          autodriveActive = true;
          autodriveBtn.classList.add('active');
          autodrivePanel.classList.add('show');
          gamePaused = false; // Ensure game is not paused
        }
      });
    }

    if (autodriveSpeedSlider && autodriveSpeedValue) {
      // Use both input and change events for better touch support
      const updateSpeed = (e) => {
        autodriveSpeed = parseFloat(e.target.value);
        autodriveSpeedValue.textContent = autodriveSpeed + 'x';
      };
      autodriveSpeedSlider.addEventListener('input', updateSpeed);
      autodriveSpeedSlider.addEventListener('change', updateSpeed);
      
      // Prevent scrolling when interacting with slider on touch devices
      autodriveSpeedSlider.addEventListener('touchstart', (e) => {
        // Allow the slider to work, but prevent page scrolling
        const touch = e.touches[0];
        const sliderRect = autodriveSpeedSlider.getBoundingClientRect();
        const percentage = (touch.clientX - sliderRect.left) / sliderRect.width;
        const min = parseFloat(autodriveSpeedSlider.min);
        const max = parseFloat(autodriveSpeedSlider.max);
        const value = min + (percentage * (max - min));
        autodriveSpeedSlider.value = Math.max(min, Math.min(max, value));
        updateSpeed({ target: autodriveSpeedSlider });
      }, { passive: false });
      
      autodriveSpeedSlider.addEventListener('touchmove', (e) => {
        e.preventDefault(); // Prevent scrolling
        const touch = e.touches[0];
        const sliderRect = autodriveSpeedSlider.getBoundingClientRect();
        const percentage = (touch.clientX - sliderRect.left) / sliderRect.width;
        const min = parseFloat(autodriveSpeedSlider.min);
        const max = parseFloat(autodriveSpeedSlider.max);
        const value = min + (percentage * (max - min));
        autodriveSpeedSlider.value = Math.max(min, Math.min(max, value));
        updateSpeed({ target: autodriveSpeedSlider });
      }, { passive: false });
    }

    const spawnSnackBtn = document.getElementById('spawnSnack');
    if (spawnSnackBtn) {
      spawnSnackBtn.addEventListener('click', () => {
        if (gameRunning && !gameOver) {
          // Don't spawn if we're at max score
          if (score >= 4000) return;
          
          // Calculate empty squares (total squares - snake - existing food)
          const totalSquares = GRID_SIZE * GRID_SIZE;
          const occupiedSquares = snake.length + food.length;
          const emptySquares = totalSquares - occupiedSquares;
          
          // Calculate 80% of empty squares
          const snacksToSpawn = Math.floor(emptySquares * 0.8);
          
          // Spawn snacks in empty cells
          for (let i = 0; i < snacksToSpawn; i++) {
            // Don't add food if we're at max score
            if (score >= 4000) break;
            
            // Try to generate food, but limit attempts to avoid infinite loops
            let attempts = 0;
            let newFood;
            do {
              newFood = {
                x: Math.floor(Math.random() * GRID_SIZE),
                y: Math.floor(Math.random() * GRID_SIZE)
              };
              attempts++;
              // If we can't find an empty spot after many attempts, break
              if (attempts > 100) break;
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
                     food.some(f => f.x === newFood.x && f.y === newFood.y));
            
            // Only add if we found a valid position
            if (attempts <= 100) {
              food.push(newFood);
            }
          }
          
          draw();
        }
      });
    }

    if (autodriveStop) {
      autodriveStop.addEventListener('click', () => {
        autodriveActive = false;
        autodriveBtn.classList.remove('active');
        autodrivePanel.classList.remove('show');
        // Pause the game when stopping autodrive
        if (gameRunning && !gameOver) {
          gamePaused = true;
          updatePauseButton();
        }
      });
    }

    // Pause button
    const pauseBtnTop = document.getElementById('pauseBtnTop');
    if (pauseBtnTop) {
      pauseBtnTop.addEventListener('click', () => {
        togglePause();
      });
    }

    // Clear high score
    const clearHighScoreBtn = document.getElementById('clearHighScoreBtn');
    const confirmModal = document.getElementById('confirmModal');
    const confirmYes = document.getElementById('confirmYes');
    const confirmNo = document.getElementById('confirmNo');
    
    if (clearHighScoreBtn && confirmModal) {
      clearHighScoreBtn.addEventListener('click', () => {
        confirmModal.classList.add('show');
        if (menuDropdown) menuDropdown.classList.remove('show');
      });
    }

    if (confirmYes) {
      confirmYes.addEventListener('click', () => {
        highscore = 0;
        // Store as number (localStorage will convert to string, but this ensures consistency)
        localStorage.setItem('snakeHighscore', String(0));
        updateScores();
        if (confirmModal) confirmModal.classList.remove('show');
        // Don't auto-start game after clearing high score
      });
    }

    if (confirmNo) {
      confirmNo.addEventListener('click', () => {
        if (confirmModal) confirmModal.classList.remove('show');
      });
    }

    if (confirmModal) {
      confirmModal.addEventListener('click', (e) => {
        if (e.target === confirmModal) {
          confirmModal.classList.remove('show');
        }
      });
    }

    // Help modal
    const helpBtn = document.getElementById('helpBtn');
    const helpModal = document.getElementById('helpModal');
    const closeHelp = document.getElementById('closeHelp');

    if (helpBtn) {
      helpBtn.addEventListener('click', () => {
        helpModal.classList.add('show');
        menuDropdown.classList.remove('show');
      });
    }

    if (closeHelp) {
      closeHelp.addEventListener('click', () => {
        helpModal.classList.remove('show');
      });
    }

    if (helpModal) {
      helpModal.addEventListener('click', (e) => {
        if (e.target === helpModal) {
          helpModal.classList.remove('show');
        }
      });
    }

    // Control mode modal
    const controlModeBtn = document.getElementById('controlModeBtn');
    const controlModeModal = document.getElementById('controlModeModal');
    const closeControlMode = document.getElementById('closeControlMode');
    const controlModeAbsolute = document.getElementById('controlModeAbsolute');
    const controlModeRelative = document.getElementById('controlModeRelative');

    if (controlModeBtn) {
      controlModeBtn.addEventListener('click', () => {
        controlModeModal.classList.add('show');
        if (menuDropdown) menuDropdown.classList.remove('show');
      });
    }

    if (closeControlMode) {
      closeControlMode.addEventListener('click', () => {
        controlModeModal.classList.remove('show');
      });
    }

    // Control mode modal should only close with X button, not by clicking outside

    const controlModeSelect = document.getElementById('controlModeSelect');
    const controlModeDescription = document.getElementById('controlModeDescription');
    
    // Description texts for each mode
    const modeDescriptions = {
      'none': 'No touch controls displayed. Use keyboard or swipe gestures to play.',
      'absolute': 'Up/Down/Left/Right buttons always move in those directions.',
      'relative': 'Buttons turn the snake left or right from its current facing direction.',
      'split': 'Left side: Up, Left, Down. Right side: Up, Right, Down. Split directional controls on both sides.'
    };
    
    // Set initial value and description
    if (controlModeSelect) {
      controlModeSelect.value = controlMode;
      if (controlModeDescription) {
        controlModeDescription.textContent = modeDescriptions[controlMode] || modeDescriptions['none'];
      }
    }

    function setControlMode(mode) {
      controlMode = mode;
      localStorage.setItem('controlMode', mode);
      updateDirectionButtons();
      // Update dropdown and description
      if (controlModeSelect) {
        controlModeSelect.value = mode;
      }
      if (controlModeDescription) {
        controlModeDescription.textContent = modeDescriptions[mode] || modeDescriptions['none'];
      }
      // Don't close the modal - let user see the controls change and close manually with X
    }
    
    // Handle dropdown change
    if (controlModeSelect) {
      controlModeSelect.addEventListener('change', (e) => {
        setControlMode(e.target.value);
      });
    }

    // Hamiltonian Path Configuration
    const hamiltonianPathBtn = document.getElementById('hamiltonianPathBtn');
    const hamiltonianPathModal = document.getElementById('hamiltonianPathModal');
    const closeHamiltonianPath = document.getElementById('closeHamiltonianPath');
    const hamiltonianPathCanvas = document.getElementById('hamiltonianPathCanvas');
    const clearHamiltonianPath = document.getElementById('clearHamiltonianPath');
    const importHamiltonianPath = document.getElementById('importHamiltonianPath');
    const exportHamiltonianPath = document.getElementById('exportHamiltonianPath');
    const saveHamiltonianPath = document.getElementById('saveHamiltonianPath');
    const hamiltonianPathFileInput = document.getElementById('hamiltonianPathFileInput');
    const hamiltonianStep = document.getElementById('hamiltonianStep');
    const hamiltonianTotal = document.getElementById('hamiltonianTotal');
    const hamiltonianRemaining = document.getElementById('hamiltonianRemaining');
    const hamiltonianPathStatus = document.getElementById('hamiltonianPathStatus');
    
    let currentPath = []; // Current path being drawn
    let isDrawing = false;
    let lastCell = null;
    let canvasCtx = null;
    let canvasCellSize = 0;
    let pathHistory = []; // History for undo/redo
    let historyIndex = -1; // Current position in history
    let maxHistorySize = 100; // Limit history size
    
    // Predefined Hamiltonian paths embedded in code
    const predefinedHamiltonianPaths = {
      basic: {
        name: "basic hamilton",
        path: [{"x":0,"y":0},{"x":0,"y":1},{"x":0,"y":2},{"x":0,"y":3},{"x":0,"y":4},{"x":0,"y":5},{"x":0,"y":6},{"x":0,"y":7},{"x":0,"y":8},{"x":0,"y":9},{"x":0,"y":10},{"x":0,"y":11},{"x":0,"y":12},{"x":0,"y":13},{"x":0,"y":14},{"x":0,"y":15},{"x":0,"y":16},{"x":0,"y":17},{"x":0,"y":18},{"x":0,"y":19},{"x":1,"y":19},{"x":2,"y":19},{"x":3,"y":19},{"x":4,"y":19},{"x":5,"y":19},{"x":6,"y":19},{"x":7,"y":19},{"x":8,"y":19},{"x":9,"y":19},{"x":10,"y":19},{"x":11,"y":19},{"x":12,"y":19},{"x":13,"y":19},{"x":14,"y":19},{"x":15,"y":19},{"x":16,"y":19},{"x":17,"y":19},{"x":18,"y":19},{"x":19,"y":19},{"x":19,"y":18},{"x":18,"y":18},{"x":17,"y":18},{"x":16,"y":18},{"x":15,"y":18},{"x":14,"y":18},{"x":13,"y":18},{"x":12,"y":18},{"x":11,"y":18},{"x":10,"y":18},{"x":9,"y":18},{"x":8,"y":18},{"x":7,"y":18},{"x":6,"y":18},{"x":5,"y":18},{"x":4,"y":18},{"x":3,"y":18},{"x":2,"y":18},{"x":1,"y":18},{"x":1,"y":17},{"x":2,"y":17},{"x":3,"y":17},{"x":4,"y":17},{"x":5,"y":17},{"x":6,"y":17},{"x":7,"y":17},{"x":8,"y":17},{"x":9,"y":17},{"x":10,"y":17},{"x":11,"y":17},{"x":12,"y":17},{"x":13,"y":17},{"x":14,"y":17},{"x":15,"y":17},{"x":16,"y":17},{"x":17,"y":17},{"x":18,"y":17},{"x":19,"y":17},{"x":19,"y":16},{"x":18,"y":16},{"x":17,"y":16},{"x":16,"y":16},{"x":15,"y":16},{"x":14,"y":16},{"x":13,"y":16},{"x":12,"y":16},{"x":11,"y":16},{"x":10,"y":16},{"x":9,"y":16},{"x":8,"y":16},{"x":7,"y":16},{"x":6,"y":16},{"x":5,"y":16},{"x":4,"y":16},{"x":3,"y":16},{"x":2,"y":16},{"x":1,"y":16},{"x":1,"y":15},{"x":2,"y":15},{"x":3,"y":15},{"x":4,"y":15},{"x":5,"y":15},{"x":6,"y":15},{"x":7,"y":15},{"x":8,"y":15},{"x":9,"y":15},{"x":10,"y":15},{"x":11,"y":15},{"x":12,"y":15},{"x":13,"y":15},{"x":14,"y":15},{"x":15,"y":15},{"x":16,"y":15},{"x":17,"y":15},{"x":18,"y":15},{"x":19,"y":15},{"x":19,"y":14},{"x":18,"y":14},{"x":17,"y":14},{"x":16,"y":14},{"x":15,"y":14},{"x":14,"y":14},{"x":13,"y":14},{"x":12,"y":14},{"x":11,"y":14},{"x":10,"y":14},{"x":9,"y":14},{"x":8,"y":14},{"x":7,"y":14},{"x":6,"y":14},{"x":5,"y":14},{"x":4,"y":14},{"x":3,"y":14},{"x":2,"y":14},{"x":1,"y":14},{"x":1,"y":13},{"x":2,"y":13},{"x":3,"y":13},{"x":4,"y":13},{"x":5,"y":13},{"x":6,"y":13},{"x":7,"y":13},{"x":8,"y":13},{"x":9,"y":13},{"x":10,"y":13},{"x":11,"y":13},{"x":12,"y":13},{"x":13,"y":13},{"x":14,"y":13},{"x":15,"y":13},{"x":16,"y":13},{"x":17,"y":13},{"x":18,"y":13},{"x":19,"y":13},{"x":19,"y":12},{"x":18,"y":12},{"x":17,"y":12},{"x":16,"y":12},{"x":15,"y":12},{"x":14,"y":12},{"x":13,"y":12},{"x":12,"y":12},{"x":11,"y":12},{"x":10,"y":12},{"x":9,"y":12},{"x":8,"y":12},{"x":7,"y":12},{"x":6,"y":12},{"x":5,"y":12},{"x":4,"y":12},{"x":3,"y":12},{"x":2,"y":12},{"x":1,"y":12},{"x":1,"y":11},{"x":2,"y":11},{"x":3,"y":11},{"x":4,"y":11},{"x":5,"y":11},{"x":6,"y":11},{"x":7,"y":11},{"x":8,"y":11},{"x":9,"y":11},{"x":10,"y":11},{"x":11,"y":11},{"x":12,"y":11},{"x":13,"y":11},{"x":14,"y":11},{"x":15,"y":11},{"x":16,"y":11},{"x":17,"y":11},{"x":18,"y":11},{"x":19,"y":11},{"x":19,"y":10},{"x":18,"y":10},{"x":17,"y":10},{"x":16,"y":10},{"x":15,"y":10},{"x":14,"y":10},{"x":13,"y":10},{"x":12,"y":10},{"x":11,"y":10},{"x":10,"y":10},{"x":9,"y":10},{"x":8,"y":10},{"x":7,"y":10},{"x":6,"y":10},{"x":5,"y":10},{"x":4,"y":10},{"x":3,"y":10},{"x":2,"y":10},{"x":1,"y":10},{"x":1,"y":9},{"x":2,"y":9},{"x":3,"y":9},{"x":4,"y":9},{"x":5,"y":9},{"x":6,"y":9},{"x":7,"y":9},{"x":8,"y":9},{"x":9,"y":9},{"x":10,"y":9},{"x":11,"y":9},{"x":12,"y":9},{"x":13,"y":9},{"x":14,"y":9},{"x":15,"y":9},{"x":16,"y":9},{"x":17,"y":9},{"x":18,"y":9},{"x":19,"y":9},{"x":19,"y":8},{"x":18,"y":8},{"x":17,"y":8},{"x":16,"y":8},{"x":15,"y":8},{"x":14,"y":8},{"x":13,"y":8},{"x":12,"y":8},{"x":11,"y":8},{"x":10,"y":8},{"x":9,"y":8},{"x":8,"y":8},{"x":7,"y":8},{"x":6,"y":8},{"x":5,"y":8},{"x":4,"y":8},{"x":3,"y":8},{"x":2,"y":8},{"x":1,"y":8},{"x":1,"y":7},{"x":2,"y":7},{"x":3,"y":7},{"x":4,"y":7},{"x":5,"y":7},{"x":6,"y":7},{"x":7,"y":7},{"x":8,"y":7},{"x":9,"y":7},{"x":10,"y":7},{"x":11,"y":7},{"x":12,"y":7},{"x":13,"y":7},{"x":14,"y":7},{"x":15,"y":7},{"x":16,"y":7},{"x":17,"y":7},{"x":18,"y":7},{"x":19,"y":7},{"x":19,"y":6},{"x":18,"y":6},{"x":17,"y":6},{"x":16,"y":6},{"x":15,"y":6},{"x":14,"y":6},{"x":13,"y":6},{"x":12,"y":6},{"x":11,"y":6},{"x":10,"y":6},{"x":9,"y":6},{"x":8,"y":6},{"x":7,"y":6},{"x":6,"y":6},{"x":5,"y":6},{"x":4,"y":6},{"x":3,"y":6},{"x":2,"y":6},{"x":1,"y":6},{"x":1,"y":5},{"x":2,"y":5},{"x":3,"y":5},{"x":4,"y":5},{"x":5,"y":5},{"x":6,"y":5},{"x":7,"y":5},{"x":8,"y":5},{"x":9,"y":5},{"x":10,"y":5},{"x":11,"y":5},{"x":12,"y":5},{"x":13,"y":5},{"x":14,"y":5},{"x":15,"y":5},{"x":16,"y":5},{"x":17,"y":5},{"x":18,"y":5},{"x":19,"y":5},{"x":19,"y":4},{"x":18,"y":4},{"x":17,"y":4},{"x":16,"y":4},{"x":15,"y":4},{"x":14,"y":4},{"x":13,"y":4},{"x":12,"y":4},{"x":11,"y":4},{"x":10,"y":4},{"x":9,"y":4},{"x":8,"y":4},{"x":7,"y":4},{"x":6,"y":4},{"x":5,"y":4},{"x":4,"y":4},{"x":3,"y":4},{"x":2,"y":4},{"x":1,"y":4},{"x":1,"y":3},{"x":2,"y":3},{"x":3,"y":3},{"x":4,"y":3},{"x":5,"y":3},{"x":6,"y":3},{"x":7,"y":3},{"x":8,"y":3},{"x":9,"y":3},{"x":10,"y":3},{"x":11,"y":3},{"x":12,"y":3},{"x":13,"y":3},{"x":14,"y":3},{"x":15,"y":3},{"x":16,"y":3},{"x":17,"y":3},{"x":18,"y":3},{"x":19,"y":3},{"x":19,"y":2},{"x":18,"y":2},{"x":17,"y":2},{"x":16,"y":2},{"x":15,"y":2},{"x":14,"y":2},{"x":13,"y":2},{"x":12,"y":2},{"x":11,"y":2},{"x":10,"y":2},{"x":9,"y":2},{"x":8,"y":2},{"x":7,"y":2},{"x":6,"y":2},{"x":5,"y":2},{"x":4,"y":2},{"x":3,"y":2},{"x":2,"y":2},{"x":1,"y":2},{"x":1,"y":1},{"x":2,"y":1},{"x":3,"y":1},{"x":4,"y":1},{"x":5,"y":1},{"x":6,"y":1},{"x":7,"y":1},{"x":8,"y":1},{"x":9,"y":1},{"x":10,"y":1},{"x":11,"y":1},{"x":12,"y":1},{"x":13,"y":1},{"x":14,"y":1},{"x":15,"y":1},{"x":16,"y":1},{"x":17,"y":1},{"x":18,"y":1},{"x":19,"y":1},{"x":19,"y":0},{"x":18,"y":0},{"x":17,"y":0},{"x":16,"y":0},{"x":15,"y":0},{"x":14,"y":0},{"x":13,"y":0},{"x":12,"y":0},{"x":11,"y":0},{"x":10,"y":0},{"x":9,"y":0},{"x":8,"y":0},{"x":7,"y":0},{"x":6,"y":0},{"x":5,"y":0},{"x":4,"y":0},{"x":3,"y":0},{"x":2,"y":0},{"x":1,"y":0},{"x":0,"y":0}]
      },
      christmas: {
        name: "christmas tree",
        path: [{"x":0,"y":0},{"x":1,"y":0},{"x":2,"y":0},{"x":3,"y":0},{"x":4,"y":0},{"x":5,"y":0},{"x":6,"y":0},{"x":7,"y":0},{"x":8,"y":0},{"x":9,"y":0},{"x":9,"y":1},{"x":9,"y":2},{"x":10,"y":2},{"x":10,"y":3},{"x":9,"y":3},{"x":8,"y":3},{"x":8,"y":4},{"x":9,"y":4},{"x":10,"y":4},{"x":11,"y":4},{"x":11,"y":5},{"x":10,"y":5},{"x":9,"y":5},{"x":8,"y":5},{"x":7,"y":5},{"x":7,"y":6},{"x":8,"y":6},{"x":9,"y":6},{"x":10,"y":6},{"x":11,"y":6},{"x":12,"y":6},{"x":12,"y":7},{"x":11,"y":7},{"x":10,"y":7},{"x":9,"y":7},{"x":8,"y":7},{"x":7,"y":7},{"x":6,"y":7},{"x":6,"y":8},{"x":7,"y":8},{"x":8,"y":8},{"x":9,"y":8},{"x":10,"y":8},{"x":11,"y":8},{"x":12,"y":8},{"x":13,"y":8},{"x":13,"y":9},{"x":12,"y":9},{"x":11,"y":9},{"x":10,"y":9},{"x":9,"y":9},{"x":8,"y":9},{"x":7,"y":9},{"x":6,"y":9},{"x":5,"y":9},{"x":5,"y":10},{"x":6,"y":10},{"x":7,"y":10},{"x":8,"y":10},{"x":9,"y":10},{"x":10,"y":10},{"x":11,"y":10},{"x":12,"y":10},{"x":13,"y":10},{"x":14,"y":10},{"x":14,"y":11},{"x":13,"y":11},{"x":12,"y":11},{"x":11,"y":11},{"x":10,"y":11},{"x":9,"y":11},{"x":8,"y":11},{"x":7,"y":11},{"x":6,"y":11},{"x":5,"y":11},{"x":4,"y":11},{"x":4,"y":12},{"x":5,"y":12},{"x":6,"y":12},{"x":7,"y":12},{"x":8,"y":12},{"x":9,"y":12},{"x":10,"y":12},{"x":11,"y":12},{"x":12,"y":12},{"x":13,"y":12},{"x":14,"y":12},{"x":15,"y":12},{"x":15,"y":13},{"x":14,"y":13},{"x":13,"y":13},{"x":12,"y":13},{"x":11,"y":13},{"x":10,"y":13},{"x":9,"y":13},{"x":8,"y":13},{"x":7,"y":13},{"x":6,"y":13},{"x":5,"y":13},{"x":4,"y":13},{"x":3,"y":13},{"x":3,"y":14},{"x":4,"y":14},{"x":5,"y":14},{"x":6,"y":14},{"x":7,"y":14},{"x":8,"y":14},{"x":9,"y":14},{"x":10,"y":14},{"x":11,"y":14},{"x":12,"y":14},{"x":13,"y":14},{"x":14,"y":14},{"x":15,"y":14},{"x":16,"y":14},{"x":16,"y":15},{"x":15,"y":15},{"x":14,"y":15},{"x":13,"y":15},{"x":12,"y":15},{"x":11,"y":15},{"x":10,"y":15},{"x":9,"y":15},{"x":8,"y":15},{"x":7,"y":15},{"x":6,"y":15},{"x":5,"y":15},{"x":4,"y":15},{"x":3,"y":15},{"x":2,"y":15},{"x":2,"y":16},{"x":3,"y":16},{"x":4,"y":16},{"x":5,"y":16},{"x":6,"y":16},{"x":7,"y":16},{"x":8,"y":16},{"x":9,"y":16},{"x":10,"y":16},{"x":11,"y":16},{"x":12,"y":16},{"x":13,"y":16},{"x":14,"y":16},{"x":15,"y":16},{"x":16,"y":16},{"x":17,"y":16},{"x":17,"y":17},{"x":16,"y":17},{"x":15,"y":17},{"x":14,"y":17},{"x":13,"y":17},{"x":12,"y":17},{"x":11,"y":17},{"x":10,"y":17},{"x":10,"y":18},{"x":11,"y":18},{"x":12,"y":18},{"x":13,"y":18},{"x":14,"y":18},{"x":15,"y":18},{"x":16,"y":18},{"x":17,"y":18},{"x":18,"y":18},{"x":18,"y":17},{"x":18,"y":16},{"x":18,"y":15},{"x":17,"y":15},{"x":17,"y":14},{"x":17,"y":13},{"x":16,"y":13},{"x":16,"y":12},{"x":16,"y":11},{"x":15,"y":11},{"x":15,"y":10},{"x":15,"y":9},{"x":14,"y":9},{"x":14,"y":8},{"x":14,"y":7},{"x":13,"y":7},{"x":13,"y":6},{"x":13,"y":5},{"x":12,"y":5},{"x":12,"y":4},{"x":12,"y":3},{"x":11,"y":3},{"x":11,"y":2},{"x":11,"y":1},{"x":10,"y":1},{"x":10,"y":0},{"x":11,"y":0},{"x":12,"y":0},{"x":12,"y":1},{"x":12,"y":2},{"x":13,"y":2},{"x":13,"y":3},{"x":13,"y":4},{"x":14,"y":4},{"x":14,"y":5},{"x":14,"y":6},{"x":15,"y":6},{"x":15,"y":7},{"x":15,"y":8},{"x":16,"y":8},{"x":16,"y":9},{"x":16,"y":10},{"x":17,"y":10},{"x":17,"y":11},{"x":17,"y":12},{"x":18,"y":12},{"x":18,"y":11},{"x":18,"y":10},{"x":18,"y":9},{"x":17,"y":9},{"x":17,"y":8},{"x":17,"y":7},{"x":16,"y":7},{"x":16,"y":6},{"x":16,"y":5},{"x":15,"y":5},{"x":15,"y":4},{"x":15,"y":3},{"x":14,"y":3},{"x":14,"y":2},{"x":14,"y":1},{"x":13,"y":1},{"x":13,"y":0},{"x":14,"y":0},{"x":15,"y":0},{"x":15,"y":1},{"x":15,"y":2},{"x":16,"y":2},{"x":16,"y":3},{"x":16,"y":4},{"x":17,"y":4},{"x":17,"y":5},{"x":17,"y":6},{"x":18,"y":6},{"x":18,"y":5},{"x":18,"y":4},{"x":18,"y":3},{"x":17,"y":3},{"x":17,"y":2},{"x":17,"y":1},{"x":16,"y":1},{"x":16,"y":0},{"x":17,"y":0},{"x":18,"y":0},{"x":19,"y":0},{"x":19,"y":1},{"x":18,"y":1},{"x":18,"y":2},{"x":19,"y":2},{"x":19,"y":3},{"x":19,"y":4},{"x":19,"y":5},{"x":19,"y":6},{"x":19,"y":7},{"x":18,"y":7},{"x":18,"y":8},{"x":19,"y":8},{"x":19,"y":9},{"x":19,"y":10},{"x":19,"y":11},{"x":19,"y":12},{"x":19,"y":13},{"x":18,"y":13},{"x":18,"y":14},{"x":19,"y":14},{"x":19,"y":15},{"x":19,"y":16},{"x":19,"y":17},{"x":19,"y":18},{"x":19,"y":19},{"x":18,"y":19},{"x":17,"y":19},{"x":16,"y":19},{"x":15,"y":19},{"x":14,"y":19},{"x":13,"y":19},{"x":12,"y":19},{"x":11,"y":19},{"x":10,"y":19},{"x":9,"y":19},{"x":8,"y":19},{"x":7,"y":19},{"x":6,"y":19},{"x":5,"y":19},{"x":4,"y":19},{"x":3,"y":19},{"x":2,"y":19},{"x":1,"y":19},{"x":0,"y":19},{"x":0,"y":18},{"x":1,"y":18},{"x":2,"y":18},{"x":3,"y":18},{"x":4,"y":18},{"x":5,"y":18},{"x":6,"y":18},{"x":7,"y":18},{"x":8,"y":18},{"x":9,"y":18},{"x":9,"y":17},{"x":8,"y":17},{"x":7,"y":17},{"x":6,"y":17},{"x":5,"y":17},{"x":4,"y":17},{"x":3,"y":17},{"x":2,"y":17},{"x":1,"y":17},{"x":0,"y":17},{"x":0,"y":16},{"x":1,"y":16},{"x":1,"y":15},{"x":0,"y":15},{"x":0,"y":14},{"x":1,"y":14},{"x":2,"y":14},{"x":2,"y":13},{"x":2,"y":12},{"x":3,"y":12},{"x":3,"y":11},{"x":3,"y":10},{"x":4,"y":10},{"x":4,"y":9},{"x":4,"y":8},{"x":5,"y":8},{"x":5,"y":7},{"x":5,"y":6},{"x":6,"y":6},{"x":6,"y":5},{"x":6,"y":4},{"x":7,"y":4},{"x":7,"y":3},{"x":7,"y":2},{"x":8,"y":2},{"x":8,"y":1},{"x":7,"y":1},{"x":6,"y":1},{"x":6,"y":2},{"x":6,"y":3},{"x":5,"y":3},{"x":5,"y":4},{"x":5,"y":5},{"x":4,"y":5},{"x":4,"y":6},{"x":4,"y":7},{"x":3,"y":7},{"x":3,"y":8},{"x":3,"y":9},{"x":2,"y":9},{"x":2,"y":10},{"x":2,"y":11},{"x":1,"y":11},{"x":1,"y":12},{"x":1,"y":13},{"x":0,"y":13},{"x":0,"y":12},{"x":0,"y":11},{"x":0,"y":10},{"x":1,"y":10},{"x":1,"y":9},{"x":0,"y":9},{"x":0,"y":8},{"x":1,"y":8},{"x":2,"y":8},{"x":2,"y":7},{"x":2,"y":6},{"x":3,"y":6},{"x":3,"y":5},{"x":3,"y":4},{"x":4,"y":4},{"x":4,"y":3},{"x":4,"y":2},{"x":5,"y":2},{"x":5,"y":1},{"x":4,"y":1},{"x":3,"y":1},{"x":3,"y":2},{"x":3,"y":3},{"x":2,"y":3},{"x":2,"y":4},{"x":2,"y":5},{"x":1,"y":5},{"x":1,"y":6},{"x":1,"y":7},{"x":0,"y":7},{"x":0,"y":6},{"x":0,"y":5},{"x":0,"y":4},{"x":1,"y":4},{"x":1,"y":3},{"x":0,"y":3},{"x":0,"y":2},{"x":1,"y":2},{"x":2,"y":2},{"x":2,"y":1},{"x":1,"y":1},{"x":0,"y":1},{"x":0,"y":0}]
      },
      spaghetti: {
        name: "spaghetti",
        path: [{"x":0,"y":0},{"x":0,"y":1},{"x":0,"y":2},{"x":0,"y":3},{"x":0,"y":4},{"x":0,"y":5},{"x":0,"y":6},{"x":0,"y":7},{"x":0,"y":8},{"x":0,"y":9},{"x":0,"y":10},{"x":0,"y":11},{"x":0,"y":12},{"x":0,"y":13},{"x":0,"y":14},{"x":0,"y":15},{"x":0,"y":16},{"x":0,"y":17},{"x":0,"y":18},{"x":0,"y":19},{"x":1,"y":19},{"x":1,"y":18},{"x":1,"y":17},{"x":1,"y":16},{"x":1,"y":15},{"x":1,"y":14},{"x":1,"y":13},{"x":1,"y":12},{"x":1,"y":11},{"x":1,"y":10},{"x":1,"y":9},{"x":1,"y":8},{"x":1,"y":7},{"x":1,"y":6},{"x":1,"y":5},{"x":1,"y":4},{"x":1,"y":3},{"x":1,"y":2},{"x":1,"y":1},{"x":2,"y":1},{"x":3,"y":1},{"x":4,"y":1},{"x":4,"y":2},{"x":3,"y":2},{"x":2,"y":2},{"x":2,"y":3},{"x":3,"y":3},{"x":4,"y":3},{"x":4,"y":4},{"x":3,"y":4},{"x":2,"y":4},{"x":2,"y":5},{"x":2,"y":6},{"x":2,"y":7},{"x":2,"y":8},{"x":2,"y":9},{"x":3,"y":9},{"x":4,"y":9},{"x":4,"y":8},{"x":3,"y":8},{"x":3,"y":7},{"x":3,"y":6},{"x":3,"y":5},{"x":4,"y":5},{"x":5,"y":5},{"x":6,"y":5},{"x":6,"y":6},{"x":5,"y":6},{"x":4,"y":6},{"x":4,"y":7},{"x":5,"y":7},{"x":5,"y":8},{"x":5,"y":9},{"x":5,"y":10},{"x":4,"y":10},{"x":3,"y":10},{"x":2,"y":10},{"x":2,"y":11},{"x":2,"y":12},{"x":2,"y":13},{"x":3,"y":13},{"x":3,"y":12},{"x":3,"y":11},{"x":4,"y":11},{"x":4,"y":12},{"x":4,"y":13},{"x":4,"y":14},{"x":3,"y":14},{"x":2,"y":14},{"x":2,"y":15},{"x":3,"y":15},{"x":4,"y":15},{"x":5,"y":15},{"x":6,"y":15},{"x":7,"y":15},{"x":8,"y":15},{"x":9,"y":15},{"x":10,"y":15},{"x":11,"y":15},{"x":12,"y":15},{"x":13,"y":15},{"x":14,"y":15},{"x":15,"y":15},{"x":16,"y":15},{"x":16,"y":16},{"x":15,"y":16},{"x":14,"y":16},{"x":13,"y":16},{"x":12,"y":16},{"x":11,"y":16},{"x":10,"y":16},{"x":9,"y":16},{"x":8,"y":16},{"x":7,"y":16},{"x":6,"y":16},{"x":5,"y":16},{"x":4,"y":16},{"x":3,"y":16},{"x":2,"y":16},{"x":2,"y":17},{"x":3,"y":17},{"x":4,"y":17},{"x":5,"y":17},{"x":6,"y":17},{"x":7,"y":17},{"x":8,"y":17},{"x":9,"y":17},{"x":10,"y":17},{"x":11,"y":17},{"x":12,"y":17},{"x":13,"y":17},{"x":14,"y":17},{"x":15,"y":17},{"x":16,"y":17},{"x":17,"y":17},{"x":17,"y":18},{"x":16,"y":18},{"x":15,"y":18},{"x":14,"y":18},{"x":13,"y":18},{"x":12,"y":18},{"x":11,"y":18},{"x":10,"y":18},{"x":9,"y":18},{"x":8,"y":18},{"x":7,"y":18},{"x":6,"y":18},{"x":5,"y":18},{"x":4,"y":18},{"x":3,"y":18},{"x":2,"y":18},{"x":2,"y":19},{"x":3,"y":19},{"x":4,"y":19},{"x":5,"y":19},{"x":6,"y":19},{"x":7,"y":19},{"x":8,"y":19},{"x":9,"y":19},{"x":10,"y":19},{"x":11,"y":19},{"x":12,"y":19},{"x":13,"y":19},{"x":14,"y":19},{"x":15,"y":19},{"x":16,"y":19},{"x":17,"y":19},{"x":18,"y":19},{"x":19,"y":19},{"x":19,"y":18},{"x":18,"y":18},{"x":18,"y":17},{"x":19,"y":17},{"x":19,"y":16},{"x":18,"y":16},{"x":17,"y":16},{"x":17,"y":15},{"x":18,"y":15},{"x":19,"y":15},{"x":19,"y":14},{"x":18,"y":14},{"x":17,"y":14},{"x":16,"y":14},{"x":15,"y":14},{"x":14,"y":14},{"x":13,"y":14},{"x":12,"y":14},{"x":11,"y":14},{"x":10,"y":14},{"x":9,"y":14},{"x":8,"y":14},{"x":7,"y":14},{"x":6,"y":14},{"x":5,"y":14},{"x":5,"y":13},{"x":5,"y":12},{"x":5,"y":11},{"x":6,"y":11},{"x":6,"y":12},{"x":6,"y":13},{"x":7,"y":13},{"x":7,"y":12},{"x":7,"y":11},{"x":7,"y":10},{"x":6,"y":10},{"x":6,"y":9},{"x":6,"y":8},{"x":6,"y":7},{"x":7,"y":7},{"x":7,"y":8},{"x":7,"y":9},{"x":8,"y":9},{"x":9,"y":9},{"x":10,"y":9},{"x":11,"y":9},{"x":12,"y":9},{"x":12,"y":10},{"x":11,"y":10},{"x":10,"y":10},{"x":9,"y":10},{"x":8,"y":10},{"x":8,"y":11},{"x":9,"y":11},{"x":10,"y":11},{"x":11,"y":11},{"x":12,"y":11},{"x":13,"y":11},{"x":13,"y":12},{"x":12,"y":12},{"x":11,"y":12},{"x":10,"y":12},{"x":9,"y":12},{"x":8,"y":12},{"x":8,"y":13},{"x":9,"y":13},{"x":10,"y":13},{"x":11,"y":13},{"x":12,"y":13},{"x":13,"y":13},{"x":14,"y":13},{"x":15,"y":13},{"x":16,"y":13},{"x":17,"y":13},{"x":18,"y":13},{"x":19,"y":13},{"x":19,"y":12},{"x":18,"y":12},{"x":17,"y":12},{"x":16,"y":12},{"x":15,"y":12},{"x":14,"y":12},{"x":14,"y":11},{"x":14,"y":10},{"x":13,"y":10},{"x":13,"y":9},{"x":13,"y":8},{"x":12,"y":8},{"x":11,"y":8},{"x":10,"y":8},{"x":9,"y":8},{"x":8,"y":8},{"x":8,"y":7},{"x":8,"y":6},{"x":7,"y":6},{"x":7,"y":5},{"x":8,"y":5},{"x":9,"y":5},{"x":9,"y":6},{"x":9,"y":7},{"x":10,"y":7},{"x":11,"y":7},{"x":12,"y":7},{"x":13,"y":7},{"x":14,"y":7},{"x":14,"y":8},{"x":14,"y":9},{"x":15,"y":9},{"x":15,"y":10},{"x":15,"y":11},{"x":16,"y":11},{"x":17,"y":11},{"x":18,"y":11},{"x":19,"y":11},{"x":19,"y":10},{"x":18,"y":10},{"x":17,"y":10},{"x":16,"y":10},{"x":16,"y":9},{"x":17,"y":9},{"x":18,"y":9},{"x":19,"y":9},{"x":19,"y":8},{"x":19,"y":7},{"x":19,"y":6},{"x":19,"y":5},{"x":19,"y":4},{"x":19,"y":3},{"x":19,"y":2},{"x":19,"y":1},{"x":19,"y":0},{"x":18,"y":0},{"x":18,"y":1},{"x":18,"y":2},{"x":18,"y":3},{"x":18,"y":4},{"x":18,"y":5},{"x":18,"y":6},{"x":18,"y":7},{"x":18,"y":8},{"x":17,"y":8},{"x":16,"y":8},{"x":15,"y":8},{"x":15,"y":7},{"x":16,"y":7},{"x":17,"y":7},{"x":17,"y":6},{"x":17,"y":5},{"x":17,"y":4},{"x":17,"y":3},{"x":17,"y":2},{"x":17,"y":1},{"x":17,"y":0},{"x":16,"y":0},{"x":16,"y":1},{"x":16,"y":2},{"x":15,"y":2},{"x":15,"y":1},{"x":15,"y":0},{"x":14,"y":0},{"x":14,"y":1},{"x":13,"y":1},{"x":13,"y":0},{"x":12,"y":0},{"x":11,"y":0},{"x":10,"y":0},{"x":10,"y":1},{"x":11,"y":1},{"x":12,"y":1},{"x":12,"y":2},{"x":13,"y":2},{"x":14,"y":2},{"x":14,"y":3},{"x":15,"y":3},{"x":16,"y":3},{"x":16,"y":4},{"x":16,"y":5},{"x":16,"y":6},{"x":15,"y":6},{"x":15,"y":5},{"x":15,"y":4},{"x":14,"y":4},{"x":14,"y":5},{"x":14,"y":6},{"x":13,"y":6},{"x":13,"y":5},{"x":13,"y":4},{"x":13,"y":3},{"x":12,"y":3},{"x":12,"y":4},{"x":12,"y":5},{"x":12,"y":6},{"x":11,"y":6},{"x":10,"y":6},{"x":10,"y":5},{"x":11,"y":5},{"x":11,"y":4},{"x":11,"y":3},{"x":11,"y":2},{"x":10,"y":2},{"x":10,"y":3},{"x":10,"y":4},{"x":9,"y":4},{"x":9,"y":3},{"x":9,"y":2},{"x":9,"y":1},{"x":9,"y":0},{"x":8,"y":0},{"x":8,"y":1},{"x":8,"y":2},{"x":8,"y":3},{"x":8,"y":4},{"x":7,"y":4},{"x":7,"y":3},{"x":7,"y":2},{"x":7,"y":1},{"x":7,"y":0},{"x":6,"y":0},{"x":6,"y":1},{"x":6,"y":2},{"x":6,"y":3},{"x":6,"y":4},{"x":5,"y":4},{"x":5,"y":3},{"x":5,"y":2},{"x":5,"y":1},{"x":5,"y":0},{"x":4,"y":0},{"x":3,"y":0},{"x":2,"y":0},{"x":1,"y":0},{"x":0,"y":0}]
      },
      squiggle: {
        name: "squiggle",
        path: [{"x":0,"y":0},{"x":1,"y":0},{"x":2,"y":0},{"x":2,"y":1},{"x":3,"y":1},{"x":3,"y":0},{"x":4,"y":0},{"x":4,"y":1},{"x":5,"y":1},{"x":5,"y":0},{"x":6,"y":0},{"x":6,"y":1},{"x":7,"y":1},{"x":7,"y":0},{"x":8,"y":0},{"x":8,"y":1},{"x":9,"y":1},{"x":9,"y":0},{"x":10,"y":0},{"x":10,"y":1},{"x":11,"y":1},{"x":11,"y":0},{"x":12,"y":0},{"x":12,"y":1},{"x":13,"y":1},{"x":13,"y":0},{"x":14,"y":0},{"x":14,"y":1},{"x":15,"y":1},{"x":15,"y":0},{"x":16,"y":0},{"x":16,"y":1},{"x":17,"y":1},{"x":17,"y":0},{"x":18,"y":0},{"x":19,"y":0},{"x":19,"y":1},{"x":18,"y":1},{"x":18,"y":2},{"x":19,"y":2},{"x":19,"y":3},{"x":18,"y":3},{"x":18,"y":4},{"x":19,"y":4},{"x":19,"y":5},{"x":18,"y":5},{"x":18,"y":6},{"x":19,"y":6},{"x":19,"y":7},{"x":18,"y":7},{"x":18,"y":8},{"x":19,"y":8},{"x":19,"y":9},{"x":18,"y":9},{"x":18,"y":10},{"x":19,"y":10},{"x":19,"y":11},{"x":18,"y":11},{"x":18,"y":12},{"x":19,"y":12},{"x":19,"y":13},{"x":18,"y":13},{"x":18,"y":14},{"x":19,"y":14},{"x":19,"y":15},{"x":18,"y":15},{"x":18,"y":16},{"x":19,"y":16},{"x":19,"y":17},{"x":18,"y":17},{"x":18,"y":18},{"x":19,"y":18},{"x":19,"y":19},{"x":18,"y":19},{"x":17,"y":19},{"x":17,"y":18},{"x":16,"y":18},{"x":16,"y":19},{"x":15,"y":19},{"x":15,"y":18},{"x":14,"y":18},{"x":14,"y":19},{"x":13,"y":19},{"x":13,"y":18},{"x":12,"y":18},{"x":12,"y":19},{"x":11,"y":19},{"x":11,"y":18},{"x":10,"y":18},{"x":10,"y":19},{"x":9,"y":19},{"x":9,"y":18},{"x":8,"y":18},{"x":8,"y":19},{"x":7,"y":19},{"x":7,"y":18},{"x":6,"y":18},{"x":6,"y":19},{"x":5,"y":19},{"x":5,"y":18},{"x":4,"y":18},{"x":4,"y":19},{"x":3,"y":19},{"x":3,"y":18},{"x":2,"y":18},{"x":2,"y":19},{"x":1,"y":19},{"x":0,"y":19},{"x":0,"y":18},{"x":1,"y":18},{"x":1,"y":17},{"x":0,"y":17},{"x":0,"y":16},{"x":1,"y":16},{"x":1,"y":15},{"x":0,"y":15},{"x":0,"y":14},{"x":1,"y":14},{"x":1,"y":13},{"x":0,"y":13},{"x":0,"y":12},{"x":1,"y":12},{"x":1,"y":11},{"x":0,"y":11},{"x":0,"y":10},{"x":1,"y":10},{"x":1,"y":9},{"x":0,"y":9},{"x":0,"y":8},{"x":1,"y":8},{"x":1,"y":7},{"x":0,"y":7},{"x":0,"y":6},{"x":1,"y":6},{"x":1,"y":5},{"x":0,"y":5},{"x":0,"y":4},{"x":1,"y":4},{"x":2,"y":4},{"x":3,"y":4},{"x":3,"y":5},{"x":2,"y":5},{"x":2,"y":6},{"x":3,"y":6},{"x":3,"y":7},{"x":2,"y":7},{"x":2,"y":8},{"x":3,"y":8},{"x":3,"y":9},{"x":2,"y":9},{"x":2,"y":10},{"x":3,"y":10},{"x":3,"y":11},{"x":2,"y":11},{"x":2,"y":12},{"x":3,"y":12},{"x":3,"y":13},{"x":2,"y":13},{"x":2,"y":14},{"x":3,"y":14},{"x":3,"y":15},{"x":2,"y":15},{"x":2,"y":16},{"x":2,"y":17},{"x":3,"y":17},{"x":3,"y":16},{"x":4,"y":16},{"x":4,"y":17},{"x":5,"y":17},{"x":5,"y":16},{"x":6,"y":16},{"x":6,"y":17},{"x":7,"y":17},{"x":7,"y":16},{"x":8,"y":16},{"x":8,"y":17},{"x":9,"y":17},{"x":9,"y":16},{"x":10,"y":16},{"x":10,"y":17},{"x":11,"y":17},{"x":11,"y":16},{"x":12,"y":16},{"x":12,"y":17},{"x":13,"y":17},{"x":13,"y":16},{"x":14,"y":16},{"x":14,"y":17},{"x":15,"y":17},{"x":15,"y":16},{"x":16,"y":16},{"x":16,"y":17},{"x":17,"y":17},{"x":17,"y":16},{"x":17,"y":15},{"x":16,"y":15},{"x":16,"y":14},{"x":17,"y":14},{"x":17,"y":13},{"x":16,"y":13},{"x":16,"y":12},{"x":17,"y":12},{"x":17,"y":11},{"x":16,"y":11},{"x":16,"y":10},{"x":17,"y":10},{"x":17,"y":9},{"x":16,"y":9},{"x":16,"y":8},{"x":17,"y":8},{"x":17,"y":7},{"x":16,"y":7},{"x":16,"y":6},{"x":17,"y":6},{"x":17,"y":5},{"x":16,"y":5},{"x":16,"y":4},{"x":17,"y":4},{"x":17,"y":3},{"x":17,"y":2},{"x":16,"y":2},{"x":16,"y":3},{"x":15,"y":3},{"x":15,"y":2},{"x":14,"y":2},{"x":14,"y":3},{"x":14,"y":4},{"x":15,"y":4},{"x":15,"y":5},{"x":14,"y":5},{"x":14,"y":6},{"x":15,"y":6},{"x":15,"y":7},{"x":14,"y":7},{"x":14,"y":8},{"x":15,"y":8},{"x":15,"y":9},{"x":14,"y":9},{"x":14,"y":10},{"x":15,"y":10},{"x":15,"y":11},{"x":14,"y":11},{"x":14,"y":12},{"x":15,"y":12},{"x":15,"y":13},{"x":14,"y":13},{"x":14,"y":14},{"x":15,"y":14},{"x":15,"y":15},{"x":14,"y":15},{"x":13,"y":15},{"x":13,"y":14},{"x":12,"y":14},{"x":12,"y":15},{"x":11,"y":15},{"x":11,"y":14},{"x":10,"y":14},{"x":10,"y":15},{"x":9,"y":15},{"x":9,"y":14},{"x":8,"y":14},{"x":8,"y":15},{"x":7,"y":15},{"x":7,"y":14},{"x":6,"y":14},{"x":6,"y":15},{"x":5,"y":15},{"x":4,"y":15},{"x":4,"y":14},{"x":5,"y":14},{"x":5,"y":13},{"x":4,"y":13},{"x":4,"y":12},{"x":5,"y":12},{"x":5,"y":11},{"x":4,"y":11},{"x":4,"y":10},{"x":5,"y":10},{"x":5,"y":9},{"x":4,"y":9},{"x":4,"y":8},{"x":5,"y":8},{"x":5,"y":7},{"x":4,"y":7},{"x":4,"y":6},{"x":5,"y":6},{"x":5,"y":5},{"x":4,"y":5},{"x":4,"y":4},{"x":5,"y":4},{"x":6,"y":4},{"x":7,"y":4},{"x":7,"y":5},{"x":6,"y":5},{"x":6,"y":6},{"x":7,"y":6},{"x":7,"y":7},{"x":6,"y":7},{"x":6,"y":8},{"x":7,"y":8},{"x":7,"y":9},{"x":6,"y":9},{"x":6,"y":10},{"x":7,"y":10},{"x":7,"y":11},{"x":6,"y":11},{"x":6,"y":12},{"x":6,"y":13},{"x":7,"y":13},{"x":7,"y":12},{"x":8,"y":12},{"x":8,"y":13},{"x":9,"y":13},{"x":9,"y":12},{"x":10,"y":12},{"x":10,"y":13},{"x":11,"y":13},{"x":11,"y":12},{"x":12,"y":12},{"x":12,"y":13},{"x":13,"y":13},{"x":13,"y":12},{"x":13,"y":11},{"x":12,"y":11},{"x":12,"y":10},{"x":13,"y":10},{"x":13,"y":9},{"x":12,"y":9},{"x":12,"y":8},{"x":13,"y":8},{"x":13,"y":7},{"x":12,"y":7},{"x":12,"y":6},{"x":13,"y":6},{"x":13,"y":5},{"x":12,"y":5},{"x":12,"y":4},{"x":13,"y":4},{"x":13,"y":3},{"x":13,"y":2},{"x":12,"y":2},{"x":12,"y":3},{"x":11,"y":3},{"x":11,"y":2},{"x":10,"y":2},{"x":10,"y":3},{"x":10,"y":4},{"x":11,"y":4},{"x":11,"y":5},{"x":10,"y":5},{"x":10,"y":6},{"x":11,"y":6},{"x":11,"y":7},{"x":10,"y":7},{"x":10,"y":8},{"x":11,"y":8},{"x":11,"y":9},{"x":10,"y":9},{"x":10,"y":10},{"x":11,"y":10},{"x":11,"y":11},{"x":10,"y":11},{"x":9,"y":11},{"x":8,"y":11},{"x":8,"y":10},{"x":9,"y":10},{"x":9,"y":9},{"x":8,"y":9},{"x":8,"y":8},{"x":9,"y":8},{"x":9,"y":7},{"x":8,"y":7},{"x":8,"y":6},{"x":9,"y":6},{"x":9,"y":5},{"x":8,"y":5},{"x":8,"y":4},{"x":9,"y":4},{"x":9,"y":3},{"x":9,"y":2},{"x":8,"y":2},{"x":8,"y":3},{"x":7,"y":3},{"x":7,"y":2},{"x":6,"y":2},{"x":6,"y":3},{"x":5,"y":3},{"x":5,"y":2},{"x":4,"y":2},{"x":4,"y":3},{"x":3,"y":3},{"x":3,"y":2},{"x":2,"y":2},{"x":2,"y":3},{"x":1,"y":3},{"x":0,"y":3},{"x":0,"y":2},{"x":1,"y":2},{"x":1,"y":1},{"x":0,"y":1},{"x":0,"y":0}]
      }
    };
    
    function initHamiltonianCanvas() {
      if (!hamiltonianPathCanvas) return;
      
      const container = hamiltonianPathCanvas.parentElement;
      const maxSize = Math.min(600, window.innerWidth - 100);
      const cellSize = Math.floor(maxSize / GRID_SIZE);
      const canvasSize = cellSize * GRID_SIZE;
      
      hamiltonianPathCanvas.width = canvasSize;
      hamiltonianPathCanvas.height = canvasSize;
      hamiltonianPathCanvas.style.width = canvasSize + 'px';
      hamiltonianPathCanvas.style.height = canvasSize + 'px';
      
      canvasCtx = hamiltonianPathCanvas.getContext('2d');
      canvasCellSize = cellSize;
      
      drawHamiltonianCanvas();
    }
    
    function drawHamiltonianCanvas() {
      if (!canvasCtx || !hamiltonianPathCanvas) return;
      
      const ctx = canvasCtx;
      const cellSize = canvasCellSize;
      
      // Clear canvas
      ctx.fillStyle = 'rgba(10, 10, 30, 1)';
      ctx.fillRect(0, 0, hamiltonianPathCanvas.width, hamiltonianPathCanvas.height);
      
      // Draw grid
      ctx.strokeStyle = 'rgba(0, 245, 255, 0.2)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= GRID_SIZE; i++) {
        const pos = i * cellSize;
        ctx.beginPath();
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, GRID_SIZE * cellSize);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, pos);
        ctx.lineTo(GRID_SIZE * cellSize, pos);
        ctx.stroke();
      }
      
      // Draw visited cells
      const visited = new Set();
      currentPath.forEach((cell, index) => {
        const key = `${cell.x},${cell.y}`;
        if (visited.has(key)) {
          // Duplicate - highlight in red
          ctx.fillStyle = 'rgba(255, 0, 64, 0.5)';
        } else {
          visited.add(key);
          // Normal visited cell
          const alpha = 0.3 + (index / currentPath.length) * 0.4;
          ctx.fillStyle = `rgba(0, 245, 255, ${alpha})`;
        }
        ctx.fillRect(cell.x * cellSize, cell.y * cellSize, cellSize, cellSize);
      });
      
      // Draw path lines
      if (currentPath.length > 1) {
        ctx.strokeStyle = '#00f5ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(
          currentPath[0].x * cellSize + cellSize / 2,
          currentPath[0].y * cellSize + cellSize / 2
        );
        for (let i = 1; i < currentPath.length; i++) {
          ctx.lineTo(
            currentPath[i].x * cellSize + cellSize / 2,
            currentPath[i].y * cellSize + cellSize / 2
          );
        }
        ctx.stroke();
      }
      
      // Highlight start cell (0, 0)
      ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
      ctx.fillRect(0, 0, cellSize, cellSize);
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 2;
      ctx.strokeRect(0, 0, cellSize, cellSize);
      
      // Highlight current cell
      if (lastCell) {
        ctx.fillStyle = 'rgba(255, 107, 53, 0.5)';
        ctx.fillRect(lastCell.x * cellSize, lastCell.y * cellSize, cellSize, cellSize);
      }
      
      // Update stats
      const totalCells = GRID_SIZE * GRID_SIZE;
      const uniqueVisited = new Set();
      currentPath.forEach(c => uniqueVisited.add(`${c.x},${c.y}`));
      const remaining = totalCells - uniqueVisited.size;
      if (hamiltonianStep) hamiltonianStep.textContent = currentPath.length;
      if (hamiltonianTotal) hamiltonianTotal.textContent = totalCells + 1; // Show expected total (400 + return to start)
      if (hamiltonianRemaining) hamiltonianRemaining.textContent = remaining;
      
      // Update status
      updateHamiltonianStatus();
    }
    
    function updateHamiltonianStatus() {
      if (!hamiltonianPathStatus) return;
      
      const totalCells = GRID_SIZE * GRID_SIZE;
      const isValid = validateHamiltonianPath();
      
      // Check for duplicates, but allow (0,0) at start and end for valid cycles
      const visited = new Map(); // Use Map to count occurrences
      currentPath.forEach((cell, index) => {
        const key = `${cell.x},${cell.y}`;
        visited.set(key, (visited.get(key) || 0) + 1);
      });
      
      // Check for actual duplicates (excluding valid (0,0) at start/end)
      const duplicates = [];
      visited.forEach((count, key) => {
        if (count > 1) {
          // Allow (0,0) to appear twice only if it's at start and end of a complete cycle
          if (key === '0,0' && count === 2 && 
              currentPath.length === totalCells + 1 &&
              currentPath[0].x === 0 && currentPath[0].y === 0 &&
              currentPath[currentPath.length - 1].x === 0 && currentPath[currentPath.length - 1].y === 0) {
            // This is a valid cycle completion, not a duplicate
            return;
          }
          // Any other duplicate is invalid
          duplicates.push(key);
        }
      });
      
      const uniqueVisited = new Set();
      currentPath.forEach(c => uniqueVisited.add(`${c.x},${c.y}`));
      const remaining = totalCells - uniqueVisited.size;
      
      if (currentPath.length === 0) {
        hamiltonianPathStatus.textContent = 'Click and drag to start drawing the path';
        hamiltonianPathStatus.style.background = 'rgba(0, 245, 255, 0.2)';
        hamiltonianPathStatus.style.color = '#00f5ff';
      } else if (duplicates.length > 0) {
        hamiltonianPathStatus.textContent = `⚠️ Duplicate cells detected! Path has duplicate(s): ${duplicates.join(', ')}`;
        hamiltonianPathStatus.style.background = 'rgba(255, 0, 64, 0.3)';
        hamiltonianPathStatus.style.color = '#ff0040';
      } else if (!isValid.continuous) {
        hamiltonianPathStatus.textContent = '⚠️ Path is not continuous (all cells must be adjacent)';
        hamiltonianPathStatus.style.background = 'rgba(255, 107, 53, 0.3)';
        hamiltonianPathStatus.style.color = '#ff6b35';
      } else if (remaining > 0) {
        hamiltonianPathStatus.textContent = `Drawing... ${remaining} unique cells remaining. Return to (0,0) to complete the cycle.`;
        hamiltonianPathStatus.style.background = 'rgba(255, 107, 53, 0.2)';
        hamiltonianPathStatus.style.color = '#ff6b35';
      } else if (remaining === 0 && currentPath.length === totalCells) {
        // All unique cells visited, but haven't returned to start yet
        hamiltonianPathStatus.textContent = 'All cells visited! Return to (0,0) to complete the cycle.';
        hamiltonianPathStatus.style.background = 'rgba(255, 255, 0, 0.2)';
        hamiltonianPathStatus.style.color = '#ffeb3b';
      } else if (isValid.valid) {
        hamiltonianPathStatus.textContent = '✅ Valid Hamiltonian path! Click SAVE to use it.';
        hamiltonianPathStatus.style.background = 'rgba(0, 255, 0, 0.3)';
        hamiltonianPathStatus.style.color = '#00ff00';
      } else {
        hamiltonianPathStatus.textContent = isValid.error || 'Path incomplete';
        hamiltonianPathStatus.style.background = 'rgba(255, 107, 53, 0.3)';
        hamiltonianPathStatus.style.color = '#ff6b35';
      }
    }
    
    function validateHamiltonianPath() {
      if (currentPath.length === 0) {
        return { valid: false, error: 'Path is empty', continuous: true };
      }
      
      // Check starts at (0, 0)
      if (currentPath[0].x !== 0 || currentPath[0].y !== 0) {
        return { valid: false, error: 'Path must start at top-left corner (0, 0)', continuous: true };
      }
      
      // Check ends at (0, 0) - but allow it to be the same as start for cycle
      const last = currentPath[currentPath.length - 1];
      if (last.x !== 0 || last.y !== 0) {
        return { valid: false, error: 'Path must end at top-left corner (0, 0) to complete the cycle', continuous: true };
      }
      
      // For a cycle, the last cell is the same as the first, so we need exactly GRID_SIZE * GRID_SIZE cells
      // (not GRID_SIZE * GRID_SIZE + 1, because the cycle completion is implicit)
      
      // Check all cells are visited
      const totalCells = GRID_SIZE * GRID_SIZE;
      // For a Hamiltonian cycle, the path should have exactly totalCells + 1 entries
      // (400 unique cells + return to start at (0,0) = 401 total)
      const expectedLength = totalCells + 1;
      if (currentPath.length !== expectedLength) {
        return { valid: false, error: `Path has ${currentPath.length} cells, but needs exactly ${expectedLength} (${totalCells} unique cells + return to start)`, continuous: true };
      }
      
      // Check all cells visited exactly once (except (0,0) which appears at start and end for the cycle)
      const visited = new Map(); // Use Map to count occurrences
      currentPath.forEach((cell, index) => {
        const key = `${cell.x},${cell.y}`;
        visited.set(key, (visited.get(key) || 0) + 1);
      });
      
      // Check for duplicates (only (0,0) should appear twice, and only at start and end)
      const duplicates = [];
      visited.forEach((count, key) => {
        if (count > 1) {
          // Allow (0,0) to appear twice only if it's at start and end
          if (key !== '0,0' || count !== 2 || 
              currentPath[0].x !== 0 || currentPath[0].y !== 0 ||
              currentPath[currentPath.length - 1].x !== 0 || currentPath[currentPath.length - 1].y !== 0) {
            duplicates.push(key);
          }
        }
      });
      
      if (duplicates.length > 0) {
        return { valid: false, error: `Path has duplicate cell(s): ${duplicates.join(', ')}`, continuous: true };
      }
      
      // All unique cells should be visited (visited.size should equal totalCells, since (0,0) appears twice but Set only stores it once)
      // Actually, if (0,0) appears twice, the Set size will be totalCells (all unique cells including (0,0) once)
      // But we need to verify all cells are present
      const uniqueCells = new Set();
      currentPath.forEach(cell => uniqueCells.add(`${cell.x},${cell.y}`));
      if (uniqueCells.size !== totalCells) {
        return { valid: false, error: `Only ${uniqueCells.size} of ${totalCells} unique cells visited`, continuous: true };
      }
      
      // Check path is continuous
      for (let i = 0; i < currentPath.length - 1; i++) {
        const curr = currentPath[i];
        const next = currentPath[i + 1];
        const dx = Math.abs(curr.x - next.x);
        const dy = Math.abs(curr.y - next.y);
        if (dx + dy !== 1) {
          return { valid: false, error: 'Path is not continuous', continuous: false };
        }
      }
      
      return { valid: true, error: null, continuous: true };
    }
    
    function getCellFromPoint(x, y) {
      if (!hamiltonianPathCanvas) return null;
      const rect = hamiltonianPathCanvas.getBoundingClientRect();
      const canvasX = x - rect.left;
      const canvasY = y - rect.top;
      const cellX = Math.floor(canvasX / canvasCellSize);
      const cellY = Math.floor(canvasY / canvasCellSize);
      
      if (cellX >= 0 && cellX < GRID_SIZE && cellY >= 0 && cellY < GRID_SIZE) {
        return { x: cellX, y: cellY };
      }
      return null;
    }
    
    // Efficient deep copy for path arrays
    function deepCopyPath(path) {
      // Use structuredClone if available (faster than JSON), otherwise fall back
      if (typeof structuredClone !== 'undefined') {
        return structuredClone(path);
      }
      // Fallback: manual copy (faster than JSON for small arrays)
      return path.map(cell => ({ x: cell.x, y: cell.y }));
    }
    
    // Save current state to history
    function saveToHistory() {
      // Remove any future history if we're not at the end
      if (historyIndex < pathHistory.length - 1) {
        pathHistory = pathHistory.slice(0, historyIndex + 1);
      }
      
      // Add current state (save AFTER the change has been made)
      pathHistory.push({
        path: deepCopyPath(currentPath),
        lastCell: lastCell ? { x: lastCell.x, y: lastCell.y } : null
      });
      
      // Update history index
      historyIndex = pathHistory.length - 1;
      
      // Limit history size (remove oldest entries)
      if (pathHistory.length > maxHistorySize) {
        const removeCount = pathHistory.length - maxHistorySize;
        pathHistory.splice(0, removeCount);
        historyIndex -= removeCount;
      }
      
      updateUndoRedoButtons();
    }
    
    // Undo last action
    function undoPath() {
      if (historyIndex > 0) {
        historyIndex--;
        const state = pathHistory[historyIndex];
        currentPath = deepCopyPath(state.path);
        lastCell = state.lastCell ? { x: state.lastCell.x, y: state.lastCell.y } : null;
        drawHamiltonianCanvas();
        updateUndoRedoButtons();
      }
    }
    
    // Redo last undone action
    function redoPath() {
      if (historyIndex < pathHistory.length - 1) {
        historyIndex++;
        const state = pathHistory[historyIndex];
        currentPath = deepCopyPath(state.path);
        lastCell = state.lastCell ? { x: state.lastCell.x, y: state.lastCell.y } : null;
        drawHamiltonianCanvas();
        updateUndoRedoButtons();
      }
    }
    
    // Update undo/redo button states
    function updateUndoRedoButtons() {
      const undoBtn = document.getElementById('undoHamiltonianPath');
      const redoBtn = document.getElementById('redohamiltonianPath');
      if (undoBtn) {
        undoBtn.disabled = historyIndex <= 0;
        undoBtn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
      }
      if (redoBtn) {
        redoBtn.disabled = historyIndex >= pathHistory.length - 1;
        redoBtn.style.opacity = historyIndex >= pathHistory.length - 1 ? '0.5' : '1';
      }
    }
    
    // Find a straight path between two cells
    function findStraightPath(from, to) {
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      
      // Only allow horizontal or vertical paths (no diagonals)
      if (dx !== 0 && dy !== 0) {
        return null; // Not a straight horizontal or vertical line
      }
      
      const path = [];
      const steps = Math.max(Math.abs(dx), Math.abs(dy));
      const stepX = dx !== 0 ? (dx > 0 ? 1 : -1) : 0;
      const stepY = dy !== 0 ? (dy > 0 ? 1 : -1) : 0;
      
      // Check if path is clear (no cells already in path, except start and end)
      const pathSet = new Set();
      currentPath.forEach(c => pathSet.add(`${c.x},${c.y}`));
      
      for (let i = 1; i < steps; i++) {
        const x = from.x + stepX * i;
        const y = from.y + stepY * i;
        const key = `${x},${y}`;
        
        // Check if cell is already in path (and not the target)
        if (pathSet.has(key) && (x !== to.x || y !== to.y)) {
          return null; // Path blocked
        }
        
        // Check bounds
        if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) {
          return null; // Out of bounds
        }
        
        path.push({ x, y });
      }
      
      return path;
    }
    
    function addCellToPath(cell, useSmartFill = true) {
      if (!cell) return false;
      
      // If path is empty, must start at (0, 0)
      if (currentPath.length === 0) {
        if (cell.x !== 0 || cell.y !== 0) {
          currentPath.push({ x: 0, y: 0 });
          saveToHistory(); // Save AFTER adding (0,0)
        }
      }
      
      // Check if this cell is already in path
      const exists = currentPath.some(c => c.x === cell.x && c.y === cell.y);
      if (exists) {
        // Allow returning to (0,0) to complete the cycle if we've visited all unique cells
        const totalCells = GRID_SIZE * GRID_SIZE;
        const uniqueCells = new Set();
        currentPath.forEach(c => uniqueCells.add(`${c.x},${c.y}`));
        
        // Check if we've visited all unique cells (400) and trying to return to (0,0)
        if (cell.x === 0 && cell.y === 0 && 
            uniqueCells.size === totalCells &&
            currentPath[0].x === 0 && currentPath[0].y === 0) {
          // Completing the cycle - add the final (0,0)
          currentPath.push(cell);
          lastCell = cell;
          saveToHistory(); // Save AFTER adding the cell
          drawHamiltonianCanvas();
          return true;
        }
        // Otherwise, don't add duplicates
        SoundManager.playInvalidMove();
        return false;
      }
      
      // Check if cell is adjacent to last cell
      if (currentPath.length > 0) {
        const last = currentPath[currentPath.length - 1];
        const dx = Math.abs(last.x - cell.x);
        const dy = Math.abs(last.y - cell.y);
        
        if (dx + dy !== 1) {
          // Not adjacent - try smart fill if enabled
          if (useSmartFill) {
            const straightPath = findStraightPath(last, cell);
            if (straightPath && straightPath.length > 0) {
              // Found a valid straight path - add all intermediate cells
              for (const intermediateCell of straightPath) {
                currentPath.push(intermediateCell);
              }
              currentPath.push(cell);
              lastCell = cell;
              saveToHistory(); // Save AFTER adding all cells
              drawHamiltonianCanvas();
              return true;
            }
          }
          
          // Check if trying to complete cycle
          const totalCells = GRID_SIZE * GRID_SIZE;
          const uniqueCells = new Set();
          currentPath.forEach(c => uniqueCells.add(`${c.x},${c.y}`));
          if (cell.x === 0 && cell.y === 0 && uniqueCells.size === totalCells) {
            const lastDx = Math.abs(last.x - 0);
            const lastDy = Math.abs(last.y - 0);
            if (lastDx + lastDy === 1) {
              currentPath.push(cell);
              lastCell = cell;
              saveToHistory(); // Save AFTER adding the cell
              drawHamiltonianCanvas();
              return true;
            }
          }
          
          // Invalid move
          SoundManager.playInvalidMove();
          return false;
        }
      }
      
      // Valid adjacent cell - add it
      currentPath.push(cell);
      lastCell = cell;
      saveToHistory(); // Save AFTER adding the cell
      drawHamiltonianCanvas();
      return true;
    }
    
    // Event handlers
    if (hamiltonianPathBtn && hamiltonianPathModal) {
      hamiltonianPathBtn.addEventListener('click', () => {
        hamiltonianPathModal.classList.add('show');
        if (menuDropdown) menuDropdown.classList.remove('show');
        // Load saved path if exists
        const saved = localStorage.getItem('customHamiltonianPath');
        if (saved) {
          try {
            currentPath = JSON.parse(saved);
            lastCell = currentPath.length > 0 ? currentPath[currentPath.length - 1] : null;
          } catch (e) {
            currentPath = [];
            lastCell = null;
          }
        } else {
          currentPath = [];
          lastCell = null;
        }
        // Initialize history - save initial state so undo can work
        pathHistory = [];
        historyIndex = -1;
        // Save the initial state (whether empty or loaded) as the starting point
        saveToHistory();
        setTimeout(() => {
          initHamiltonianCanvas();
          updateUndoRedoButtons();
          // Focus canvas for arrow key navigation
          if (hamiltonianPathCanvas) {
            hamiltonianPathCanvas.focus();
          }
        }, 100);
      });
    }
    
    if (closeHamiltonianPath && hamiltonianPathModal) {
      closeHamiltonianPath.addEventListener('click', () => {
        hamiltonianPathModal.classList.remove('show');
      });
    }
    
    if (hamiltonianPathModal) {
      hamiltonianPathModal.addEventListener('click', (e) => {
        if (e.target === hamiltonianPathModal) {
          hamiltonianPathModal.classList.remove('show');
        }
      });
    }
    
    // Canvas drawing
    if (hamiltonianPathCanvas) {
      hamiltonianPathCanvas.addEventListener('mousedown', (e) => {
        isDrawing = true;
        const cell = getCellFromPoint(e.clientX, e.clientY);
        if (cell) {
          addCellToPath(cell);
        }
      });
      
      hamiltonianPathCanvas.addEventListener('mousemove', (e) => {
        if (isDrawing) {
          const cell = getCellFromPoint(e.clientX, e.clientY);
          if (cell && (!lastCell || cell.x !== lastCell.x || cell.y !== lastCell.y)) {
            addCellToPath(cell);
          }
        }
      });
      
      hamiltonianPathCanvas.addEventListener('mouseup', () => {
        isDrawing = false;
      });
      
      hamiltonianPathCanvas.addEventListener('mouseleave', () => {
        isDrawing = false;
      });
      
      // Touch events
      hamiltonianPathCanvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isDrawing = true;
        const touch = e.touches[0];
        const cell = getCellFromPoint(touch.clientX, touch.clientY);
        if (cell) {
          addCellToPath(cell);
        }
      });
      
      hamiltonianPathCanvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (isDrawing) {
          const touch = e.touches[0];
          const cell = getCellFromPoint(touch.clientX, touch.clientY);
          if (cell && (!lastCell || cell.x !== lastCell.x || cell.y !== lastCell.y)) {
            addCellToPath(cell);
          }
        }
      });
      
      hamiltonianPathCanvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        isDrawing = false;
      });
    }
    
    // Undo button
    const undoHamiltonianPath = document.getElementById('undoHamiltonianPath');
    if (undoHamiltonianPath) {
      undoHamiltonianPath.addEventListener('click', () => {
        undoPath();
      });
    }
    
    // Redo button
    const redoHamiltonianPath = document.getElementById('redohamiltonianPath');
    if (redohamiltonianPath) {
      redoHamiltonianPath.addEventListener('click', () => {
        redoPath();
      });
    }
    
    // Clear button
    if (clearHamiltonianPath) {
      clearHamiltonianPath.addEventListener('click', () => {
        saveToHistory(); // Save current state before clearing
        currentPath = [];
        lastCell = null;
        pathHistory = [];
        historyIndex = -1;
        drawHamiltonianCanvas();
        updateUndoRedoButtons();
      });
    }
    
    // Keyboard shortcuts for undo/redo (when modal is open)
    document.addEventListener('keydown', (e) => {
      if (!hamiltonianPathModal || !hamiltonianPathModal.classList.contains('show')) {
        return; // Modal not open, ignore
      }
      
      // Check for undo (Ctrl+Z or Cmd+Z)
      if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        undoPath();
        return;
      }
      
      // Check for redo (Ctrl+Shift+Z or Cmd+Shift+Z)
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z') {
        e.preventDefault();
        redoPath();
        return;
      }
      
      // Arrow key navigation (when modal is open)
      // Allow arrow keys to work when modal is open (not just when canvas is focused)
      if (e.key.startsWith('Arrow')) {
        if (currentPath.length === 0) {
          // If path is empty, start at (0,0) first
          if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            currentPath.push({ x: 0, y: 0 });
            lastCell = { x: 0, y: 0 };
            saveToHistory();
            drawHamiltonianCanvas();
          }
          return;
        }
        
        const last = currentPath[currentPath.length - 1];
        let nextCell = null;
        
        switch (e.key) {
          case 'ArrowUp':
            if (last.y > 0) {
              nextCell = { x: last.x, y: last.y - 1 };
            }
            break;
          case 'ArrowDown':
            if (last.y < GRID_SIZE - 1) {
              nextCell = { x: last.x, y: last.y + 1 };
            }
            break;
          case 'ArrowLeft':
            if (last.x > 0) {
              nextCell = { x: last.x - 1, y: last.y };
            }
            break;
          case 'ArrowRight':
            if (last.x < GRID_SIZE - 1) {
              nextCell = { x: last.x + 1, y: last.y };
            }
            break;
        }
        
        if (nextCell) {
          e.preventDefault();
          addCellToPath(nextCell, false); // Don't use smart fill for arrow keys
        }
      }
    });
    
    // Save button
    if (saveHamiltonianPath) {
      saveHamiltonianPath.addEventListener('click', () => {
        const validation = validateHamiltonianPath();
        if (validation.valid) {
          customHamiltonianPath = [...currentPath];
          localStorage.setItem('customHamiltonianPath', JSON.stringify(customHamiltonianPath));
          hamiltonianPath = null; // Reset default path so custom is used
          hamiltonianPathStatus.textContent = '✅ Path saved! It will be used in autodrive mode.';
          hamiltonianPathStatus.style.background = 'rgba(0, 255, 0, 0.3)';
          hamiltonianPathStatus.style.color = '#00ff00';
        } else {
          alert('Cannot save: ' + (validation.error || 'Path is invalid'));
        }
      });
    }
    
    // Export button
    if (exportHamiltonianPath) {
      exportHamiltonianPath.addEventListener('click', () => {
        if (currentPath.length === 0) {
          alert('No path to export');
          return;
        }
        const dataStr = JSON.stringify(currentPath, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'hamiltonian-path.json';
        link.click();
        URL.revokeObjectURL(url);
      });
    }
    
    // Import button
    if (importHamiltonianPath && hamiltonianPathFileInput) {
      importHamiltonianPath.addEventListener('click', () => {
        hamiltonianPathFileInput.click();
      });
      
      hamiltonianPathFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const imported = JSON.parse(event.target.result);
            // Handle both array format and object format with name
            let pathData = imported;
            if (imported && imported.path && Array.isArray(imported.path)) {
              pathData = imported.path;
            }
            if (Array.isArray(pathData) && pathData.length > 0) {
              // Save current state to history before importing
              saveToHistory();
              currentPath = pathData;
              lastCell = currentPath.length > 0 ? currentPath[currentPath.length - 1] : null;
              // Initialize history with imported path
              pathHistory = [];
              historyIndex = -1;
              saveToHistory();
              drawHamiltonianCanvas();
              updateUndoRedoButtons();
              hamiltonianPathStatus.textContent = 'Path imported. Validate and save to use it.';
              hamiltonianPathStatus.style.background = 'rgba(0, 245, 255, 0.2)';
              hamiltonianPathStatus.style.color = '#00f5ff';
              // Update dropdown if imported path has a name
              const presetSelect = document.getElementById('hamiltonianPathPreset');
              if (presetSelect && imported && imported.name) {
                presetSelect.value = imported.name;
              } else if (presetSelect) {
                presetSelect.value = '';
              }
            } else {
              alert('Invalid file format');
            }
          } catch (error) {
            alert('Error reading file: ' + error.message);
          }
        };
        reader.readAsText(file);
        e.target.value = ''; // Reset input
      });
    }
    
    // Predefined paths dropdown
    const hamiltonianPathPreset = document.getElementById('hamiltonianPathPreset');
    if (hamiltonianPathPreset) {
      hamiltonianPathPreset.addEventListener('change', (e) => {
        const presetName = e.target.value;
        if (!presetName) {
          // Clear path if "Custom / None" is selected
          saveToHistory();
          currentPath = [];
          lastCell = null;
          pathHistory = [];
          historyIndex = -1;
          drawHamiltonianCanvas();
          updateUndoRedoButtons();
          return;
        }
        
        // Load predefined path from embedded data
        const presetData = predefinedHamiltonianPaths[presetName];
        if (presetData && presetData.path && Array.isArray(presetData.path) && presetData.path.length > 0) {
          // Save current state to history before loading preset
          saveToHistory();
          currentPath = presetData.path;
          lastCell = currentPath.length > 0 ? currentPath[currentPath.length - 1] : null;
          // Initialize history with preset path
          pathHistory = [];
          historyIndex = -1;
          saveToHistory();
          drawHamiltonianCanvas();
          updateUndoRedoButtons();
          hamiltonianPathStatus.textContent = `Preset "${presetData.name || presetName}" loaded. Validate and save to use it.`;
          hamiltonianPathStatus.style.background = 'rgba(0, 245, 255, 0.2)';
          hamiltonianPathStatus.style.color = '#00f5ff';
        } else {
          console.error('Error loading predefined path: Invalid preset data');
          hamiltonianPathStatus.textContent = `Error loading preset: Invalid data`;
          hamiltonianPathStatus.style.background = 'rgba(255, 0, 64, 0.2)';
          hamiltonianPathStatus.style.color = '#ff0040';
          // Reset dropdown
          e.target.value = '';
        }
      });
    }
    
    // Load custom path on startup
    const savedPath = localStorage.getItem('customHamiltonianPath');
    if (savedPath) {
      try {
        customHamiltonianPath = JSON.parse(savedPath);
      } catch (e) {
        customHamiltonianPath = null;
      }
    }

    // Reset control positions button
    const resetControlPositions = document.getElementById('resetControlPositions');
    if (resetControlPositions) {
      resetControlPositions.addEventListener('click', () => {
        // Clear saved positions from localStorage
        localStorage.removeItem('directionControlsPosition');
        localStorage.removeItem('relativeTurnLeftPosition');
        localStorage.removeItem('relativeTurnRightPosition');
        localStorage.removeItem('splitControlLeftPosition');
        localStorage.removeItem('splitControlRightPosition');
        
        // Reset absolute direction controls to default position
        const directionControls = document.getElementById('directionControls');
        if (directionControls) {
          directionControls.style.left = '80px';
          directionControls.style.top = 'auto';
          directionControls.style.bottom = '40px';
          directionControls.style.right = 'auto';
          directionControls.style.transform = 'none';
        }
        
        // Reset relative turn controls
        const relativeTurnLeft = document.getElementById('relativeTurnLeft');
        const relativeTurnRight = document.getElementById('relativeTurnRight');
        
        if (relativeTurnLeft && relativeTurnRight) {
          // Clear their positions and reposition at bottom of game area
          relativeTurnLeft.style.left = '';
          relativeTurnLeft.style.top = '';
          relativeTurnLeft.style.bottom = '';
          relativeTurnLeft.style.right = '';
          relativeTurnLeft.style.transform = '';
          
          relativeTurnRight.style.left = '';
          relativeTurnRight.style.top = '';
          relativeTurnRight.style.bottom = '';
          relativeTurnRight.style.right = '';
          relativeTurnRight.style.transform = '';
          
          // Reposition at bottom of game area
          setTimeout(() => {
            positionRelativeControlsAtBottom();
          }, 100);
        }
        
        // Reset split controls
        const splitControlLeft = document.getElementById('splitControlLeft');
        const splitControlRight = document.getElementById('splitControlRight');
        
        if (splitControlLeft && splitControlRight) {
          // Clear their positions
          splitControlLeft.style.left = '';
          splitControlLeft.style.top = '';
          splitControlLeft.style.bottom = '';
          splitControlLeft.style.right = '';
          splitControlLeft.style.transform = '';
          
          splitControlRight.style.left = '';
          splitControlRight.style.top = '';
          splitControlRight.style.bottom = '';
          splitControlRight.style.right = '';
          splitControlRight.style.transform = '';
          
          // Reposition on sides
          setTimeout(() => {
            positionSplitControlsOnSides();
          }, 100);
        }
        
        // Play feedback sound
        SoundManager.playGlitch();
      });
    }

    // Close modals with Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (helpModal && helpModal.classList.contains('show')) {
          helpModal.classList.remove('show');
        }
        if (confirmModal && confirmModal.classList.contains('show')) {
          confirmModal.classList.remove('show');
        }
        // Control mode modal should only close with X button, not Escape
      }
    });

    // Initialize - set initial food position (cell 4, top row) for immediate catch
    food = [{ x: 4, y: 0 }];
    updateScores();
    draw();
    
    // Show start button initially
    showStartButton();
    
    // Position controls on initial load if in relative or split mode
    if (controlMode === 'relative') {
      setTimeout(() => {
        positionRelativeControlsAtBottom();
      }, 200);
    } else if (controlMode === 'split') {
      setTimeout(() => {
        positionSplitControlsOnSides();
      }, 200);
    }
    
    // Start button click handler
    if (startGameBtn) {
      startGameBtn.addEventListener('click', () => {
        startGame();
      });
    }
  </script>
</body>
</html>


